!<arch>
//              0           0     0     0       115       `
cfft32_noscale.asm/
cfft32_scale.asm/
cfft_noscale.asm/
cifft32_noscale.asm/
cifft32_scale.asm/
cifft_noscale.asm/

abias.asm/      1161799424  0     0     0       9103      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    acorr_bias
; Processor:   C55xx
; Description: calculates positive biased auto-correlation
;
; Usage:    short acorr_bias(DATA *x, DATA *r, ushort nx, ushort nr)
;
; Copyright Texas instruments Inc, 2000
; History:
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
; 
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;****************************************************************

	.ARMS_off                     ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_bias
_acorr_bias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
;REG_SAVE_SZ       .set 3            ;save-on-entry registers saved
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
	.asg    0, temp
	.asg	1, n_inverse
	.asg    0 + FRAME_SZ, SAVE_AR5
	.asg    2 + FRAME_SZ, SAVE_AR6
	.asg    4 + FRAME_SZ, SAVE_AR7
	.asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
	
	.asg	AR0, x_ptr
	.asg	AR1, r_ptr
	.asg	XAR0, Xx_ptr
	.asg	XAR1, Xr_ptr
	.asg	DR0, nx
	.asg	DR1, nr
	
	.asg    AR2, counter
	.asg    AR3, x2_save
	.asg    XAR3, Xx2_save
	.asg	AR4, odd
	.asg	AR5, x_save
	.asg	XAR5, Xx_save
	.asg    AR6, loop_count
	.asg    AR7, xb_ptr
	.asg    XAR7, Xxb_ptr
	
    ;.asg	AC2, odd
    .asg	AC1, exec
	;.asg	AC3, B
	;.asg	AC0, A

        PSH	mmap(ST1_55)
	
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP 

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
    MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 
	||BSET	FRCT			; Set FRCT

	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6 
	||BSET	SXMD			; Set SXMD

	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 
        
;
; Initialize some of the variables
;----------------------------------------------------------------
	||MOV	#0, exec

	MOV	nr, loop_count
	||MOV	#0, odd

	MOV	Xx_ptr, Xx_save

	MOV	Xx_ptr, Xx2_save
	MOV	nx, AC0
		
	SUB	#1, loop_count

;
; If the number of correlation elements to calculate is      
; exactly equal to na, then we want to calculate the last    
; 2 elements outside of the loop. Since loop assumes minimum 
; of 3 MAC operations                                        
;----------------------------------------------------------------
	||SUB	nr, AC0
	MOV	AC0, *sp(#(temp))
    
	CMP	*sp(#(temp)) == #1, TC1
	
	BCC	L0, !TC1
	
	SUB	#1, exec
	SUB	#1, loop_count
	||B	L1				  	

L0:
	CMP	*sp(#(temp)) == #0, TC1
	
	BCC	L1, !TC1
	SUB	#2, loop_count
	ADD	#1, exec

L1:

; ---- Prepare the scaling value ----
	MOV	#32767, AC0
	MOV	nx, *sp(#(temp))
	RPT	#15
	SUBC	*sp(#(temp)), AC0
	ADD	#1, AC0
	MOV	AC0, *sp(#(n_inverse))
	BSET	SXMD

; ---- If NR == #1, then we can't use the DUAL MAC loop ----
	MOV	nr, *sp(#(temp))
	CMP	*sp(#temp) == #1, TC1
	BCC	LOOP_SINGLE, TC1
	
; ---- ODD detection ----
; If we have an output buffer which is an odd number, then we need to 
; enable the extra mac which is outside of the main dual mac loop.
	BTST	@#0, nr, TC1	; Test to see if the LSB of NR is set. If 
				; it is, then we have an odd number
    .if  $isdefed("SI_BUGS")
	XCC	check1, TC1
	.else
	XCCPART	check1, TC1
	.endif
	MOV	#-1, odd	; Setup the odd flag for later use 

check1:

; Generic pointer and loop setup 
; 	Generic will be used by both normal dual mac and the odd 
;	numbered dual mac. 

	MOV	Xx_save, XCDP		; Setup CDP 	
	MOV	Xx2_save, Xx_ptr
	ADD	#1, x_ptr 
	MOV Xx_ptr,Xxb_ptr	; Setup the secondary pointer
    SUB	#1, x_ptr
 	SFTS	loop_count, #-1
    .if  $isdefed("SI_BUGS")
	XCC	check2, odd<#0		; This is only for the case where we have odd
	.else
	XCCPART	check2, odd<#0		; This is only for the case where we have odd
	.endif
	SUB	#1, loop_count		; sized input vectors. In this case we have

check2:					; moved one of the MACs out of the loop

	MOV	loop_count, BRC0
	
	MOV	nx, counter
 	SUB	#3, counter
	MOV	counter, CSR

;
; Perform correlation:                                       
;----------------------------------------------------------------
	
LOOP_DUAL:   
	RPTBLOCAL	loop1-1

; ---- Preload A ----
	MPY	*x_ptr+, *CDP+, AC0
	::MPY	*xb_ptr+, *CDP+, AC3

; ---- Main Dual MAC loop  ----
	RPTSUB	CSR, #2
	MAC	*x_ptr+, *CDP+, AC0
	::MAC	*xb_ptr+, *CDP+, AC3

; ---- Do one MAC for A, Load DR2 with B  ----
	MACM	*x_ptr, *CDP, AC0
	||MOV	HI(AC3), T2

; ---- Multiply B with inverse, Load DR3 with A  ----
	MPYMR	*sp(#(n_inverse)), T2, AC3
	||MOV	HI(AC0), T3

; ---- Multiply A with inverse, x2 incremented by to because of DUAL MAC ----
	MPYMR	*sp(#(n_inverse)), T3, AC0
	||ADD	#2, x2_save

; ---- Store A, reset CDP ----
	MOV	HI(AC0), *r_ptr+
	||MOV	x_save, CDP

; ---- Store B, reload x_pointer (used for A) with new x2_save ----
	MOV	HI(AC3), *r_ptr+
	||MOV	x2_save, x_ptr

; ---- Reload xb_ptr (used for B) with one more than x_ptr ----
	ADD	#1, x_ptr, xb_ptr		; Setup the secondary pointer
	
loop1:

	BCC	REGULAR, odd>=#0		; Goto REGULAR to regular if we 
						; didn't have the odd condition.
	
; ---- 3 -----
; If ODD, then we need to do the odd value outside of the MAC
; loop. Pointers CDP and x_ptr need to be restored at end
; of loop for following MAC instructions
	MPYM	*x_ptr+, *CDP+, AC0
	||ADD	#1, x2_save
	
	MACM	*x_ptr+, *CDP+, AC0	
	MACM	*x_ptr, *CDP, AC0

	MOV	HI(AC0), T3
	
	MPYMR	*sp(#(n_inverse)), T3, AC0
	||MOV	x_save, CDP
	
	MOV	HI(AC0), *r_ptr+
	||MOV	x2_save, x_ptr	


REGULAR:
	BCC	FINISH, exec == #0	; This is actually kinda redundant because we have the SINGLE detector now

; ---- 2 -----
	MPYM	*x_ptr+, *CDP+, AC0
	MACM	*x_ptr, *CDP-, AC0
	
	MOV	HI(AC0), T3
	MPYMR	*sp(#(n_inverse)), T3, AC0
	MOV	HI(AC0), *r_ptr+

	BCC	FINISH, exec < #0

; ---- 1 -----
	MPYM	*x_ptr, *CDP, AC0
	
	MOV	HI(AC0), T3
	MPYMR	*sp(#(n_inverse)), T3, AC0
	MOV	HI(AC0), *r_ptr+

FINISH:
; bug: original code put return value to AC0
; fix: put to T0
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV	#0, T0			;clear oflag
	
	XCCPART	check3, overflow(AC0)	;clears ACOV0
	||MOV	#1, T0			;overflow occurred

check3:
	
	XCCPART	check4, overflow(AC3)	;clears ACOV1
	||MOV	#1, T0			;overflow occurred

check4:

;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

	MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7

	BCLR	SXMD			; Clear SXMD
	||MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6

	BCLR	FRCT			; Clear FRCT
	||MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5


;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

        POP	mmap(ST1_55)

;
; Return to calling function
;----------------------------------------------------------------
	RET			; RETD

;----------------------------------------------------------------
;End of file


LOOP_SINGLE:   
; This is only used if we have the case where it is a single 
; value to calculate. The dual MAC loop cannot be used here 
; because it would overwrite neighbouring values due to 
; the dual saves. A conditional save would be cycle costly
; to have in the DUAL MAC loop
;--------------------------------------------------

; ---- Pointer setup ----
	MOV	Xx_save, XCDP	; Setup CDP 	
	MOV	Xx2_save, Xx_ptr

; ---- Counter setup ----
	MOV	nx, counter
 	SUB	#3, counter
 	MOV	counter, CSR	; Because of the CSR updates, we need to preload CSR

; ---- Preload A ----
	MPYM	*x_ptr+, *CDP+, AC0
	
; ---- MAC ----
	RPT	CSR
	MACM	*x_ptr+, *CDP+, AC0	

; ---- Multiply by inverse ----
	MOV	HI(AC0), T3
	MPYMR	*sp(#(n_inverse)), T3, AC0
	
; ---- Save ----
	MOV	HI(AC0), *r_ptr+
	
	B	FINISH			; Branch back to cleanup routines

add.asm/        1161799436  0     0     0       5553      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    ADD
; Processor:   C55xx
; Description: Implements a vector add using a single-MAC 
;              approach.
;
; Usage: ushort oflag = add (DATA *x,
;                             DATA *y,
;                             DATA *r,
;                             ushort nx,
;                             ushort scale)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

	.ARMS_off			;enable assembler for ARMS=0
	.CPL_on				;enable assembler for CPL=1
	.mmregs				;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            	;return address
REG_SAVE_SZ       .set 0            	;save-on-entry registers saved
FRAME_SZ          .set 0            	;local variables
ARG_BLK_SZ        .set 0            	;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, y_ptr           	;linear pointer for second input vector
	.asg     AR2, r_ptr           	;linear pointer for result vector

	.asg     BRC0, outer_cnt      	;outer loop count
	.asg     T0, oflag           	;returned value

ST2mask	.set  0000000000010010b 	;circular/linear pointers


	.def _add
	.text

_add:

       PSH	mmap(ST3_55)

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND 	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) + Y(i);
; ---------------------------------------------------------------

	RPTBLOCAL	loop		;start the outer loop
	ADD	*AR0+, *AR1+, AC0		;vector add of two inputs

; ---------------------------------------------------------------
; To implement scaling:
; if(scale = #1) then AC0=AC0/2;
; otherwise *r_ptr+ = AC0
; ---------------------------------------------------------------

	XCC	loop, T1!=#0		;testing for scaling
      ||SFTA	AC0, -1			;if scale=1, AC0=AC0/2
loop:	MOV	HI(AC0), *AR2+		;end of outer loop

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	MOV	#0, oflag		;clear oflag
	XCC	check, overflow(AC0)
      ||MOV	#1, oflag		;overflow occured

check:

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS
	BCLR	FRCT			;clear FRCT

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function


       POP	mmap(ST3_55)


; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------

      RET		 
		
;----------------------------------------------------------------
;End of file 	

araw.asm/       1161799443  0     0     0       7023      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    acorr_raw
; Version:     2.0
; Processor:   C55xx
; Description: calculates raw auto-correlation
; Usage:    short acorr_raw(DATA *x, DATA *r, ushort nx, ushort nr)
; Copyright Texas instruments Inc, 2000
; History:
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
; - Fixed XARx init bug (added Xx_ptr,Xx_save,Xx2_save,Xxb_ptr).
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;****************************************************************

	.ARMS_off                     ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_raw
_acorr_raw

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
;REG_SAVE_SZ       .set 3            ;save-on-entry registers saved
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 1            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
	.asg    0, temp
	.asg    0 + FRAME_SZ, SAVE_AR5
	.asg    2 + FRAME_SZ, SAVE_AR6
	.asg    4 + FRAME_SZ, SAVE_AR7
	.asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
	
	.asg	AR0, x_ptr
	.asg	XAR0, Xx_ptr
	.asg	AR1, r_ptr
	.asg	DR0, nx
	.asg	DR1, nr

	.asg    AR2, counter
	.asg    AR3, x2_save
	.asg    XAR3, Xx2_save
	.asg	AR4, odd
	.asg	AR5, x_save
	.asg	XAR5, Xx_save
	.asg    AR6, loop_count
	.asg	AR7, xb_ptr
	.asg	XAR7, Xxb_ptr

    .asg	AC1, exec
	;.asg	AC3, B
	;.asg	AC0, A
	
       PSH	mmap(ST1_55)
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 
	||BSET	SXMD			; Set SXMD

	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6
	||BSET	FRCT			; Set FRCT

	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 

;
; Initialize some of the variables
;----------------------------------------------------------------
	MOV	#0, exec			
	||MOV	nr, loop_count

	MOV	nr, AC3
	MOV	Xx_ptr, Xx_save

	MOV	Xx_ptr, Xx2_save
	SUB	#1, AC3

	MOV	nx, AC0
	BCC	LOOP_SINGLE, AC3 == #0		; We can't use dual MAC for
									; nr==#1
	SUB	#1, loop_count

;
; If the number of correlation elements to calculate is      
; exactly equal to na, then we want to calculate the last    
; 2 elements outside of the loop. Since loop assumes minimum 
; of 3 MAC operations                                        
;----------------------------------------------------------------
	||SUB	nr, AC0
	MOV	AC0, *sp(#(temp))
    
	CMP	*sp(#(temp)) == #1, TC1
	BCC	L0, !TC1
	
	SUB	#1, exec
	SUB	#1, loop_count
	||B	L1				  	

L0:
	CMP	*sp(#(temp)) == #0, TC1
	BCC	L1, !TC1

	SUB	#2, loop_count
	ADD	#1, exec

L1:
	MOV	Xx_save, XCDP		; Setup CDP 	
	
	MOV	x2_save, x_ptr
	MOV Xx_ptr, Xxb_ptr
	ADD	#1, x_ptr, xb_ptr	; Setup the secondary pointer

	SFTS	loop_count, #-1
	MOV	loop_count, BRC0
      
	MOV	nx, counter
 	SUB	#4, counter		; Changed to 4 from 3 because we want to
 					; try for the dual MAC.
	MOV	counter, CSR		; Because of the CSR updates, we need to preload CSR

;
; Perform correlation:                                       
;----------------------------------------------------------------
LOOP_DUAL:   
	RPTBLOCAL	loop1-1

; ---- Preload ----
	MPY	*x_ptr+, *CDP+, AC0
	::MPY	*xb_ptr+, *CDP+, AC3
	||ADD	#2, x2_save

; ---- Main Dual MAC loop  ----
	RPTSUB	CSR, #2
	MAC	*x_ptr+, *CDP+, AC0
	::MAC	*xb_ptr+, *CDP+, AC3
    
; ---- Do one MAC for A, and final MAC for B  ----
	MACMR	*xb_ptr, *CDP, AC3	;Create the B result
	MACM	*x_ptr+, *CDP+, AC0
	
; ---- Final MAC for A  ----
	MACMR	*x_ptr, *CDP, AC0	;Create the A result
	||AMOV	x2_save, x_ptr		; x_ptr = x2_save
    
; ---- Store A, reset CDP ----
	MOV	HI(AC0), *r_ptr+
	||MOV	x_save, CDP

; ---- Store B, reload x_pointer (used for A) with new x2_save ----
	MOV	HI(AC3), *r_ptr+
	||AMOV	x2_save, xb_ptr

; ---- Reload xb_ptr (used for B) with one more than x_ptr ----
	AMAR	*xb_ptr+		;xb_ptr = x_ptr + #1 ; Setup the secondary pointer
	
loop1:

	BCC	FINISH, exec == #0

; ---- 2 -----
	MPYM	*x_ptr+, *CDP+, AC0
	MACMR	*x_ptr, *CDP-, AC0

	MOV	HI(AC0), *r_ptr+

	BCC	FINISH, exec < #0

; ---- 1 -----
	MPYMR	*x_ptr, *CDP, AC0

	MOV	HI(AC0), *r_ptr+

FINISH:
; bug: return value originally in AC0
; put to T0
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOv	#0, T0			;clear oflag
	
	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, T0                 ;overflow occurred
	
check1:

	XCCPARt	check2, overflow(AC3)	;clears ACOV1
	||MOV	#1, T0			;overflow occurred

;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
	BCLR	SXMD			; Clear SXMD
	||MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7

	BCLR	FRCT			; Clear FRCT
	||MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6

	MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

     POP	mmap(ST1_55)

;
; Return to calling function
;----------------------------------------------------------------
	RET	; RETD
;----------------------------------------------------------------
;End of file

LOOP_SINGLE:   
; This is only used if we have the case where it is a single 
; value to calculate. The dual MAC loop cannot be used here 
; because it would overwrite neighbouring values due to 
; the dual saves. A conditional save would be cycle costly
; to have in the DUAL MAC loop
;--------------------------------------------------   

; ---- Pointer setup ----
	MOV	x_save, CDP		; Setup CDP 	
	MOV	x2_save, x_ptr

; ---- Counter setup ----
	MOV	nx, counter
 	SUB	#3, counter
	MOV	counter, CSR		; Because of the CSR updates, we need to preload CSR

; ---- Preload A ----
	MPYM	*x_ptr+, *CDP+, AC0

; ---- MAC ----		
	RPT	CSR
	MACM	*x_ptr+, *CDP+, AC0	

	MACMR	*x_ptr, *CDP, AC0	;Create the A result

; ---- Save ----
	MOV	HI(AC0), *r_ptr+
	
	B	FINISH	; Branch back to cleanup routines

arct2.asm/      1161799449  0     0     0       3770      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    atan2_16
; Processor:   C55xx
; Description: arctangent 2 implementation
; Usage:    short atan2( DATA *x2, DATA *x1, DATA *r, int *NX)
;   r[i]=arctangent(x1[i]/x2[i]) Q15 format
;   NX=number of elements in x1,x2,r
;   x1,x2 input
;   r result
;   return 0 if ok; 1 if error
;   
;  Copyright Texas instruments Inc, 2000
;****************************************************************
	.mmregs
	.cpl_on
	.arms_on
	;.model call=c55_std
;	.model mem=small

	.def	_atan2_16
;FRCT	.set	6			; FRCT bit position in ST1 (phase3)
;SATD	.set	9			; SATD bit position in ST1 (phase3)


_atan2_16:
; LOCAL VARIABLE
SP_NUM		.SET	0
;* AR0   assigned to _x
;* AR1   assigned to _y
;* AR2   assigned to _r
;* T0   assigned to _nx
	
	AADD	#-1, SP			;space for local variable
	SUB	#1, T0			;nx - 1
	MOV	T0, BRC0		;repeat nx times
	BSET	FRCT			;fractional mode set
	BSET	SATD			;saturation mode on
	RPTB	loop1-1
	MOV	*AR0 << #16, AC0
	||MOV	*AR1 << #16, AC1
	ABS	AC0
	MOV	HI(AC0), *SP(#SP_NUM)
	||ABS	AC1
	MAX	AC1, AC0
	BCC	XGTY, CARRY
	CALL	atan2
	||MANT	AC0, AC1
	::NEXP	AC0, T1
	SUB	#16384 << #16, AC0
	NEG	AC0
	||B	QUAD
XGTY
	MOV	HI(AC1), *SP(#SP_NUM)
	CALL	atan2
	||MANT	AC0, AC1
	::NEXP	AC0, T1

QUAD
	BTST	#15, *AR0+, TC1
    .if  $isdefed("SI_BUGS")
	XCC	check_1, TC1
    .else
	XCCPART	check_1, TC1
    .endif
	SUB	#32767 << #16, AC0
check_1:
    .if  $isdefed("SI_BUGS")
	XCC	check_2, TC1
    .else
	XCCPART	check_2, TC1
    .endif
	NEG	AC0
check_2:
	BTST	#15, *AR1+, TC1
    .if  $isdefed("SI_BUGS")
	XCC	check_3, TC1
    .else
	XCCPART	check_3, TC1
    .endif
	NEG	AC0
check_3:
	MOV	HI(AC0), *AR2+	

loop1:

	AADD	#1, SP
	BCLR	FRCT			;fractional mode reset
	BCLR	SATD			;saturation mode off
	MOV	#0, T0			;returned value
	||RET

;*************************************************


*****************************************************************************
; INPUT VALUE IN AC1,T1,SP_NUM
; RETURN AC1
; USE: AC0,AC1
; FRCT = 1
atan2:
	SFTS	AC1, #-1, AC2
	XOR	#1FFFh << #16, AC2
	||MOV	HI(AC1), T0

; COMPUTE 2^28/X
; Calculate Ym = 2*Ym - Ym^2*X
	.LOOP	2
; Ym: AC2_h ; X: T0
	MPY	T0, AC2, AC3
	SFTS	AC2, #-1, AC0
	MPY	AC2, AC3
	SUB	AC3, AC0
	SFTS	AC0, #2, AC2
	.ENDLOOP

; LAST ITERATION
	MPY	T0, AC2, AC3
	SFTS	AC0, #1
	MPY	AC2, AC3
	AMOV	#atancoeffs, XAR3
	SUB	AC3, AC0

	MPYM	*SP(#(SP_NUM + 1)), AC0, AC2
	SFTS	AC2, #3
	||NEG	T1
	SFTL	AC2, T1
	ADD	AC2, AC2

	SFTS	AC2, #-16
	||MOV	*AR3+ << #16, AC0
	MOV	AC2, T0
	||MOV	*AR3+ << #16, AC1
	MOV	*AR3+ << #16, AC1
	||MACR	AC0, T0, AC1, AC0
	MOV	*AR3+ << #16, AC1
	||MACR	AC0, T0, AC1, AC0
	MOV	*AR3+ << #16, AC1
	||MACR	AC0, T0, AC1, AC0
	MACR	AC0, T0, AC1, AC0
	MPYR	T0, AC0

	SFTS	AC0, #-1
	||RET

********************************************************************************

	.data    

atancoeffs:
	.word 0xfda8 ; C5 -0.009159*2*32767.999*x^5
	.word 0x118b ; C4 +0.068542*2*32767.999*x^4
	.word 0xde7c ; C3 -0.130908*2*32767.999*x^3    
	.word 0x00d9 ; C2 +0.003314*2*32767.999*x^2
	.word 0x5179 ; C1 +0.318253*2*32767.999*x^1
;	.word 0x0000 ; C0 0*x^0

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor


	

atan16.asm/     1161799456  0     0     0       1733      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    atan16
; Processor:   C55xx
; Description: Arctangent implementation
; Usage:   short atan16( DATA *x, DATA *r, int NX)
;  NX : number of element of x and r
;  r[i]=atan(x[i]) with x and r in Q15 format
;  return 0
;
;  Copyright Texas instruments Inc, 2000
;****************************************************************
	.mmregs
	.cpl_on
	.arms_on
	;.model call=c55_std
	;.model mem=small

	.def	_atan16
;FRCT	.set	6			; FRCT bit position in ST1 (phase3)

_atan16:
;* AR0   assigned to _x
;* AR1   assigned to _r
;* T0   assigned to _nx
	SUB	#1, T0			;nx-1
	MOV	T0, BRC0		;repeat nx times
	AMOV	#atancoeffs, XAR2	;pointer on coeff
	BSET	FRCT			;fractional mode
	RPTBLOCAL	loop1-1
	MOV	*AR2+ << #16, AC0	;C5
	||MOV	*AR0+, T0		;input sample
	MOV	*AR2+ << #16, AC1	;C3
	||MPYR	T0, AC0
	MOV	*AR2+ << #16, AC1	;C1
	||MACR	AC0, T0, AC1, AC0
	MPYR	T0, AC0
	||ASUB	#3, AR2			;pointer on coeff
	MACR	AC0, T0, AC1, AC0
	MPYR	T0, AC0
	MOV	HI(AC0), *AR1+		;save result

loop1:

	BCLR	FRCT			;return to standard C
	
	MOV	#0, T0			;return OK value (no possible error)
	
	||RET

;*************************************************

	.data    

atancoeffs:		; coefficients obtained from polyfit function of matlab
				; for 0 <= x <= 1 ; C0+C1*x+C2*x*x+...
	.word 2596	; C5 Q15
;	.word 0     ; C4
	.word -9464 ; C3
;	.word 0     ; C2
	.word 32617 ; C1 
;	.word 0     ; C0

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

aubias.asm/     1161799463  0     0     0       10448     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    acorr_unbias
; Processor:   C55xx
; Description: calculates positive unbiased auto-correlation
; Usage:    short acorr_unbias(DATA *x, DATA *r, ushort nx, ushort nr)
; Copyright Texas instruments Inc, 2000
; History:
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
; - Fixed XARx init bug (added Xx_ptr,Xx_save,Xx2_save,Xxb_ptr).
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;****************************************************************

	.ARMS_off                     ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_unbias
_acorr_unbias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
;REG_SAVE_SZ       .set 3            ;save-on-entry registers saved
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 3            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
	.asg    0, temp
	.asg    1, tempb
	.asg	2, exec
	.asg    0 + FRAME_SZ, SAVE_AR5
	.asg    2 + FRAME_SZ, SAVE_AR6
	.asg    4 + FRAME_SZ, SAVE_AR7
	.asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
	
	.asg	AR0, x_ptr
	.asg	XAR0, Xx_ptr
	.asg	AR1, r_ptr
	.asg	DR0, nx
	.asg	DR1, nr
	
	.asg	AR4, odd
	.asg    AR2, counter
	.asg	AR5, x_save
	.asg	XAR5, Xx_save
	.asg    AR6, loop_count
	.asg    AR7, xb_ptr
	.asg    XAR7, Xxb_ptr
	.asg    AR3, x2_save
	.asg    XAR3, Xx2_save
    
	.asg	AC2, C
	.asg	AC1, D
	;.asg	AC3, B
	;.asg	AC0, A


        PSH	mmap(ST1_55)	
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 
	||BSET	FRCT			; Set FRCT

	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6 
	||BSET	SXMD			; Set SXMD

	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 
	    
;
; Initialize some of the variables
;----------------------------------------------------------------
	||MOV	nr, loop_count
	MOV	#0, *sp(#(exec))

	MOV	Xx_ptr, Xx_save

	MOV	Xx_ptr, Xx2_save
	MOV	nx, AC0	
	
	SUB	#1, loop_count

;
; If the number of correlation elements to calculate is      
; exactly equal to na, then we want to calculate the last    
; 2 elements outside of the loop. Since loop assumes minimum 
; of 3 MAC operations                                        
;----------------------------------------------------------------
	SUB	nr, AC0
	MOV	AC0, *sp(#(temp))
    
	CMP	*sp(#(temp)) == #1, TC1
	BCC	L0, !TC1    
	
	ADD	#-1, *sp(#(exec))
	SUB	#1, loop_count
	||B	L1				  	

L0:
	CMP	*sp(#(temp)) == #0, TC1
	BCC	L1, !TC1

	SUB	#2, loop_count
	ADD	#1, *sp(#(exec))

L1:

; ---- If NR == #1, then we can't use the DUAL MAC loop ----
	MOV	nr, *sp(#(temp))
	CMP	*sp(#temp) == #1, TC1
	BCC	LOOP_SINGLE, TC1

;--------Divisor value setup----------
	MOV	nx, *sp(#(temp))	; This value is used for division
	MOV	nx, *sp(#(tempb))	; This value is used for division for the second thing
	ADD	#-1, *sp(#(tempb))
    	
; ---- ODD detection ----
; If we have an output buffer which is an odd number, then we need to 
; enable the extra mac which is outside of the main dual mac loop.
	BTST	@#0, nr, TC1		; Test to see if the LSB of NR is set. If 
					; it is, then we have an odd number
    .if  $isdefed("SI_BUGS")
	XCC	check1, TC1
	.else
	XCCPART	check1, TC1
	.endif
	MOV	#-1, odd		; Setup the odd flag for later use 
check1:		

; Generic pointer and loop setup 
; 	Generic will be used by both normal dual mac and the single loop.
;	For single loop, cycles are are lost because we setup the BRC.

	MOV	Xx_save, XCDP		; Setup CDP 	
	MOV	x2_save, x_ptr		; Setup the primary pointer
	MOV Xx_ptr, Xxb_ptr
	ADD	#1, x_ptr, xb_ptr	; Setup the secondary pointer
    
	SFTS	loop_count, #-1		; Divide loop_count by 2 so that it will
 					; it will be of the right size for the dual mac
    .if  $isdefed("SI_BUGS")
	XCC	check2, odd<#0		; This is only for the case where we have odd
	.else
	XCCPART	check2, odd<#0		; This is only for the case where we have odd
	.endif
	SUB	#1, loop_count		; sized input vectors. In this case we have
check2:
					; moved one of the MACs out of the loop
	MOV	loop_count, BRC0
    
	MOV	#15, BRC1		; This is for the division
 	||MOV	nx, counter
    
	SUB	#3, counter	
	MOV	counter, CSR		; Because of the CSR updates, we need to preload CSR

;
; Perform correlation:                                       
;----------------------------------------------------------------	
LOOP_DUAL: 
	RPTB	loop1-1

; ---- Preload ----
	MPY	*x_ptr+, *CDP+, AC0
	::MPY	*xb_ptr+, *CDP+, AC3

; ---- Main Dual MAC loop  ----
	RPTSUB	CSR, #2
	MAC	*x_ptr+, *CDP+, AC0
	::MAC	*xb_ptr+, *CDP+, AC3

; ---- Do one MAC for A, Load DR2 with B  ----
	MACM	*x_ptr+, *CDP+, AC0
	||MOV	HI(AC3), T2

; ---- Scale results ----
; Divide result by number of MACs performed, result is in 
; lower half of accumulator
;
; D<-HI(ABS(A))
; C<-HI(ABS(B))
;
; A and B are only used to give C and D the correct sign

	MOV	HI(AC0), T3
	||MOV	T2, C

	MOV	T3, AC3
	MOV	T3, AC0		;Could I have just shifted A?-yes, but 


; ---- Get ABS of C and D, update CDP and x2_save ----
	ABS	C
	||MOV	x_save, CDP

	ABS	AC3
	||ADD	#2, x2_save

; ---- Scale values ----
	BCLR	SXMD		; Set SXMD
	RPTBLOCAL	loop2-1
	SUBC	*sp(#(temp)), AC3
	SUBC	*sp(#(tempb)), C

loop2:

	BSET	SXMD		; Set SXMD

; ---- Negate if necessary ----
    .if  $isdefed("SI_BUGS")
	XCC	check3, AC0 < #0
	.else
	XCCPART	check3, AC0 < #0
	.endif
    	NEG	AC3
check3:

	MOV	T2, AC0		; for the second variable
    .if  $isdefed("SI_BUGS")
	XCC	check4, AC0 < #0
	.else
	XCCPART	check4, AC0 < #0
	.endif
    	NEG	C
check4:

; ---- Store the values, update A pointer ----
	MOV	AC3, *r_ptr+
	MOV	C, *r_ptr+
	||MOV	x2_save, x_ptr
	
; ---- Update scaling values ----
	ADD	#-2, *sp(#(temp))
	ADD	#-2, *sp(#(tempb))

; ---- B pointer update ----
	ADD	#1, x_ptr, xb_ptr	; Setup the secondary pointer	

loop1:

	BCC	REGULAR, odd>=#0	; Goto REGULAR to regular if we 
					; didn't have the odd condition.
	
; ---- 3 -----
; If ODD, then we need to do the odd value outside of the MAC
; loop. Pointers CDP and x_ptr are restored throughout
; for use in the following sections if necessary
	MPYM	*x_ptr+, *CDP+, AC0
	||ADD	#1, x2_save
    
   	RPT	#1
	MACM	*x_ptr+, *CDP+, AC0
	
	MOV	HI(AC0), T3
	
	MOV	T3, AC3
	||MOV	x_save, CDP
		
	ABS	AC3

; ---- Scale values ----
	BCLR	SXMD		; Set SXMD
	RPT	#15
	SUBC	*sp(#(temp)), AC3
	BSET	SXMD		; Set SXMD

    .if  $isdefed("SI_BUGS")    
	XCC	check5, AC0 < #0
	.else
	XCCPART	check5, AC0 < #0
	.endif
    	NEG	AC3
check5:

	MOV	AC3, *r_ptr+
	||MOV	x2_save, x_ptr

REGULAR:
	MOV	*sp(#(exec)), AC3
	BCC	FINISH, AC3 == #0

; ---- 2 -----
	MPYM	*x_ptr+, *CDP+, AC0
	MACMR	*x_ptr, *CDP-, AC0 
	MOV	HI(AC0 <<#-1), *r_ptr+

	BCC	FINISH, AC3 < #0

; ---- 1 -----
	MPYMR	*x_ptr, *CDP, AC0
	MOV	HI(AC0), *r_ptr+

FINISH:
; bug: original return value in AC0
; fix: put to T0
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV	#0, T0			;clear oflag
	
	XCCPART	check6, overflow(AC0)	;clears ACOV0
	||MOV	#1, T0			;overflow occurred
check6:	

	XCCPART	check7, overflow(AC3)	;clears ACOV1
	||MOV	#1, T0			;overflow occurred
check7:

;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
	MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7
	BCLR	FRCT			; Clear FRCT
	||MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6

	BCLR	SXMD			; Clear SXMD
	||MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5
	
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

      POP  mmap(ST1_55)

;
; Return to calling function
;----------------------------------------------------------------
	RET
;----------------------------------------------------------------
;End of file

LOOP_SINGLE:   
; This is only used if we have the case where it is a single 
; value to calculate. The dual MAC loop cannot be used here 
; because it would overwrite neighbouring values due to 
; the dual saves. A conditional save would be cycle costly
; to have in the DUAL MAC loop
;--------------------------------------------------
	MOV	nx, *sp(#(temp))	; This value is used for division
                          
	MOV	x_save, CDP		; Setup CDP 	
	MOV	x2_save, x_ptr
	MOV	nx, counter
 	SUB	#2, counter
	MOV	counter, CSR

	MPYM	*x_ptr+, *CDP+, AC0
	
	RPT	CSR
	MACM	*x_ptr+, *CDP+, AC0
	
; ---- Scale results ----
; Divide result by number of MACs performed, result is in 
; lower half of accumulator

	MOV	HI(AC0), T3
	MOV	T3, AC3
	MOV	T3, AC0		;Could I have just shifted A?-yes, but 

	ABS	AC3

; ---- Scale values ----
	BCLR	SXMD		; Clear SXMD
	RPT	#15
	SUBC	*sp(#(temp)), AC3
	BSET	SXMD		; Set SXMD

; ---- Negate if necessary ----
    .if  $isdefed("SI_BUGS")
	XCC	check8, AC0 < #0
	.else
	XCCPART	check8, AC0 < #0
	.endif
    	NEG	AC3
check8:

; ---- Save ----
	MOV	AC3, *r_ptr+

	B	FINISH		; Branch back to the ending stuff
bexp.asm/       1161799471  0     0     0       1353      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    bexp
; Version:     2.0
; Processor:   C55xx
; Description: block exponent
; Useage: short r_maxexp = bexp (DATA *x, ushort nx)
;  
; Copyright Texas instruments Inc, 2000
;-----------------------------------------------------------------------------
; Register usage
; --------------
      .asg     AR0, in_ptr  

      .global _bexp
      .text

_bexp:
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

      SUB #1,T0                        ;setup loop counter=nx-1
      MOV T0,BRC0
      MOV #020h,T0                     ;init T0 to the max exp
      ||RPTBLOCAL end_block-1          ;start main loop
      MOV *in_ptr+ << #16,AC0          ;read in the vector with 16 bits left shift
      EXP AC0,T1                       ;calculate exp and store the result into T1
      MIN T1,T0                        ;update T0 with min value
end_block:

      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
      
      RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

cbias.asm/      1161799478  0     0     0       10075     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    corr_bias
; Processor:   C55xx
; Description: biased full length correlation of two vectors
;
; Useage: ushort corr_raw(DATA *x, DATA *r, ushort nx, ushort nr)
; Copyright Texas instruments Inc, 2000
; History:
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
	.global _corr_bias
_corr_bias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
;REG_SAVE_SZ       .set 3            ;save-on-entry registers saved
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 5            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------
	

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ	
	.asg    0, temp
	.asg    1, n_inverse
	.asg    3, y_orig
	.asg    "0 + FRAME_SZ", SAVE_AR6
	.asg    "2 + FRAME_SZ", SAVE_AR7
	.asg    "4 + FRAME_SZ", SAVE_AR5
	.asg    "0 + REG_SAVE_SZ + FRAME_SZ", RETURN_ADDR
	
	.asg    AR3, mac_cnt
	.asg    AR4, x_save
	.asg    AR6, x2_save
	.asg	AR5, y_save    
	.asg    AR7, region1_and_3_loop_cnt
	.asg    XAR4, Xx_save
	.asg    XAR6, Xx2_save
	.asg	XAR5, Xy_save
	
	.asg	AR0, x_ptr
	.asg	AR1, y_ptr
	.asg	AR2, r_ptr
	.asg	XAR0, Xx_ptr
	.asg	XAR1, Xy_ptr
	.asg	XAR2, Xr_ptr
	
	.asg	DR0, nx
	.asg	DR1, ny
	
    .asg	AC2, odd
    
	.asg	AC1, B
	.asg	AC0, A
; bug: original return value in AC0
; fix: put in T0
	.asg    T0, oflag           ;returned value
	
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
        PSH mmap(ST0_55)	
        PSH mmap(ST1_55)	
        PSH mmap(ST2_55)	
        PSH mmap(ST3_55)
	
	AADD #-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP
;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 
	|| BSET #ST1_SXMD, ST1_55

        MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 
	|| BSET #ST1_FRCT, ST1_55
	
	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6 

;---------- X pointer setup    
; x_ptr		-	X pointer as passed
; x_save	-	X+nx
; x2_save	-	Unchanged original X pointer
	MOV Xx_ptr, Xx2_save
	MOV Xx_ptr, A
	ADD nx, A
	MOV A, Xx_save
;
; Calculate inverse of number of MACs  = nx                 
; We load Q15 equivalent of 1 into accumulator and use SUBC 
; Thus calculating Q15 equivalent of 1/N                    
;----------------------------------------------------------------
	MOV #32767, A
	
	MOV nx, *sp(#(temp))
	
	RPT #15
	SUBC *sp(#(temp)), A, A
	
	ADD #1, A
    MOV A, *sp(#(n_inverse))
 
	BSET #ST1_SXMD, ST1_55
 	
;---------- Y pointer setup    
; y_ptr		-	Y pointer as passed
; y_orig		-	Unchainged original Y pointer
	MOV Xy_ptr, Xy_save
	MOV Xy_ptr, dbl(*sp(#(y_orig)))  ; 

    MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	
;
; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
	MOV nx, B
	SUB #4, B
	MOV B, region1_and_3_loop_cnt
	SUB #1, x_save

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
	BTST @#0, region1_and_3_loop_cnt, TC1
	MOV #0, odd
    .if  $isdefed("SI_BUGS")
	XCC temp000529, !TC1
	.else
	XCCPART temp000529, !TC1
	.endif
	MOV #-1, odd
temp000529: 

;        
; Initial lag is in region 1, load initial MAC count and      
; number of elements to calculate in region 1                 
;----------------------------------------------------------------

REGION1:
; ---- Pointer setup -----
	MOV y_save, y_ptr
	MOV x_save, x_ptr
	
; ---- Initialize BRC and mac_cnt -----
	SFTL region1_and_3_loop_cnt, #-1
    .if  $isdefed("SI_BUGS")
	XCC temp000529b, odd < #0
	.else
	XCCPART temp000529b, odd < #0
	.endif
	SUB #1, region1_and_3_loop_cnt
temp000529b:
    MOV region1_and_3_loop_cnt, BRC0
        
	MOV #0, mac_cnt
		
	MPY *x_ptr, *y_ptr+, A
	MPYMR *sp(#(n_inverse)), A, A
	MOV HI(A), *r_ptr+

; ---- 2 -----	
	MPYM *x_ptr-, *y_ptr-, A 
	MAC *x_ptr, *y_ptr, A
	MPYMR *sp(#(n_inverse)), A, A
	MOV HI(A), *r_ptr+    

; ---- Pointer stuff ----	           
	ADD #2, y_save
	MOV x_save, CDP
	MOV y_save, x_ptr
	ADD #1, x_ptr, y_ptr
						
	BCC REGION1_LOOP, odd == #0

; ---- 3 -----	
REGION1_extra_mac:
	MPYM  *x_ptr-, *CDP-, A
	MACM *x_ptr-, *CDP-, A
	MACM *x_ptr-, *CDP-, A
	
	MPYMR *sp(#(n_inverse)), A, A
	
	MOV HI(A), *r_ptr+
	
	ADD #1, y_save
	MOV Xx_save, XCDP

	MOV Xy_save, Xx_ptr
	ADD #1, x_ptr, y_ptr
	ADD #2, mac_cnt

REGION1_LOOP:
	MOV mac_cnt, CSR

	RPTBLOCAL endlocal1
    ADD #2, y_save
    
	MPY *x_ptr-, *CDP-, A :: MPY *y_ptr-, *CDP-, B
	
; ---- Main Dual MAC loop  ----   
	RPTADD CSR, #2
	MAC *x_ptr-, *CDP-, A :: MAC *y_ptr-, *CDP-, B
	
; ---- Cleanup MAC ----
	MACM *y_ptr-, *CDP-, B
	
; ---- Reload Pointers ----	
	MOV x_save, CDP
	MOV y_save, x_ptr
	ADD #1, x_ptr, y_ptr

; ---- BIAS A and B  ----
	MPYMR *sp(#(n_inverse)), A, A
	MPYMR *sp(#(n_inverse)), B, B

; ---- Store ----    
			MOV HI(A), *r_ptr+
endlocal1:	MOV HI(B), *r_ptr+ 

; ---- Reload Pointers ----	
	MOV dbl(*sp(#(y_orig))), Xy_save
	MOV x2_save, x_save

;
; Begin Loop for Region 2:                                      
;----------------------------------------------------------------

REGION2:
	MOV ny, A
	SUB nx, A
  
	MOV A, DR3
	MOV DR3, BRC0
    
	MOV nx, mac_cnt
	
	MOV x_save, x_ptr
	SUB #3, mac_cnt
	MOV y_save, y_ptr

REGION2_LOOP:
	MOV mac_cnt, CSR
	RPTBLOCAL localend2
	
; ---- Setup pointers ----
	ADD #1, y_save

; ---- Preload A ----
	MPYM *x_ptr+, *y_ptr+, A
	
; ---- Main MAC loop  ---- 
;	MOV mac_cnt, CSR
	RPT CSR
	MACM *x_ptr+, *y_ptr+, A, A	
	
; ---- Cleanup ----
	MACM *x_ptr+, *y_ptr+, A, A	
	MPYMR *sp(#(n_inverse)), A, A
	
; ---- Setup for subsequent passes through Region 2 ----     
	MOV x_save, x_ptr
	MOV y_save, y_ptr

; ---- Store ----      
localend2:	MOV HI(A), *r_ptr+

;
; Begin REGION3 loop:                                           
;----------------------------------------------------------------

REGION3:

	MOV region1_and_3_loop_cnt, BRC0
	MOV x_save, CDP
	MOV y_save, x_ptr
	ADD #1, x_ptr, y_ptr

	MOV nx, mac_cnt
	SUB #4, mac_cnt
	MOV mac_cnt, CSR


REGION3_LOOP:
	RPTBLOCAL localend3
	ADD #2, y_save

; ---- Preload A ----
	MPY *x_ptr+, *CDP+, A :: MPY *y_ptr+, *CDP+, B

; ---- Main Dual MAC loop  ----   
	RPTSUB CSR, #2
	MAC *x_ptr+, *CDP+, A :: MAC *y_ptr+, *CDP+, B

; ---- Cleanup ----     
	MACM *x_ptr, *CDP, A
	
; ---- Setup Pointers ----    
	MOV x_save, CDP
	MOV y_save, x_ptr
	ADD #1, x_ptr, y_ptr
	
; ---- BIAS A and B  ----
	MPYMR *sp(#(n_inverse)), A, A
	MPYMR *sp(#(n_inverse)), B, B
	
; ---- Store ----    
			MOV HI(A), *r_ptr+
localend3:	MOV HI(B), *r_ptr+ 
;	}

;
; Calculate last correlation elements outside of loop       
;----------------------------------------------------------------
	BCC REGION3_FINAL, odd == #0

; ---- 3 -----
	MPYM  *x_ptr+, *CDP+, A
	MACM *x_ptr+, *CDP+, A
	MACM *x_ptr+, *CDP+, A

	MPYMR *sp(#(n_inverse)), A, A
	
	MOV HI(A), *r_ptr+
	
	ADD #1, y_save
	MOV x_save, CDP
	MOV y_save, x_ptr
     
REGION3_FINAL:
; ---- 2 -----
	MPYM  *x_ptr+, *CDP+, A
	MACM *x_ptr, *CDP-, A
	MPYMR *sp(#(n_inverse)), A, A
	MOV HI(A), *r_ptr+    

; ---- 1 -----
	MPYM  *x_ptr, *CDP, A
	MPYMR *sp(#(n_inverse)), A, A
	MOV HI(A), *r_ptr+    

; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
; bug: original code put return value in A
; fix: put in oflag
	MOV #0, oflag
	
    .if  $isdefed("SI_BUGS")
	XCC dummy1, overflow(A)
	.else
	XCCPART dummy1, overflow(A)
	.endif
dummy1:  MOV #1, oflag
	
    .if  $isdefed("SI_BUGS")
	XCC dummy2, overflow(B)
	.else
	XCCPART dummy2, overflow(B)
	.endif
dummy2:	MOV #1, oflag
;                
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
	MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7
	
	MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6

	MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP
        POP mmap(ST3_55)	
        POP mmap(ST2_55)	
        POP mmap(ST1_55)	
        POP mmap(ST0_55)	
	
;
; Return to calling function
;----------------------------------------------------------------
	return ; RETD
;----------------------------------------------------------------
;End of file



cbrev.asm/      1161799491  0     0     0       6003      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;*********************************************************************
; Function:    cbrev
; Processor:   C55xx
; Description: This function performs bit-reversal of complex data array x.
;              If x==y, in-place bit reversal is performed.
; Usage:    void cbrev (DATA *x, DATA *y, ushort n)
; Copyright Texas instruments Inc, 2000
;****************************************************************

		.mmregs  
		.cpl_on   

		.sect ".text:cbrev"
        .global _cbrev   

_cbrev:

;//-----------------------------------------------------------------------------
;// Context Save
;//-----------------------------------------------------------------------------

	PSH	mmap(ST2_55)		; preserve ST2 register  

;//-----------------------------------------------------------------------------
;// Initialize
;//-----------------------------------------------------------------------------

	BSET	AR1LC			      ; circular addressing for AR1
	.arms_off
	BCLR	ARMS			      ; reset ARMS bit
	
	MOV	T0, T1			    ; n in DR1
	SFTL	T1, #1			; 2*n
	MOV	mmap(T1), BK03		; circular buffer size is 2*n 
	MOV	mmap(AR1), BSA01	      ; circular buffer offset 
     


 
      MOV T0, Hi(AC2)               ; used for log2(N) computation


;
;	Determine if in-place or off-place computation
;

	MOV	XAR1, AC0
	MOV	XAR0, AC1		     
	
	MOV	#0, AR1			 ; output pointer (circular)

	
	SUB	AC1, AC0		    ; compare input and output pointers 
	BCC	off_place, AC0 != #0; if x<>y, do off-place bit reversal

;//-----------------------------------------------------------------------------
;// In-place bit reversal
;//-----------------------------------------------------------------------------
in_place: 

	BSET	AR0LC			; circular addressing for AR0
	BSET	AR2LC			; circular addressing for AR2
	BSET	AR4LC			; circular addressing for AR4
	BSET	AR3LC			; circular addressing for AR3
	
	MOV	mmap(AR0), BSA23	; circular buffer offset 
	MOV	mmap(AR0), BSA45	; circular buffer offset
	MOV	mmap(AR0), BSA01	; circular buffer offset 

 	MOV	#0, AR0			 ; output pointer (circular)
 	MOV	#0, AR3			 ; output pointer (circular)
 	MOV	#0, AR2			 ; output pointer (circular)
 	MOV	#0, AR4			 ; output pointer (circular)

;
;    Initialize extended part of XARn
;

    MOV    XAR0,XAR2
    MOV    XAR0,XAR3
    MOV    XAR0,XAR4

;
;    Compute log2(N)
;

	EXP AC2, T1				; Hi(AC2) = N
    MOV #14, AC2
    SUB T1,AC2				; AC2 = log2(N)


;
;	Test if log2(N) is odd
;

	AND #1, AC2, AC3
	BCC	log2n_odd, AC3 != #0	; branch to log2(N) odd processing
	
;
; 	process for log2(N) even
;	

 
;
;   Compute 2^[log2(N)/2]-1           
;                               
           SFTL AC2, #-1			; log2(N)/2
           MOV AC2, T1
           NEG T1
           MOV T0, AC2
           SFTL AC2,T1              ; 2^[log2(N)/2]				
           
           SUB     #2, AC2, AC3
           MOV     AC3,mmap(BRC0)   ; 2^[log2(N)/2]-2 
            
           MOV     AC2,T0
           SFTL    AC2, #1 
           MOV     AC2,T1             
                                      
           MOV     #0,AC2  

            RPTBLOCAL even_loop
              MOV   AC2,mmap(BRC1)
              AMAR  *(AR0+T0B)
              AMAR  *(AR2+T1)
              AMOV  AR0,AR4
           || ADD #1,AC2
              AMOV  AR2,AR3
           || RPTBLOCAL even_loop
                ; loop starts here
                MOV dbl(*AR4),AC0
                MOV dbl(*AR3),dbl(*(AR4+T1))
                
even_loop:
				MOV AC0,dbl(*(AR3+T0B))

	B	end  
log2n_odd:


;
;   Compute 2^[(log2(N)-1)/2]           
;    
		   SUB #1,AC2               ;  log2(N)-1          
           SFTL AC2, #-1			; (log2(N)-1)/2
           MOV AC2, T1
           ADD #1, T1
           NEG T1
           MOV T0, AC2
           SFTL AC2,T1				;2^[(log2(N)-1)/2]
           

			SUB    #2, AC2, AC3
            MOV    AC3,mmap(BRC0) 
            SFTL   AC2, #1   
            MOV    AC2,T0
            SFTL   AC2, #1 
            MOV    AC2,T1             
            
            MOV     #1,AC2
            RPTBLOCAL  odd_loop
              MOV   AC2,mmap(BRC1)
              AMAR  *(AR0+T0B)
              AMAR  *(AR0+T0B)
              AMAR  *(AR2+T1)
              AMOV  AR0,AR4
           || ADD #2,AC2
              AMOV  AR2,AR3
           || RPTBLOCAL odd_loop
                ; loop starts here
                MOV dbl(*AR4),AC0
                MOV dbl(*AR3),dbl(*(AR4+T0))
                
odd_loop:
				MOV AC0,dbl(*(AR3+T0B))

	B	end  
	 
	
;//-----------------------------------------------------------------------------
;// Off-place bit reversal
;//-----------------------------------------------------------------------------
off_place: 

;TEST

   
;	MOV	T0, T1			    ; n in DR1
;	SFTL	T1, #1			; 2*n
;	MOV	mmap(T1), BK03		; circular buffer size is 2*n 
;	MOV	mmap(AR1), BSA01	; circular buffer offset      
 ;	MOV	#0, AR1			    ; output pointer (circular)


;END TEST

 	MOV	T0, T1			    ; n in DR1
	SUB	#1, T1
	MOV	mmap(T1), BRC0		; BRC0 = n - 1 						
 
	RPTBLOCAL	loop2-1            
	MOV	dbl(*AR0+), AC0
	MOV	AC0, dbl(*(AR1+T0B))  

loop2:

;//-----------------------------------------------------------------------------
;// Context Restore
;//-----------------------------------------------------------------------------
end:
      BSET	ARMS			; restore C environment 
	POP	mmap(ST2_55)		; restore ST2_55 register

	RET				; return   

	.end     

 
cbrev32.asm/    1161799485  0     0     0       3427      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;*********************************************************************
; Function:    cbrev32
; Processor:   C55xx
; Description: This function performs 32-bit bit-reversal of complex 
;			   data array x.
;              If x==y, in-place bit reversal is performed.
; Usage:    void cbrev32 (DATA *x, DATA *y, ushort n)
; Copyright Texas instruments Inc, 2002
;****************************************************************

		.mmregs  
		.cpl_on   

        .global _cbrev32   

_cbrev32:

;//-----------------------------------------------------------------------------
;// Context Save
;//-----------------------------------------------------------------------------

	PSH	mmap(ST2_55)		; preserve ST2 register  

;//-----------------------------------------------------------------------------
;// Initialize
;//-----------------------------------------------------------------------------

	BSET	AR1LC			; circular addressing for AR1
	.arms_off
	BCLR	ARMS			; reset ARMS bit

	MOV	T0, T1				; n in DR1
	SFTL T1, #1				; 2*n
	SFTL T1, #1				; 4*n
	MOV	mmap(T1), BK03		; circular buffer size is 4*n 
	MOV	mmap(AR1), BSA01	; circular buffer offset      
 
 	MOV	T0, T1				; n in DR1
	SUB	#1, T1
	MOV	mmap(T1), BRC0		; BRC0 = n - 1

	MOV	XAR1, AC0

	MOV	XAR0, AC1			; 
	MOV	#0, AR1				; output pointer (circular)
	SFTL T0,#1

	SUB	AC1, AC0		; compare input and output pointers 
	BCC	off_place, AC0 != #0	; if x<>y, do off-place bit reversal

;//-----------------------------------------------------------------------------
;// In-place bit reversal
;//-----------------------------------------------------------------------------
in_place: 

	BSET	AR0LC			; circular addressing for AR0
	MOV	#0, AR0

	RPTBLOCAL	loop1-1 
	MOV	dbl(*AR0+), AC0
	MOV dbl(*AR0-), AC3      
	AMOV	AR1, T1			; should be in parallel but CCS1.00b crashes
	MOV	dbl(*AR1+), AC1
	MOV dbl(*AR1-), AC2
	ASUB	AR0, T1			; should be in parallel but CCS1.00b crashes
 	XCCPART	check1, T1>=#0	; swap only if AR3 < AR2 
	||MOV	AC1, dbl(*AR0+)	; otherwise they are swapped already
check1:	
	XCCPART check2, T1>=#0
	||MOV AC2,dbl(*AR0+)
check2:
	XCCPART	check3, T1>=#0
	||MOV	AC0, dbl(*AR1+)
check3:
	XCCPART check4, T1>=#0
	|| MOV AC3, dbl(*(AR1+T0B))
check4:
	MAR *+AR1(-2)
loop1:

	B	end  
	
;//-----------------------------------------------------------------------------
;// Off-place bit reversal
;//-----------------------------------------------------------------------------
off_place:  						
 
	RPTBLOCAL	loop2-1            
	MOV	dbl(*AR0+), AC0
	MOV dbl(*AR0+), AC1
	MOV AC0, dbl(*AR1+)
	MOV	AC1, dbl(*(AR1+T0B))  
	MAR *+AR1(-2)
loop2:

;//-----------------------------------------------------------------------------
;// Context Restore
;//-----------------------------------------------------------------------------
end:
    BSET	ARMS			; restore C environment
	POP	mmap(ST2_55)		; restore ST2 register

	RET				; return   

	.end     



/0              1161799497  0     0     0       11863     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Descripac1on: 32-bit radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
; Usage:    void cfft32_NOSCALE (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2002
; History:
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;***********************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
; 	ar0       ->    fftdata pointer
; 	t0        ->    fft size
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Array declaraac1ons
;-----------------------------------------------------------------------

        .ref twiddle32

        .def _cfft32_NOSCALE     	; make funcac1on visible to other fnct
        .cpl_on
        .arms_off     				; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
        
;-----------------------------------------------------------------------  
; Stack frame
;-----------------------------------------------------------------------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-enac0y registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

;-----------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------            
       .asg    0, data_pac0
       .asg    1, data_sz

;-----------------------------------------------------------------------
; Temp data
;-----------------------------------------------------------------------
		.bss tempmem, 2, , 2
      
        .text           
_cfft32_NOSCALE


;-----------------------------------------------------------------------
; Save any save-on-entry registers that are used
;-----------------------------------------------------------------------
		PSH	mmap(ST0_55)
    	PSH	mmap(ST1_55)
    	PSH	mmap(ST2_55)  
    	PSH	mmap(ST3_55)
    	PSH T2
    	PSH T3
		PSHBOTH XAR5
		PSHBOTH XAR6
		PSHBOTH XAR7

;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;-----------------------------------------------------------------------
		AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;-----------------------------------------------------------------------
; Save entry values for later
;-----------------------------------------------------------------------
		MOV AR0, *sp(data_pac0) ; 
   		MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; FFT implementaac1on
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.        
;-----------------------------------------------------------------------
; Modificaac1on of status registers	  
      	BSET #FRCT, ST1_55          
      	BCLR #ARMS, ST2_55          
	  	BCLR #C54CM, ST1_55  
      
      	BSET SXMD
      	BCLR SATD
      	BSET M40
	                                   
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage
;-----------------------------------------------------------------------      
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) + (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) - (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; ar6  -> tempmem
        ;
        ; ar0-> a
        ; ar1-> b
        ; ar2-> c
        ; ar3-> d
        ;
        ; --------------------------------------------------------------        
       
    	MOV XAR0, XAR1					; AR0 contains    #(fftdata) a
    	ADD *sp(data_pac0),T0, AR1		; b: ar1 = #(fftdata+4*FFT_SIZE/4)
	
		MOV XAR1, XAR2 
		ADD T0,AR2						; c: ar2 = #(fftdata+4*FFT_SIZE/2)
 	        
    	MOV XAR2, XAR3    
		ADD T0, AR3						; d: ar3 = #(fftdata+4*3*FFT_SIZE/4)
		
		SFTS T0, #-1					;T0 = FFT_SIZE/4
		SFTS T0, #-1	
		SUB #1, T0
		
		AMOV #tempmem, XAR6
		MOV T0,BRC0
	        
    	RPTB stage12
;-----------------------------------------------------------------------
; Benchmark: 21 stages for stage1_2 loop
;-----------------------------------------------------------------------   	
		;Instruction					Ac0	Ac1	Ac2	Ac3	Ar0	Ar1	Ar2	Ar3    	
		mov dbl(*ar0), ac0				;ar				ar	br	cr	dr
		sub dbl(*ar2),ac0,ac3			;			ar-cr				
		add dbl(*ar2+),ac0,ac1			;	ar+cr				ci	
		mov dbl(*ar1),ac0				;br							
		sub ac0,dbl(*ar3+),ac2			;		dr-br				di
		mov ac2,dbl(*ar6) 	;ar6->dr-br								
	||	add ac0<<#1,ac2					;		dr+br					
		add ac2,ac1						;ar+cr+dr+br						
	|| 	mov dbl(*ar3-),ac0				;di							dr 
		mov ac1,dbl(*ar0+)				;				ai			
	|| 	sub ac2<<#1,ac1					;ar+cr-(dr+br)						
		mov ac1, dbl(*ar1+)				;					bi		 
		add dbl(*ar1),ac0,ac1			;	bi+di						 
		sub ac0, dbl(*ar1), ac2			;		bi-di					
		add ac2, ac3					;			ar-cr+bi-di				
	|| 	mov dbl(*ar2-),ac0				;ci						cr	
		mov ac3,dbl(*ar2+)				;						ci	
	|| 	sub ac2<<#1,ac3					;			ar-cr-(bi-di)				
		mov ac3, dbl(*ar3+)				;							di 
		sub ac0, dbl(*ar0), ac3			;			ai-ci				
		add dbl(*ar0),ac0				;ai+ci							
		add ac1,ac0						;ai+ci+di+bi							
	||	mov dbl(*ar6),ac2				;		dr-br					
		mov ac0, dbl(*ar0+)				;				arn			
	||	sub ac1<<#1,ac0					;ai+ci-(di+bi)							
		mov ac0, dbl(*ar1+)				;					brn		
	||	add ac2,ac3						;			ai-ci+dr-br				
		mov ac3,dbl(*ar2+)				;						crn	
	||	sub ac2<<#1,ac3					;			ai-ci-(dr-br)				
stage12:mov ac3,dbl(*ar3+)				;							drn
;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------    	
		
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )  
; register usage
; ar0->Pr, ar1->Qr, ar3->twiddle
; ar4=Re distance of butterfly
; ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main iniac1alizaac1on      	   

        ; modify ST2 to select linear or circular addressing modes
       	OR	#0x3, mmap(ST2_55)		; circular ar0,ar1        
       	MOV *sp(data_pac0), AR1		; ar1 = #fftdata  

        ; circular buffer starac1ng addresses       	     	
       	MOV mmap(@AR1),bsa01		; circular buffer start address
       	
        ; circular buffer sizes 
        MPYMK *sp(data_sz),#2,AC0	; because FRCT==1, it actually x4
        MOV mmap(@AC0_L), bk03		; bk03 = (4*FFT_SIZE-4), ar0-ar3
		MOV *sp(data_sz), T2
		SFTS T2,#-1					; T2 = FFT_SIZE/2
    	MOV T2,AR4    				; AR4 = FFT_SIZE/2(Re distance between p q)
    	SFTS T2,#-1
  	||  MOV	#4, AR6					; AR6 = group    
    	SFTS T2,#-1					; T2 = FFT_SIZE/8
    	BCC end_benchmark, T2==#0
    	MOV T2, T1					; T1 = number of butterfly,
    	MOV T2, AR5					; AR5 = stage	       	      	 		 			
    	AMOV #twiddle32, XAR3        ; AR3->twiddle	  


	    mov     #2, t0          	; moving from real->imag
        mov     #-2, t2         	; restoring cdp, and imag->real       	
                        
stage:  ; begining of a new stage
        ; stage initialization
        
        ; 1 - loop counter updates     
		SFTS AR5,#-1				; shift right stage count
	||	MOV #0,AR0		
		MOV XAR3, XCDP
		ADD #1,AR4,AR1				;AR1->QR_LOW
		ADD	#2,AR1,AR2				;AR2->QI_LOW
		   
        ; butterfly counter update		      		
        SUB #1,T1,T3        
        MOV T3, BRC1        		;butterflies loop count

        ; group counter update
        SUB #1,AR6,T3     
		MOV T3, BRC0              
       	
		RPTB group   	
;-----------------------------------------------------------------------
; Benchmark: 12 cycles for the butterfly loop
;-----------------------------------------------------------------------
       	rptb BFly 								;             (ar1,cdp)
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mac     uns(*ar1(t0)), *cdp+, ac0       ; ac0 += yil*cih (3,2)
::      mas     uns(*ar1+), *cdp+, ac1          ; ac1 -= yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mac     *ar1, uns(*(cdp+t0)), ac0       ; ac0 += yih*cil (2,3)
::      mas     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 -= yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mac     *ar1(t0), *(cdp+t0), ac0        ; ac0 += yih*cih (2,2)
::      mas     *ar1, *(cdp+t0), ac1        	; ac1 -= yrh*cih (0,2)

        add     dbl(*ar0), ac0,ac2
     	mar		*+cdp(-4)
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)

        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2

        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)

BFly:   mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #1, ar1                         ;                (4,4)      	       	
       	       	  					       	  					  					       	  					  					  					  					  					  						
		ADD AR4, AR0				;jump to next group
		ADD AR4, AR1
group:	AMAR *+CDP(4)				;CDP+4
		
		SFTS AR6,#1					;group<<1
		SFTS T1,#-1					;butterfly>>1
		SFTS AR4,#-1 				;P Q distance>>1
		BCC stage,AR5!=#0
;-----------------------------------------------------------------------
; End of radix-2 stage 
;-----------------------------------------------------------------------
				
end_benchmark:

;-----------------------------------------------------------------------
; De-allocate the local frame and argument block
;-----------------------------------------------------------------------
		AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

		;Context restore 
		POPBOTH XAR7
		POPBOTH XAR6
		POPBOTH XAR5
      	POP T3
      	POP T2 
      	POP	mmap(ST3_55)
      	POP	mmap(ST2_55)
      	POP	mmap(ST1_55)
      	POP	mmap(ST0_55)
	
		RET 
		.end         
        

/20             1161799504  0     0     0       15109     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: 32-bit radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are separately implmented for MIPS optimization.
; Usage:    void cfft32_SCALE (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2002
; History:
;    Original: 08/16/2002 ZhengTing He
;    08/19/2002 Li Yuan
;        - Changed || to :: in several dual MAC instructions
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; ar0       ->    fftdata pointer
; t0        ->    fft size
;
;-----------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------


        
        .ref twiddle32
        .def _cfft32_SCALE     		; make function visible to other fnct
        .cpl_on
        .arms_off     				; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------             
       .asg    0, data_ptr
       .asg    1, data_sz
      
        .text           
_cfft32_SCALE

;----------------------------------------------------------------
; Conditional compile
;----------------------------------------------------------------
SCALED	.set	1		; SCALED = 0 - not scaled version
						; SCALED = 1 - scaled version
						
;----------------------------------------------------------------
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

		PSH	mmap(ST0_55)
    	PSH	mmap(ST1_55)
    	PSH	mmap(ST2_55)  
    	PSH	mmap(ST3_55)
    	PSH T2
    	PSH T3
		PSHBOTH XAR5
		PSHBOTH XAR6
		PSHBOTH XAR7

;----------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
		AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;----------------------------------------------------------------
; Save entry values for later
;----------------------------------------------------------------

		MOV AR0, *sp(data_ptr) ; 
   		MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in 5 different steps:
;
;  1) - a radix-2 stage without any multiplications.
;  2) - a radix-2 stage with two groups, only the 2nd group has
;       multiplications with 0x7FFFFFFH and 0x00000000
;  3) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  4) - a radix-2 stage without scaling.
;  5) - on out-of-place bit-reversal
;-----------------------------------------------------------------------
        
;-----------------------------------------------------------------------
; Modification of status registers
;-----------------------------------------------------------------------	  
      	BSET #FRCT, ST1_55          
      	BCLR #ARMS, ST2_55          
	  	BCLR #C54CM, ST1_55  
      
      	BSET SXMD
      	BCLR SATD
      	BSET M40             
                     
      	; Define CSR for scaling loop
      	SUB #1, T0, T1                          
      	MOV T1, BRC0       			; BRC0 = fftsize - 1
		MOV XAR0,XAR1

;-----------------------------------------------------------------------
; Scaling loop: Data scaled by 2 before first stage 
;-----------------------------------------------------------------------       
	 	RPTBLOCAL scaling
     	MOV dbl(*AR1+), AC0       
     	MOV dbl(*AR1-), AC1
     ||	SFTS AC0,#-1 
     	SFTS AC1,#-1     
     ||	MOV	AC0, dbl(*AR1+)
scaling:MOV AC1, dbl(*AR1+)

;-----------------------------------------------------------------------
; Radix-2 stage 1
;-----------------------------------------------------------------------		
		MOV AR0,AR1					; AR0->fft_data 	(a)
		ADD T0,AR1 					; AR1->fft_data+n2  (b)
		MOV XAR1,XAR2				
		ADD T0,AR2					; AR2->fft_data+2*n2(c)
		MOV XAR2,XAR3
		ADD T0,AR3					; AR3->fft_data+3*n2(d)
		MOV XAR2,XAR7
		SFTS T0,#-1					; T0=fft-size/2
		SUB #1,T0,T1				; T1=fft_size/2-1
		MOV T1,BRC0

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for this loop		
;-----------------------------------------------------------------------
		RPTBLOCAL stage1		
		MOV dbl(*AR0+),AC0
		ADD dbl(*AR7),AC0,AC1		; AC1=AR+CR
		SUB dbl(*AR7+),AC0			; AC0=AR-CR
		MOV dbl(*AR0-),AC2
	||	SFTS AC1,#-1
		ADD dbl(*AR7),AC2,AC3		; AC3=AI+CI	
		SUB dbl(*AR7-),AC2			; AC2=AI-CI	
		SFTS AC0,#-1
	||	MOV AC1,dbl(*AR0+)			;(AR+CR)>>1->AR
		SFTS AC2,#-1
	||	MOV AC0,dbl(*AR7+)			;(AR-CR)>>1->CR
		SFTS AC3,#-1
	||	MOV	AC2,dbl(*AR7+)			;(AI-CI)>>1->CI
stage1:	MOV AC3,dbl(*AR0+)			;(AI+CI)>>1->AI
	

;-----------------------------------------------------------------------
; Radix-2 stage2
;-----------------------------------------------------------------------
		MOV *sp(data_ptr), AR0
	||	SFTS T0,#-1
		SUB #1,T0,T1				;T0=fft_size/4
		MOV T1,BRC0					;T1=fft_size/4-1

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for group1
;-----------------------------------------------------------------------
		RPTBLOCAL group1		
		MOV dbl(*AR0+),AC0
		ADD dbl(*AR1),AC0,AC1		; AC1=AR+BR
		SUB dbl(*AR1+),AC0			; AC0=AR-BR
		SFTS AC1,#-1
	||	MOV dbl(*AR0-),AC2
		ADD dbl(*AR1),AC2,AC3		; AC3=AI+BI
		SUB dbl(*AR1-),AC2			; AC2=AI-BI
		SFTS AC0,#-1
	||	MOV AC1,dbl(*AR0+)			; AR+BR->AR
		SFTS AC2,#-1
	||	MOV AC0,dbl(*AR1+)			; AR-BR->BR
		SFTS AC3,#-1
	||	MOV AC2,dbl(*AR1+)			; AI-BI->BI
group1: MOV AC3,dbl(*AR0+)			; AI+BI->AI


;-----------------------------------------------------------------------
; Benchmark: 13 cycles for group2	
;-----------------------------------------------------------------------	
		MOV T1,BRC0
		AMOV #twiddle32, XCDP
		MOV XAR3, XAR4			
		ADD #3,AR4					; AR4->DI_LOW

		RPTBLOCAL group2
		AMAR *AR3+					; 							AR3->DR_LOW
		MPY uns(*AR3-),*CDP+,AC0	;DR_LOW * 7FFF 				AR3->DR_HI	CDP->FFFF
	::	MPY uns(*AR4-),*CDP+,AC1    ;DI_LOW * 7FFF	 			AR4->DI_HI  
		MAC	*AR3,uns(*CDP-),AC0		;DR_HI*FFFF+DR_LOW*7FFF, 	AR3->DR_HI	CDP->7FFF
	:: 	MAC	*AR4,uns(*CDP-),AC1		;DI_HI*FFFF+DI_LOW*7FFF, 	AR4->DI_HI	
		MAC *AR3,*CDP,AC0>>#16		;DR_HI*7FFF+AC0>>16			AR3->DR_HI	CDP_>7FFF
	::	MAC *AR4,*CDP,AC1>>#16		;DI_HI*7FFF+AC1>>16			AR4->DI_HI	CDP_>7FFF				
		SUB AC1,dbl(*AR2),AC2		;AC2=CR-AC1
		ADD dbl(*AR2+),AC1			;AC1=CR+AC1					AR2->CI
		SUB AC0,dbl(*AR2),AC3		;AC3=CI-AC0			
		ADD dbl(*AR2-),AC0			;AC0=CI+AC0					AR2->CR
		SFTS AC1,#-1
	||	ADD #5, AR4					;							AR4->DI(next)
		SFTS AC3,#-1
	||	MOV AC1,dbl(*AR2+)			;AC1->CR					AR2->CI
		SFTS AC2,#-1	
	||	MOV AC3,dbl(*AR2+)			;AC3->CI					AR2->CR(next)
		SFTS AC0,#-1
	||	MOV AC2,dbl(*AR3+)			;AC2->DR					AR3->DI
group2:	MOV AC0,dbl(*AR3+)			;AC0->DI					AR3->DR(next)

;-----------------------------------------------------------------------
; End of stage 1 and 2
;----------------------------------------------------------------------- 		
		SFTS T0,#-1
		BCC end_benchmark, T0==#0

					    			 			    			    			    			    			    			    		
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )  
; 	register usage
; 	ar0->Pr, ar1->Qr, ar3->twiddle
; 	ar4=Re distance of butterfly
; 	ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main initialization     	   
		
        ; modify ST2 to select linear or circular addressing modes
       	OR	#0x3 , mmap(ST2_55)		; circular ar0,ar1   
       	MOV *sp(data_ptr), AR1		; ar1 = #fftdata  

        ; circular buffer starting addresses       	     	
       	MOV mmap(@AR1),bsa01		; circular buffer start address
       	
        ; circular buffer sizes 
        MPYMK *sp(data_sz),#2,AC0	; because FRCT==1, it actually x4
        MOV mmap(@AC0_L), bk03		; bk03 = (4*FFT_SIZE-4), ar0-ar3
        
        
		MOV *sp(data_sz), T2
		SFTS T2,#-1					; T2 = FFT_SIZE/2
	||  MOV	#4, AR6					; AR6 = group    
    	MOV T2,AR4    				; AR4 = FFT_SIZE/2(Re distance between p q)
    	
    	MOV T0,T1					; T1 = FFT_SIZE/8, nbfly
    	
    	SFTS T0,#-1					; T0=size/16
    ||	MOV #-2, T2
    	MOV T0, AR5					; AR5 is stage count
    	MOV #2,T0
    	AMOV #twiddle32, XAR3
		BCC last_stage, AR5==#0      	      	 		 				  

;-----------------------------------------------------------------------
; Beginning of the stage loop
;	 stage iniac1alizaac1on
;-----------------------------------------------------------------------
stage:  ; stage loop counter updates     
		SFTS AR5,#-1			    ; shift right stage count  

		MOV #0,AR0		
	||	MOV AR3, CDP
		ADD #1,AR4,AR1				;AR1->QR_LOW
				   
        ; butterfly counter update		      		
        SUB #1,T1,T3        
        MOV T3, BRC1        

        ; group counter update
        SUB #1,AR6,T3     
		MOV T3, BRC0              
	     	
		RPTB group   	
;-----------------------------------------------------------------------
; Benchmark: 15 cycles for butterfly loop
;-----------------------------------------------------------------------
       	rptb BFly 								;             (ar1,cdp)
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mac     uns(*ar1(t0)), *cdp+, ac0       ; ac0 += yil*cih (3,2)
::      mas     uns(*ar1+), *cdp+, ac1          ; ac1 -= yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mac     *ar1, uns(*(cdp+t0)), ac0       ; ac0 += yih*cil (2,3)
::      mas     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 -= yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mac     *ar1(t0), *(cdp+t0), ac0        ; ac0 += yih*cih (2,2)
::      mas     *ar1, *(cdp+t0), ac1        	; ac1 -= yrh*cih (0,2)	
		
        add     dbl(*ar0), ac0,ac2        
        sfts 	ac2, #-1
||		mar 	*cdp-    
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)
		sfts 	ac3, #-1
||		mar 	*cdp-
        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2
		sfts 	ac2, #-1
||		mar 	*cdp-   
        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)
		sfts 	ac3, #-1
||		mar 	*cdp-   
BFly:   mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #1, ar1                         ;                (4,4)      	       	
       	       	  					       	  					  					       	  					  					  					  					  					  						
		ADD AR4, AR0				;jump to next group
		ADD AR4, AR1
group:	AMAR *+CDP(4)				;CDP+4
		
		SFTS AR6,#1					;group<<1
		SFTS T1,#-1					;butterfly>>1
		SFTS AR4,#-1 				;P Q distance>>1
		BCC stage,AR5!=#0
;-----------------------------------------------------------------------
; END radix-2 stages (stages 3->log2(FFT_SIZE) )  
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Last stage
;-----------------------------------------------------------------------		
last_stage:
        ; stage initialization
		MOV #0,AR0	 	
		MOV AR3, CDP	      		    
		MOV #5,AR1					;AR1->QR_LOW
	
        ; group counter update
        SUB #1,AR6,T3    
		MOV T3, BRC0              
     	
		RPTB lgroup				
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mac     uns(*ar1(t0)), *cdp+, ac0       ; ac0 += yil*cih (3,2)
::      mas     uns(*ar1+), *cdp+, ac1          ; ac1 -= yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mac     *ar1, uns(*(cdp+t0)), ac0       ; ac0 += yih*cil (2,3)
::      mas     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 -= yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mac     *ar1(t0), *(cdp+t0), ac0        ; ac0 += yih*cih (2,2)
::      mas     *ar1, *(cdp+t0), ac1        	; ac1 -= yrh*cih (0,2)

        add     dbl(*ar0), ac0,ac2
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)

        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2

        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)

		mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #5, ar1                         ;                (4,4)      	       	
lgroup:	add		#4, ar0       	  				; jump to next group	       	  				
;-----------------------------------------------------------------------
; END last stage
;-----------------------------------------------------------------------
						
end_benchmark:
;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
		AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;Context restore 
		POPBOTH XAR7
		POPBOTH XAR6
		POPBOTH XAR5
      	POP T3
      	POP T2 
      	POP	mmap(ST3_55)
      	POP	mmap(ST2_55)
      	POP	mmap(ST1_55)
      	POP	mmap(ST0_55)
	
		RET 
		.end         
        

/38             1161799510  0     0     0       14473     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
; Usage:    void cfft (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2000
; History:
; 	- 07/18/2002	Sira fixed the bug in the kernal.
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; ar0       ->    fftdata pointer
; t0        ->    fft size
;
;-----------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------


        .ref twiddle		;reference to twiddle table
	         


        .def _cfft_NOSCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

		.bss tempmem, 2, , 2
		.bss tempmem1, 2, , 2 

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	


      
        .text           


_cfft_NOSCALE



;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;



      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)


      PSH T2
      PSH T3
	PSHBOTH XAR5
	PSHBOTH XAR6
	PSHBOTH XAR7

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP



;
; Save entry values for later
;----------------------------------------------------------------

	MOV AR0, *sp(data_ptr) ; 
      MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.

        
            ; save all save-on-entry regs that are modified
            


;-----------------------------------------------------------------------
; Modification of status registers

	  
        BSET #FRCT, ST1_55          
        BCLR #ARMS, ST2_55          
	  BCLR #C54CM, ST1_55  
   



              
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage


    ; --------------------------------------------------------------        
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) + (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) - (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; ar7, -> temp
        ; ar6  -> temp1
        ;
        ; ar0-> a
        ; ar1-> b
        ; ar2-> c
        ; ar3-> d
        ;
        ; ar5 = ar2
        ;
        ; t0 = 1
        ; t1 = 2
        ;       
        ;
        ; ac0-ac3 modified
        ; t1-t2 modified
        ;
        ; --------------------------------------------------------------        


       
    ; AR0 contains    #(fftdata)                 ; a
	
	  MOV  XAR0, XAR2
      ADD  *sp(data_sz), AR2			; c: ar2 = #(fftdata + 2*2*FFT_SIZE/4)
     
      SFTS T0, #-1					; T0 = FFT_SIZE/2
      mov xar2, xar3    
    MOV  XAR0, XAR1
	ADD  *sp(data_ptr), T0, AR1			; b: ar1 = #(fftdata + 1*2*FFT_SIZE/4)
	

      ADD  T0, AR3					; d: ar3 = #(fftdata + 3*2*FFT_SIZE/4)
      SFTS T0, #-1					;T0 = FFT_SIZE/4
	
      SUB #2, T0
	
	AMOV #(tempmem1), XAR7
      AMOV #tempmem, XAR6
       

	MOV #2, T1 							; 
	||MOV dbl(*AR0), AC0					; in (ar,ai)
       
      MOV T0, BRC0
	||ADD	dual(*AR2), AC0, AC2	 		; (ar+cr)/ ; (ai+ci) 
			    		   
	 		    		    		   
	 		    		    		    		   
	 		    		    		    		    		    		   
    
    MOV XAR2, XAR5 
    MOV #1, 	T0 
       
    MOV dbl(*AR1) ,AC1 				; in (br,bi)
	||	MOV AC2, dbl(*AR6) 		; temp (ar+cr),(ai+ci)   
    
    SUB	dual(*AR3), AC1, AC2   		; (br-dr)/(bi-di)
	 		
    
        
    SUB	dual(*AR2+), AC0    		; (ar-cr)/(ai-ci) 
    || MOV Hi(AC2),T3 	                    ; move (br-dr)
    
  	ADD	dual(*AR3), AC1, AC3 		; (br+dr)/ (bi+di)
 	||	MOV AC2, T2				; move (bi-di)        
        	    
        
    ADD	dual(*AR6), AC3, AC0   		; (ar+cr) + (dr+br) = ar'
	                        		; (ai+ci) + (di+bi)	= ai'
	||MOV AC0, dbl(*AR7(T0))            ; (ar-cr),(ai-ci) unaligned

          
    SUB	AC3, dual(*AR6), AC3    		; (ar+cr) - (dr+br) = br'
					 		; (ai+ci) - (di+bi)	= bi'
    ||MOV AC0, dbl(*AR0+)                 ; out (ar';ai')
         
    SUBADD	T2, *AR7(T0), AC0   		; (ar-cr) - (bi-di)	= dr'
							; (ar-cr) + (bi-di)	= cr'

   ADDSUB	T3, *AR7, AC1 			; (ai-ci) + (br-dr)	= di'
 							; (ai-ci) - (br-dr)	= ci'

        
        
        
        RPTBLOCAL r4_loop
        
    
      MOV AC3, dbl(*AR1+)				; out(br', bi')								; 
	||MOV  dbl(*AR0), AC3				; in (ar,ai)
       
       MOV 	pair(HI(AC0)),dbl(*AR3+)       		; out(dr',di')
	||ADD	dual(*AR2), AC3, AC2 			; (ar+cr) 
	    							; (ai+ci)   
       
       MOV   dbl(*AR1), AC1				; in (br,bi)
	|| MOV  pair(LO(AC0)), dbl(*AR5+) 	            ; out (cr', ci')
    
    SUB	dual(*AR3), AC1, AC2      		; (br-dr)/(bi-di) 
    || MOV AC2, dbl(*AR6) 				; temp (ar+cr),(ai+ci)
    
        
   SUB	dual(*AR2+), AC3, AC0     	      ; (ar-cr)/(ai-ci) 
    || MOV  Hi(AC2), T3                         ; move(br-dr)
    
       ADD	dual(*AR3), AC1, AC3    		; (br+dr)/(bi+di) 
 	||	MOV AC2, T2 				; move (bi-di)        
        	    
        
   	ADD dual(*AR6), AC3, AC0 			; (ar+cr) + (dr+br) = ar'
						 		; (ai+ci) + (di+bi)	= ai' 
	||MOV AC0, dbl(*AR7(T0))			; (ar-cr),(ai-ci) unaligned
	  
           
   SUB	AC3, dual(*AR6), AC3     		; (ar+cr) - (dr+br) = br'
							; (ai+ci) - (di+bi)	= bi'
    ||MOV AC0, dbl(*AR0+) 
         
    SUBADD	T2, *AR7(T0), AC0    			; (ar-cr) - (bi-di)	= dr'
								; (ar-cr) + (bi-di)	= cr'

r4_loop:    ADDSUB	T3, *AR7, AC1   		; (ai-ci) + (br-dr)	= di'
 								; (ai-ci) - (br-dr)	= ci'

     
    MOV AC3, dbl(*AR1+) 				; out(br', bi')	   
    MOV pair(HI(AC0)), dbl(*AR3+)      ; out(dr',di')       
    MOV pair(LO(AC0)),	dbl(*AR5+)	    ; out (cr', ci')      




;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )
        


        ; main initialization
        ; --------------------
        
       MOV *sp(data_ptr), AR0		; ar0 = #fftdata
       
            ; 1 - circular buffer initializations

        
            ; modify ST2 to select linear or circular addressing modes
       OR	#0x57 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
         

            ; circular buffer starting addresses
        ADD #2, ar0,ar1
        MOV mmap(@ar0),bsa23       ; P  leg
        MOV mmap(@ar0),bsa45       ; P' leg    (in-place butterflies)
        MOV mmap(@ar1),bsa01       ; Q  leg
        MOV mmap(@ar1),bsa67       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
	  MOV *sp(data_sz), T0
        MOV T0, T1		; T1 =  #FFT_SIZE
	  SFTS T0, #1        
        SUB #2, T0
    
        MOV mmap(@T0_L), bk03          	; bk03 = (2*FFT_SIZE-2), 
        MOV mmap(@T0_L), bk47   ; bk47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
       MOV *sp(data_sz), T0
       SFTS T0, #-1
       SFTS T0, #-1
        
        MOV T0, ar5   ; 2*number of groups for stage 3    
        MOV #2, ar7          ; 1/2 * number of butterflies per group for stage 3
       

        AMOV #twiddle, xar3        ; not modified during iteration of the stages
        ADD #2, AR3
        MOV xar0,xar1            ; data page = data page of indata
        MOV xar0,xar2            ; data page = data page of indata
        MOV xar0,xar4   ; data page = data page of indata (in-place butterflies)
        MOV xar0,xar6   ; data page = data page of indata (in-place butterflies)
        MOV xar3,xcdp      ; data page = data page of twiddles
        

        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------


            ; 1 - loop counter updates
        
            ; butterfly counter update
       SFTS ar7, #1
    ||    MOV #0, ar4 
        SUB #2,ar7,ar0
        MOV ar0, brc1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS ar5, #-1
        SUB  #1,ar5,ar0     
        MOV ar0, brc0         

            ; stage "counter" update (t0=0 <=> last stage)
         AMOV ar0, t0

            ; 2 - pointer modifier update
                            
            ; t1 is the pointer modifier                    
    ||   SFTS  t1,#-1        

            ; 3 - index updates                  
            ; ar0 -> Qr[0]
            ; ar1 -> Qi[0]
            ; ar2 -> Pr[0]
            ; ar4 -> Pr'[0]  (performed above to use parallelism)
            ; ar6 -> Qr'[0]

 
        SFTS ar0, #1
        ADD #1, ar0,ar1
        MOV #0, ar2
    ||  MOV ar0, ar6 
        
        
        
group:  ; begining of a new group
        

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (cdp) is updated inside the loop
        
                
        RPTBLOCAL r2_loop1

        
                ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
    ||  ADD  t1,ar1       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
      ||    MOV ar3, cdp

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]

  	SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0, dbl(*(ar4+t1))   
      
                  
              
                                   
                                                                  
                                                                    
          RPTBLOCAL r2_loop2          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

        MASR	*(AR0+T1), *CDP+, AC3  
        ::MACR	*(AR1+T1), *CDP+, AC2   
            
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

        OR AC3 << #-16, AC2
                
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1, dbl(*(ar6+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop2:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0, dbl(*(ar4+t1)) 
        
                                   ; end of butterfly loop
        
r2_loop1:        MOV AC1, dbl(*(ar6+t1))      ; store last Qr':Qi'
        
                                   ; end of group loop
    
        
        BCC stage,t0!=#0       ; end of stage loop       	
   	   
        
              
end_benchmark:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP


;Context restore 
	POPBOTH XAR7
	POPBOTH XAR6
	POPBOTH XAR5
      POP T3
      POP T2 

      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)

 

	
	RET 

	.end         
        







cfft_scale.asm/ 1161799516  0     0     0       20727     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    All stages are in radix-2.
; Usage:    void cifft (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2000
; History:
; 	- 07/18/2002	Sira fixed the bug in the kernal.
;	- 07/02/2003	D. Elam added support for 8 point
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; ar0       ->    fftdata pointer
; t0        ->    fft size
;
;-------------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

	.ref	twiddle  ; include twiddle table	
	         


        .def _cfft_SCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5549
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

		.bss tempmem, 2, , 2
		.bss tempmem1, 2, , 2 

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	


      
        .text           


_cfft_SCALE



;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;

      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  

      PSH T2
      PSH T3
	PSHBOTH XAR5
	PSHBOTH XAR6
	PSHBOTH XAR7
	
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
	

;
; Save entry values for later
;----------------------------------------------------------------

	MOV AR0, *sp(data_ptr) ; 
      MOV T0, *sp(data_sz)   ;


        
 ; save all save-on-entry regs that are modified
            


;-----------------------------------------------------------------------
; Modification of status registers

	  
        BSET	FRCT
        BSET	SATD
        BSET	SXMD          
        BCLR #ARMS, ST2_55          
	  BCLR #C54CM, ST1_55 

; Define CSR for scaling loop

        SUB	#2, T0, T1                          
        MOV	T1, CSR                               ; CSR = fftsize - 2
 
;*******************************************************************************
; SCALING LOOP: Data scaled by 2 before first stage 
;*******************************************************************************
        
        MOV XAR0, XAR1                                 ; ar0 = #fftdata
        MOV	dbl(*AR0+), AC0                        ; scale by 2 - prime the pipe
        RPT	CSR
	MOV	AC0 >> #1, dual(*AR1+)
	||MOV	dbl(*AR0+), AC0
	MOV	AC0 >> #1, dual(*AR1+)

scale_loop


;*******************************************************************************
; END SCALING LOOP
;*******************************************************************************



; radix-2 stage 1
;
; 
         MOV #2, T1
         MOV XAR0, XAR2
         MOV XAR0, XAR4
         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         AADD T0, AR0               ; ar0 = fftdata + fft_size
         MOV XAR0, XAR5				; ar5 = fftdata + fft_size
         MOV T0, T2
         SFTS T2, #-1               ; T2 = fft_size/2 
         MOV T2, AR7
         SUB #2, AR7
         MOV AR7, BRC0
        
        
        
                 ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2      
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
           
       ADD	dual(*AR2), AC2, AC0 
   

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                       
                 
        RPTBLOCAL r2_loop00 -1          


        MOV dbl(*(ar0+t1)), ac2         	; load Q            
        || MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   
        
           
         ADD	dual(*AR2), AC2, AC0        ; new P   
            
          SUB	AC2, dual(*(AR2+T1)), AC1   ; new Q 
      || MOV ac0>>#1, dual(*(ar4+t1))       ; store new P  

r2_loop00:	
		 
                    
         MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   

; radix-2 stage 2
;
; groupe #1 twiddle = #1  


         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         ADD T2, AR0                ; ar0 = fftdata + fft_size/2
         MOV AR0, AR5				; ar5 = fftdata + fft_size/2  
         MOV T2, T3                 ; T3= fft_size/2
         SFTS T2, #-1               ; T2 = fft_size/4 
         SUB #2, T2
         MOV T2, BRC0               ; BRC0 = fft_size/4 - 2
       
                                	
 
                   ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
   

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                       
                 
        RPTBLOCAL r2_loop01 -1          


        MOV dbl(*(ar0+t1)), ac2         	; load Q            
        || MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   
        
           
         ADD	dual(*AR2), AC2, AC0        ; new P   
 
       SUB	AC2, dual(*(AR2+T1)), AC1   ; new Q 
      || MOV ac0>>#1, dual(*(ar4+t1))       ; store new P  

r2_loop01:	
		 
                    
         MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q    
         
         
         
 
; radix-2 stage 2
;
; groupe #2 twiddle = #-1    


         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         ADD T0, AR2				; ar2 = #fftdata + fft_size
         MOV AR2, AR4               ; ar4 = #fftdata + fft_size  
         MOV AR2, AR0
         ADD T3,  AR0               ; ar0 = #fftdata + 3/2*fft_size 
         MOV AR0, AR1
         ADD #1, AR1
         MOV AR0, AR5				; ar5 = #fftdata + 3/2*fft_size
         MOV T2, BRC0               ; ; BRC0 = fft_size/4 - 2                           	
         AMOV #twiddle, xar3		; 
         ADD #2, AR3    			; 
         MOV XAR3, XCDP				; 

                      
                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3  
       
                   ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

         
          MASR	*(AR0+T1), *CDP-, AC3
         ::MACR	*(AR1+T1), *CDP-, AC2 
        
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
                OR AC3 << #-16, AC2
         
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                             
         	   ADD	dual(*AR2), AC2, AC0            
   
                       ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

    	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
   
                                                          
        
          RPTBLOCAL r2_loop02          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi  --correct commenting!

          
        MASR	*(AR0+T1), *CDP-, AC3   
        :: MACR	*(AR1+T1), *CDP-, AC2  
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
          OR AC3 << #-16, AC2      
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1>>#1, dual(*(ar5+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop02:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
        
                                   ; end of butterfly loop
                              
            MOV ac1>>#1, dual(*(ar5+t1))  

          MOV *sp(data_sz), T0		  
		  SUB #8, T0		  
		  BCC final_stage, T0==#0  	; branch to final stage for 8-point fft

 
 
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )
        


        ; main initialization
        ; --------------------
        
       MOV *sp(data_ptr), AR0		; ar0 = #fftdata
       ;MOV  #twiddle, AR3 
            ; 1 - circular buffer initializations

        
            ; modify ST2 to select linear or circular addressing modes
       OR	#0x57 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
         

            ; circular buffer starting addresses
        ADD #2, ar0,ar1
        MOV mmap(@ar0),bsa23       ; P  leg
        MOV mmap(@ar0),bsa45       ; P' leg    (in-place butterflies)
        MOV mmap(@ar1),bsa01       ; Q  leg
        MOV mmap(@ar1),bsa67       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
	  MOV *sp(data_sz), T0
        MOV T0, T1		; T1 =  #FFT_SIZE
	  SFTS T0, #1        
        SUB #2, T0
    
        MOV mmap(@T0_L), bk03          	; bk03 = (2*FFT_SIZE-2), 
        MOV mmap(@T0_L), bk47   ; bk47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
       MOV *sp(data_sz), T0
       SFTS T0, #-1
       SFTS T0, #-1
        
        MOV T0, ar5   ; 2*number of groups for stage 3    
        MOV #2, ar7          ; 1/2 * number of butterflies per group for stage 3
       

        ;AMOV #twiddle, xar3        ; not modified during iteration of the stages
        MOV xar0,xar1            ; data page = data page of indata
        MOV xar0,xar2            ; data page = data page of indata
        MOV xar0,xar4   ; data page = data page of indata (in-place butterflies)
        MOV xar0,xar6   ; data page = data page of indata (in-place butterflies)
        MOV xar3,xcdp      ; data page = data page of twiddles
        

        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------


            ; 1 - loop counter updates
        
            ; butterfly counter update
       SFTS ar7, #1
    ||    MOV #0, ar4 
        SUB #2,ar7,ar0
        MOV ar0, brc1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS ar5, #-1
        SUB  #1,ar5,ar0     
        MOV ar0, brc0         

            ; stage "counter" update (t0=0 <=> last stage)
         AMOV ar0, t0

            ; 2 - pointer modifier update
                            
            ; t1 is the pointer modifier                    
    ||   SFTS  t1,#-1        

            ; 3 - index updates                  
            ; ar0 -> Qr[0]
            ; ar1 -> Qi[0]
            ; ar2 -> Pr[0]
            ; ar4 -> Pr'[0]  (performed above to use parallelism)
            ; ar6 -> Qr'[0]

 
        SFTS ar0, #1
        ADD #1, ar0,ar1
        MOV #0, ar2
    ||  MOV ar0, ar6 
        
        
        
group:  ; begining of a new group
        

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (cdp) is updated inside the loop
        
                
        RPTBLOCAL r2_loop1

        
                ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
    ||  ADD  t1,ar1       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
      ||    MOV ar3, cdp

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                                          
        ; --------------------------------------------------------------        
        ; DIT radix-2 butterfly
        ;
        ; Register usage:
        ; 
        ;     address registers
        ; ar0 = Qr
        ; ar1 = Qi
        ; ar2 = Pr:Pi
        ; ar4 = Pr':Pi'
        ; ar6 = Qr':Qi'
        ; cdp = Wr:Wi
        ;
        ;     temporary registers
        ; t1 pointer modifier (jump between two consecutive legs)
        ; t2, t3 - both modified
        ;
        ;     accu registers
        ; ac0, ac1, ac2, ac3 are all modified
        ; 
        ;
        ; Comments:
        ;
        ; This butterfly supports both in-place and out-if-place
        ; implementations.
        ;
        ; input data assumed to be in order (bit-reversion after fft)
        ;
        ; twiddle table
        ;   - assumed to be in bit-reversed order
        ;     - the twiddle factors stored in the tables are the pairs
        ;      {cos(2*pi*k/N) , sin(2*pi*k/N)} = {Wr[k] , -Wi[k]}
        ;   - first twiddle pair {1,0} is suppressed (since the first
        ;       butterfly is computed out of the inner loop)
        ;   - second twiddle pair {0,1} replaced by {0,-1} (-1 can be
        ;     represented with full precision but not 1)
        ;   - when inner loop starts, cdp should point to the
        ;     third twiddle pair {1/sqrt(2),1/sqrt(2)}
        ;
        ; pointer registers
        ;   ar0 -> Qr[]
        ;   ar1 -> Qi[]
        ;   ar2 -> Pr[]
        ;   ar4 -> Pr'[]
        ;   ar6 -> Qr'[]
        ;   cdp -> W[] (bit-reversed twiddle table)
        ;
        ; --------------------------------------------------------------        
        
        
          RPTBLOCAL r2_loop2          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

          
         MASR	*(AR0+T1), *CDP+, AC3   
         ::MACR	*(AR1+T1), *CDP+, AC2   
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
          OR AC3 << #-16, AC2      
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1>>#1, dual(*(ar6+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop2:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
        
                                   ; end of butterfly loop
        
r2_loop1:        MOV AC1>>#1, dual(*(ar6+t1))      ; store last Qr':Qi'
        
                                   ; end of group loop

        SUB #1, T0
        
        BCC stage,t0!=#0       ; end of stage loop       	
   	   
; last r2 stage
; no scaling performed
;
; modify ST2 to select linear or circular addressing modes
final_stage:       AND	#0xF000 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
      
         MOV #2, T1  
         MOV *sp(data_sz), T0       ; t0 = #fftsize
         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         AADD T1, AR0               ; ar0 = fftdata + 2 
         MOV #7, AR1
         ADD AR2, AR1               ; 
         MOV AR0, AR5				; ar5 = fftdata + 2 
         SFTS T0, #-1  
         SUB #2, T0
         MOV T0, BRC0               ; brc0 = fftsize/2-2 
         MOV #4, T1
         MOV ar3, cdp             
                      
              ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0, dbl(*(ar4+t1))               
                                                          
        
          RPTBLOCAL r2_loop3          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

        MASR	*(AR0+T1), *CDP+, AC3  
        ::MACR	*(AR1+T1), *CDP+, AC2   
            
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

        
         OR AC3 << #-16, AC2      
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1, dbl(*(ar5+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop3:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0, dbl(*(ar4+t1)) 
        
                                   ; end of butterfly loop
                              
                      
        MOV AC1, dbl(*(ar5+t1))
      
              
end_benchmark:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP


;Context restore 



	POPBOTH XAR7
	POPBOTH XAR6
	POPBOTH XAR5
      POP T3
      POP T2 

      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)

 

	
	RET 

	.end         
        







cfir.asm/       1161799524  0     0     0       7477      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:     Complex block fir
; Processor:   C55xx
; Description: Implements complex finite impulse response filter using
;              dual-MAC approach.  C-callable.
;
; Useage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             DATA *dbuffer,
;                             ushort nx,
;                             ushort nh)
;
;		
;	State of the registers after the call:
;
;	XAR0 contains *x
;	XAR1 contains *h
;     XAR2 contains *r
;	XAR3 contains *dbuffer
;	T0   contains nx
;     T1   contains nh
;
; Cycles: Core: 
;         Overhead:
;
; Code Size: 
;
;
; Copyright Texas instruments Inc, 1999
;----------------------------------------------------------------
; Revision History:
; 1.00  C. Iovescu  01/05/00 - Original release.
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
;
;****************************************************************
	.ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ
ST2mask  .set  0000000100010000b    ;circular pointers


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
	.asg     AR0, x_ptr           ;linear pointer
      .asg     CDP, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, db_ptr          ;circular pointer

	.asg     BSAC, h_base        ;base addr for h_ptr
	.asg     BKC, h_sz           ;circ buffer size for h_sz

	.asg     BSA45, db_base       ;base addr for db_ptr
      .asg     XAR4, xdb_base       ;extended base addr for db_ptr
      .asg     BK47, db_sz          ;circ buffer size for db_ptr
      .asg     BK47_L, db_sz_L      ;for memory mapped access

	.asg     BRC1, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

	.asg     T0, oflag


	.def    _cfir

        .text

_cfir:

        PSH	mmap(ST3_55)

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT
      
	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC
      
	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL


;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing

; h pointer
	MOV	mmap(AR1), h_base	;base address of coefficients
	MOV XAR1, XCDP

	MOV	#0, h_ptr		;point to first coefficient
	||SFTL	T1, #1			;multiply by 2 because complex numbers

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointer
	MOV	XAR3, xdb_base		;db array address
	AMAR	*AR3+			;align pointer to index location
	MOV	*AR3+, db_ptr		;index of oldest db entry
	MOV	mmap(AR3), db_base	;base address for db_ptr

	MOV	mmap(T1), db_sz		;db_sz = 2*nh

;	ADD	#2, mmap(db_sz)		;db_sz = 2*(nh+1)


; Set circular/linear ARx behavior
	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
	SFTL	T1, #-1			;restore original value
	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times


	SUB	#3, T1			;T0 = nh-3
	MOV	T1, inner_cnt		;inner loop executes nh-2 times
;
; Setup index registers
;--------------------------------------------------------------------

	AMOV	#1, T0
	AMOV	#2, T1
	
; copy the first value from the input buffer to the delay buffer
	MOV	dbl(*x_ptr+), AC0
	MOV	AC0, dbl(*db_ptr)

	
	RPTBLOCAL	loop1-1			;start the outer loop

;BENCHMARK KERNEL ******************************************************




;First tap
	
	MPY	*db_ptr, *h_ptr+, AC0	
	::MPY	*db_ptr(T0), *h_ptr+, AC1	

	MAS	*db_ptr(T0), *h_ptr+, AC0
	::MAC	*(db_ptr+T1), *h_ptr+, AC1

;Taps 2 through N_TAP
	||RPTBLOCAL	loop2-1

	MAC	*db_ptr, *h_ptr+, AC0		;part 1 of dual MAC, real
	::MAC	*db_ptr(T0), *h_ptr+, AC1	;part 1 of dual MAC, imag
	MAS	*db_ptr(T0), *h_ptr+, AC0		
	::MAC	*(db_ptr+T1), *h_ptr+, AC1

loop2:

	MAC	*db_ptr, *h_ptr+, AC0		;part 1 of dual MAC, real
	::MAC	*db_ptr(T0), *h_ptr+, AC1	;part 1 of dual MAC, imag
	MASR	*db_ptr(T0), *h_ptr+, AC0		
	::MACR	*db_ptr, *h_ptr+, AC1

	
	MOV	HI(AC0), *r_ptr+		;store result real part
	
; copy the first value from the input buffer to the delay buffer
	MOV	dbl(*x_ptr+), AC0
	MOV	AC0, dbl(*db_ptr)

 
	MOV	HI(AC1), *r_ptr+		;store result imag part

loop1:						;end of outer loop




;TERMINATION *************************************************;


;
; Update the db entry point
;----------------------------------------------------------------

	MOV	db_ptr, *-AR3			;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV	#0, oflag			;clear oflag

	XCCPART	check1, overflow(AC0)
	||MOV	#1, oflag			;overflow occurred
check1:

	XCCPART	check2, overflow(AC1)
	||MOV	#1, oflag
check2:



; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT				;clear FRCT

	AND	#0FE00h, mmap(ST2_55)		;clear CDPLC and AR[7-0]LC
      
	BSET	ARMS				;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

       POP	mmap(ST3_55)


;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	RET					;return to calling function

;----------------------------------------------------------------
;End of file


/56             1161799531  0     0     0       12150     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Descripac1on: 32-bit radix-2 DIT complex iFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
; Usage:    void cifft32_NOSCALE (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2002
; History:
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;***********************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _ifft
; 	ar0       ->    ifftdata pointer
; 	t0        ->    ifft size
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Array declaraac1ons
;-----------------------------------------------------------------------

        .ref twiddle32

        .def _cifft32_NOSCALE     	; make funcac1on visible to other fnct
        .cpl_on
        .arms_off     				; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
        
;-----------------------------------------------------------------------  
; Stack frame
;-----------------------------------------------------------------------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-enac0y registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

;-----------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------            
       .asg    0, data_pac0
       .asg    1, data_sz

;-----------------------------------------------------------------------
; Temp data
;-----------------------------------------------------------------------
		.bss tempmem, 2, , 2
      
        .text           
_cifft32_NOSCALE

;-----------------------------------------------------------------------
; Condiac1onal compile
;-----------------------------------------------------------------------
SCALED	.set	1			; SCALED = 0 - not scaled version
						; SCALED = 1 - scaled version
;-----------------------------------------------------------------------
; Save any save-on-entry registers that are used
;-----------------------------------------------------------------------
		PSH	mmap(ST0_55)
    	PSH	mmap(ST1_55)
    	PSH	mmap(ST2_55)  
    	PSH	mmap(ST3_55)
    	PSH T2
    	PSH T3
		PSHBOTH XAR5
		PSHBOTH XAR6
		PSHBOTH XAR7

;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;-----------------------------------------------------------------------
		AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;-----------------------------------------------------------------------
; Save entry values for later
;-----------------------------------------------------------------------
		MOV AR0, *sp(data_pac0) ; 
   		MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; iFFT implementation
;
; The iFFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(iFFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.        
;-----------------------------------------------------------------------
; Modificaac1on of status registers	  
      	BSET #FRCT, ST1_55          
      	BCLR #ARMS, ST2_55          
	  	BCLR #C54CM, ST1_55  
      
      	BSET SXMD
      	BCLR SATD
      	BSET M40
	                                   
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage
;-----------------------------------------------------------------------      
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) - (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) + (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; ar6  -> tempmem
        ;
        ; ar0-> a
        ; ar1-> b
        ; ar2-> c
        ; ar3-> d
        ;
        ; --------------------------------------------------------------        
       
    	MOV XAR0, XAR1					; AR0 contains    #(ifftdata) a
    	ADD *sp(data_pac0),T0, AR1		; b: ar1 = #(ifftdata+4*iFFT_SIZE/4)
	
		MOV XAR1, XAR2 
		ADD T0,AR2						; c: ar2 = #(ifftdata+4*iFFT_SIZE/2)
 	        
    	MOV XAR2, XAR3    
		ADD T0, AR3						; d: ar3 = #(ifftdata+4*3*iFFT_SIZE/4)
		
		SFTS T0, #-1					;T0 = iFFT_SIZE/4
		SFTS T0, #-1	
		SUB #1, T0
		
		AMOV #tempmem, XAR6
		MOV T0,BRC0
	        
    	RPTB stage12
;-----------------------------------------------------------------------
; Benchmark: 21 stages for stage1_2 loop
;-----------------------------------------------------------------------   	
		;Instruction					Ac0	Ac1	Ac2	Ac3	Ar0	Ar1	Ar2	Ar3    	
		mov dbl(*ar0), ac0				;ar				ar	br	cr	dr
		sub dbl(*ar2),ac0,ac3			;			ar-cr				
		add dbl(*ar2+),ac0,ac1			;	ar+cr				ci	
		mov dbl(*ar1),ac0				;br							
		sub ac0,dbl(*ar3+),ac2			;		dr-br				di
		mov ac2,dbl(*ar6) 	;ar6->dr-br								
	||	add ac0<<#1,ac2					;		dr+br					
		add ac2,ac1						;ar+cr+dr+br						
	|| 	mov dbl(*ar3-),ac0				;di							dr 
		mov ac1,dbl(*ar0+)				;				ai			
	|| 	sub ac2<<#1,ac1					;ar+cr-(dr+br)						
		mov ac1, dbl(*ar1+)				;					bi		 
		add dbl(*ar1),ac0,ac1			;	bi+di						 
		sub ac0, dbl(*ar1), ac2			;		bi-di					
		sub ac2, ac3					;			ar-cr-(bi-di)				
	|| 	mov dbl(*ar2-),ac0				;ci						cr	
		mov ac3,dbl(*ar2+)				;						ci	
	|| 	add ac2<<#1,ac3					;			ar-cr+(bi-di)				
		mov ac3, dbl(*ar3+)				;							di 
		sub ac0, dbl(*ar0), ac3			;			ai-ci				
		add dbl(*ar0),ac0				;ai+ci							
		add ac1,ac0						;ai+ci+di+bi							
	||	mov dbl(*ar6),ac2				;		dr-br					
		mov ac0, dbl(*ar0+)				;				arn			
	||	sub ac1<<#1,ac0					;ai+ci-(di+bi)							
		mov ac0, dbl(*ar1+)				;					brn		
	||	sub ac2,ac3						;			ai-ci-(dr-br)				
		mov ac3,dbl(*ar2+)				;						crn	
	||	add ac2<<#1,ac3					;			ai-ci+(dr-br)				
stage12:mov ac3,dbl(*ar3+)				;							drn
;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------    	
		
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(iFFT_SIZE) )  
; register usage
; ar0->Pr, ar1->Qr, ar3->twiddle
; ar4=Re distance of butterfly
; ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main iniac1alizaac1on      	   

        ; modify ST2 to select linear or circular addressing modes
       	OR	#0x3, mmap(ST2_55)		; circular ar0,ar1        
       	MOV *sp(data_pac0), AR1		; ar1 = #ifftdata  

        ; circular buffer starac1ng addresses       	     	
       	MOV mmap(@AR1),bsa01		; circular buffer start address
       	
        ; circular buffer sizes 
        MPYMK *sp(data_sz),#2,AC0	; because FRCT==1, it actually x4
        MOV mmap(@AC0_L), bk03		; bk03 = (4*iFFT_SIZE-4), ar0-ar3
		MOV *sp(data_sz), T2
		SFTS T2,#-1					; T2 = iFFT_SIZE/2
    	MOV T2,AR4    				; AR4 = iFFT_SIZE/2(Re distance between p q)
    	SFTS T2,#-1
  	||  MOV	#4, AR6					; AR6 = group    
    	SFTS T2,#-1					; T2 = iFFT_SIZE/8
    	BCC end_benchmark, T2==#0
    	MOV T2, T1					; T1 = number of butterfly,
    	MOV T2, AR5					; AR5 = stage	       	      	 		 			
    	AMOV #twiddle32, XAR3        ; AR3->twiddle32	  


	    mov     #2, t0          	; moving from real->imag
        mov     #-2, t2         	; restoring cdp, and imag->real       	
                        
stage:  ; begining of a new stage
        ; stage initialization
        
        ; 1 - loop counter updates     
		SFTS AR5,#-1				; shift right stage count
	||	MOV #0,AR0		
		MOV XAR3, XCDP
		ADD #1,AR4,AR1				;AR1->QR_LOW
		ADD	#2,AR1,AR2				;AR2->QI_LOW
		   
        ; butterfly counter update		      		
        SUB #1,T1,T3        
        MOV T3, BRC1        		;butterflies loop count

        ; group counter update
        SUB #1,AR6,T3     
		MOV T3, BRC0              
       	
		RPTB group   	
;-----------------------------------------------------------------------
; Benchmark: 12 cycles for the butterfly loop
;-----------------------------------------------------------------------
       	rptb BFly 								;             (ar1,cdp)
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mas     uns(*ar1(t0)), *cdp+, ac0       ; ac0 -= yil*cih (3,2)
::      mac     uns(*ar1+), *cdp+, ac1          ; ac1 += yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mas     *ar1, uns(*(cdp+t0)), ac0       ; ac0 -= yih*cil (2,3)
::      mac     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 += yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mas     *ar1(t0), *(cdp+t0), ac0        ; ac0 -= yih*cih (2,2)
::      mac     *ar1, *(cdp+t0), ac1        	; ac1 += yrh*cih (0,2)

        add     dbl(*ar0), ac0,ac2
     	mar		*+cdp(-4)
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)

        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2

        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)

BFly:   mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #1, ar1                         ;                (4,4)      	       	
       	       	  					       	  					  					       	  					  					  					  					  					  						
		ADD AR4, AR0				;jump to next group
		ADD AR4, AR1
group:	AMAR *+CDP(4)				;CDP+4
		
		SFTS AR6,#1					;group<<1
		SFTS T1,#-1					;butterfly>>1
		SFTS AR4,#-1 				;P Q distance>>1
		BCC stage,AR5!=#0
;-----------------------------------------------------------------------
; End of radix-2 stage 
;-----------------------------------------------------------------------
				
end_benchmark:

;-----------------------------------------------------------------------
; De-allocate the local frame and argument block
;-----------------------------------------------------------------------
		AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

		;Context restore 
		POPBOTH XAR7
		POPBOTH XAR6
		POPBOTH XAR5
      	POP T3
      	POP T2 
      	POP	mmap(ST3_55)
      	POP	mmap(ST2_55)
      	POP	mmap(ST1_55)
      	POP	mmap(ST0_55)
	
		RET 
		.end         
        
/77             1161799538  0     0     0       15120     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: 32-bit radix-2 DIT complex iFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are separately implmented for MIPS optimization.
; Usage:    void cifft32_SCALE (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2002
; History:
;    08/19/2002 Li Yuan
;        - Changed || to :: in several dual MAC instructions
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _ifft
;
; ar0       ->    ifftdata pointer
; t0        ->    ifft size
;
;-----------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

;        .include "twiddle32.inc"
        .ref twiddle32
        .def _cifft32_SCALE     	; make function visible to other fnct
        .cpl_on
        .arms_off     				; disable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------             
       .asg    0, data_ptr
       .asg    1, data_sz
      
        .text           
_cifft32_SCALE

;----------------------------------------------------------------
; Conditional compile
;----------------------------------------------------------------
SCALED	.set	1		; SCALED = 0 - not scaled version
						; SCALED = 1 - scaled version
						
;----------------------------------------------------------------
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

		PSH	mmap(ST0_55)
    	PSH	mmap(ST1_55)
    	PSH	mmap(ST2_55)  
    	PSH	mmap(ST3_55)
    	PSH T2
    	PSH T3
		PSHBOTH XAR5
		PSHBOTH XAR6
		PSHBOTH XAR7

;----------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
		AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;----------------------------------------------------------------
; Save entry values for later
;----------------------------------------------------------------

		MOV AR0, *sp(data_ptr) ; 
   		MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; iFFT implementation
;
; The iFFT is implemented in 5 different steps:
;
;  1) - a radix-2 stage without any multiplications.
;  2) - a radix-2 stage with two groups, only the 2nd group has
;       multiplications with 0x7FFFFFFH and 0x00000000
;  3) - a group of log2(iFFT_SIZE)-3 radix-2 stages
;  4) - a radix-2 stage without scaling.
;  5) - on out-of-place bit-reversal
;-----------------------------------------------------------------------
        
;-----------------------------------------------------------------------
; Modification of status registers
;-----------------------------------------------------------------------	  
      	BSET #FRCT, ST1_55          
      	BCLR #ARMS, ST2_55          
	  	BCLR #C54CM, ST1_55  
      
      	BSET SXMD
      	BCLR SATD
      	BSET M40             
                     
      	; Define CSR for scaling loop
      	SUB #1, T0, T1                          
      	MOV T1, BRC0       			; BRC0 = ifftsize - 1
		MOV XAR0,XAR1

;-----------------------------------------------------------------------
; Scaling loop: Data scaled by 2 before first stage 
;-----------------------------------------------------------------------       
	 	RPTBLOCAL scaling
     	MOV dbl(*AR1+), AC0       
     	MOV dbl(*AR1-), AC1
     ||	SFTS AC0,#-1 
     	SFTS AC1,#-1     
     ||	MOV	AC0, dbl(*AR1+)
scaling:MOV AC1, dbl(*AR1+)

;-----------------------------------------------------------------------
; Radix-2 stage 1
;-----------------------------------------------------------------------		
		MOV AR0,AR1					; AR0->ifft_data 	(a)
		ADD T0,AR1 					; AR1->ifft_data+n2  (b)
		MOV XAR1,XAR2				
		ADD T0,AR2					; AR2->ifft_data+2*n2(c)
		MOV XAR2,XAR3
		ADD T0,AR3					; AR3->ifft_data+3*n2(d)
		MOV XAR2,XAR7
		SFTS T0,#-1					; T0=ifft-size/2
		SUB #1,T0,T1				; T1=ifft_size/2-1
		MOV T1,BRC0

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for this loop		
;-----------------------------------------------------------------------
		RPTBLOCAL stage1		
		MOV dbl(*AR0+),AC0
		ADD dbl(*AR7),AC0,AC1		; AC1=AR+CR
		SUB dbl(*AR7+),AC0			; AC0=AR-CR
		MOV dbl(*AR0-),AC2
	||	SFTS AC1,#-1
		ADD dbl(*AR7),AC2,AC3		; AC3=AI+CI	
		SUB dbl(*AR7-),AC2			; AC2=AI-CI	
		SFTS AC0,#-1
	||	MOV AC1,dbl(*AR0+)			;(AR+CR)>>1->AR
		SFTS AC2,#-1
	||	MOV AC0,dbl(*AR7+)			;(AR-CR)>>1->CR
		SFTS AC3,#-1
	||	MOV	AC2,dbl(*AR7+)			;(AI-CI)>>1->CI
stage1:	MOV AC3,dbl(*AR0+)			;(AI+CI)>>1->AI
	

;-----------------------------------------------------------------------
; Radix-2 stage2
;-----------------------------------------------------------------------
		MOV *sp(data_ptr), AR0
	||	SFTS T0,#-1
		SUB #1,T0,T1				;T0=ifft_size/4
		MOV T1,BRC0					;T1=ifft_size/4-1

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for group1
;-----------------------------------------------------------------------
		RPTBLOCAL group1		
		MOV dbl(*AR0+),AC0
		ADD dbl(*AR1),AC0,AC1		; AC1=AR+BR
		SUB dbl(*AR1+),AC0			; AC0=AR-BR
		SFTS AC1,#-1
	||	MOV dbl(*AR0-),AC2
		ADD dbl(*AR1),AC2,AC3		; AC3=AI+BI
		SUB dbl(*AR1-),AC2			; AC2=AI-BI
		SFTS AC0,#-1
	||	MOV AC1,dbl(*AR0+)			; AR+BR->AR
		SFTS AC2,#-1
	||	MOV AC0,dbl(*AR1+)			; AR-BR->BR
		SFTS AC3,#-1
	||	MOV AC2,dbl(*AR1+)			; AI-BI->BI
group1: MOV AC3,dbl(*AR0+)			; AI+BI->AI


;-----------------------------------------------------------------------
; Benchmark: 13 cycles for group2	
;-----------------------------------------------------------------------	
		MOV T1,BRC0
		AMOV #twiddle32, XCDP
		MOV XAR3, XAR4			
		ADD #3,AR4					; AR4->DI_LOW

		RPTBLOCAL group2
		AMAR *AR3+					; 							AR3->DR_LOW
		MPY uns(*AR3-),*CDP+,AC0	;DR_LOW * 7FFF 				AR3->DR_HI	CDP->FFFF
	::	MPY uns(*AR4-),*CDP+,AC1    ;DI_LOW * 7FFF	 			AR4->DI_HI  
		MAC	*AR3,uns(*CDP-),AC0		;DR_HI*FFFF+DR_LOW*7FFF, 	AR3->DR_HI	CDP->7FFF
	:: 	MAC	*AR4,uns(*CDP-),AC1		;DI_HI*FFFF+DI_LOW*7FFF, 	AR4->DI_HI	
		MAC *AR3,*CDP,AC0>>#16		;DR_HI*7FFF+AC0>>16			AR3->DR_HI	CDP_>7FFF
	::	MAC *AR4,*CDP,AC1>>#16		;DI_HI*7FFF+AC1>>16			AR4->DI_HI	CDP_>7FFF				
		SUB AC1,dbl(*AR2),AC2		;AC2=CR-AC1
		ADD dbl(*AR2+),AC1			;AC1=CR+AC1					AR2->CI
		SUB AC0,dbl(*AR2),AC3		;AC3=CI-AC0			
		ADD dbl(*AR2-),AC0			;AC0=CI+AC0					AR2->CR
		SFTS AC1,#-1
	||	ADD #5, AR4					;							AR4->DI(next)
		SFTS AC3,#-1
	||	MOV AC1,dbl(*AR3+)			;AC1->DR					AR3->DI
		SFTS AC2,#-1	
	||	MOV AC3,dbl(*AR3+)			;AC3->DI					AR3->DR(next)
		SFTS AC0,#-1
	||	MOV AC2,dbl(*AR2+)			;AC2->CR					AR2->CI
group2:	MOV AC0,dbl(*AR2+)			;AC0->CI					AR2->CR(next)

;-----------------------------------------------------------------------
; End of stage 1 and 2
;----------------------------------------------------------------------- 		
		SFTS T0,#-1
		BCC end_benchmark, T0==#0

					    			 			    			    			    			    			    			    		
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(iFFT_SIZE) )  
; 	register usage
; 	ar0->Pr, ar1->Qr, ar3->twiddle32
; 	ar4=Re distance of butterfly
; 	ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main initialization     	   
		
        ; modify ST2 to select linear or circular addressing modes
       	OR	#0x3 , mmap(ST2_55)		; circular ar0,ar1   
       	MOV *sp(data_ptr), AR1		; ar1 = #ifftdata  

        ; circular buffer starting addresses       	     	
       	MOV mmap(@AR1),bsa01		; circular buffer start address
       	
        ; circular buffer sizes 
        MPYMK *sp(data_sz),#2,AC0	; because FRCT==1, it actually x4
        MOV mmap(@AC0_L), bk03		; bk03 = (4*iFFT_SIZE-4), ar0-ar3
        
        
		MOV *sp(data_sz), T2
		SFTS T2,#-1					; T2 = iFFT_SIZE/2
	||  MOV	#4, AR6					; AR6 = group    
    	MOV T2,AR4    				; AR4 = iFFT_SIZE/2(Re distance between p q)
    	
    	MOV T0,T1					; T1 = iFFT_SIZE/8, nbfly
    	
    	SFTS T0,#-1					; T0=size/16
    ||	MOV #-2, T2
    	MOV T0, AR5					; AR5 is stage count
    	MOV #2,T0
    	AMOV #twiddle32, XAR3
		BCC last_stage, AR5==#0      	      	 		 				  

;-----------------------------------------------------------------------
; Beginning of the stage loop
;	 stage iniac1alizaac1on
;-----------------------------------------------------------------------
stage:  ; stage loop counter updates     
		SFTS AR5,#-1			    ; shift right stage count  

		MOV #0,AR0		
	||	MOV AR3, CDP
		ADD #1,AR4,AR1				;AR1->QR_LOW
				   
        ; butterfly counter update		      		
        SUB #1,T1,T3        
        MOV T3, BRC1        

        ; group counter update
        SUB #1,AR6,T3     
		MOV T3, BRC0              
	     	
		RPTB group   	
;-----------------------------------------------------------------------
; Benchmark: 15 cycles for butterfly loop
;-----------------------------------------------------------------------
       	rptb BFly 								;             (ar1,cdp)
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mas     uns(*ar1(t0)), *cdp+, ac0       ; ac0 -= yil*cih (3,2)
::      mac     uns(*ar1+), *cdp+, ac1          ; ac1 += yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mas     *ar1, uns(*(cdp+t0)), ac0       ; ac0 -= yih*cil (2,3)
::      mac     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 += yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mas     *ar1(t0), *(cdp+t0), ac0        ; ac0 -= yih*cih (2,2)
::      mac     *ar1, *(cdp+t0), ac1        	; ac1 += yrh*cih (0,2)	
		
        add     dbl(*ar0), ac0,ac2        
        sfts 	ac2, #-1
||		mar 	*cdp-    
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)
		sfts 	ac3, #-1
||		mar 	*cdp-
        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2
		sfts 	ac2, #-1
||		mar 	*cdp-   
        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)
		sfts 	ac3, #-1
||		mar 	*cdp-   
BFly:   mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #1, ar1                         ;                (4,4)      	       	
       	       	  					       	  					  					       	  					  					  					  					  					  						
		ADD AR4, AR0				;jump to next group
		ADD AR4, AR1
group:	AMAR *+CDP(4)				;CDP+4
		
		SFTS AR6,#1					;group<<1
		SFTS T1,#-1					;butterfly>>1
		SFTS AR4,#-1 				;P Q distance>>1
		BCC stage,AR5!=#0
;-----------------------------------------------------------------------
; END radix-2 stages (stages 3->log2(iFFT_SIZE) )  
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Last stage
;-----------------------------------------------------------------------		
last_stage:
        ; stage initialization
		MOV #0,AR0	 	
		MOV AR3, CDP	      		    
		MOV #5,AR1					;AR1->QR_LOW
	
        ; group counter update
        SUB #1,AR6,T3    
		MOV T3, BRC0              
     	
		RPTB lgroup				
        mpy     uns(*ar1), *(cdp+t0), ac0       ; ac0  = yrl*crh (1,0)
::      mpy     uns(*ar1(t0)), *(cdp+t0), ac1   ; ac1  = yil*crh (3,0)

        mas     uns(*ar1(t0)), *cdp+, ac0       ; ac0 -= yil*cih (3,2)
::      mac     uns(*ar1+), *cdp+, ac1          ; ac1 += yrl*cih (1,2)
||      swap    t0, t2                          ; t0=-2

        mas     *ar1, uns(*(cdp+t0)), ac0       ; ac0 -= yih*cil (2,3)
::      mac     *ar1(t0), uns(*(cdp+t0)), ac1   ; ac1 += yrh*cil (0,3)

        mac    *ar1(t0), uns(*cdp-), ac0       	; ac0 += yrh*crl (0,1)
::      mac    *(ar1+t0), uns(*cdp-), ac1      	; ac1 += yih*crl (2,1)
||      swap    t0, t2                          ; t0=2

        mac     *ar1, *(cdp+t0), ac0>>#16  		; ac0 += yrh*crh (0,0)
::      mac     *ar1(t0), *(cdp+t0), ac1>>#16   ; ac1 += yih*crh (2,0)

        mas     *ar1(t0), *(cdp+t0), ac0        ; ac0 -= yih*cih (2,2)
::      mac     *ar1, *(cdp+t0), ac1        	; ac1 += yrh*cih (0,2)

        add     dbl(*ar0), ac0,ac2
        mov     ac2,dbl(*ar0)                 	; new xr=ac0+xr  (0,4)
||	    sub     ac0,dbl(*ar0+),ac3             	;                (0,4)

        mov     ac3, dbl(*ar1+)                 ; new yr=xr-ac0  (2,4)
||      sub     ac1,dbl(*ar0), ac2

        mov     ac2, dbl(*ar1+)                 ; new yi=xi-ac1  (2,4)
||      add     dbl(*ar0),ac1,ac3               ;                (4,4)

		mov     ac3, dbl(*ar0+)                 ; new xi=xi+ac1
||      add     #5, ar1                         ;                (4,4)      	       	
lgroup:	add		#4, ar0       	  				; jump to next group	       	  				
;-----------------------------------------------------------------------
; END last stage
;-----------------------------------------------------------------------
						
end_benchmark:
;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
		AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;Context restore 
		POPBOTH XAR7
		POPBOTH XAR6
		POPBOTH XAR5
      	POP T3
      	POP T2 
      	POP	mmap(ST3_55)
      	POP	mmap(ST2_55)
      	POP	mmap(ST1_55)
      	POP	mmap(ST0_55)
	
		RET 
		.end         
        
/96             1161799545  0     0     0       15100     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-4/Radix-2 DIT no scale complex IFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    
; Usage:    void cifft (DATA *xy, ushort nx, NOSCALE);
; Copyright Texas instruments Inc, 2000
;
; 	- 07/17/2003	C. Iovescu fixed the bug in the kernal.
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; ar0       ->    fftdata pointer
; t0        ->    fft size
;
;-----------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

            .ref twiddle

	         
        .def _cifft_NOSCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

		.bss tempmem, 2, , 2
		.bss tempmem1, 2, , 2 

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	


      
        .text           


_cifft_NOSCALE

;//-----------------------------------------------------------------------------
;// Conditional compile
;//-----------------------------------------------------------------------------
SCALED	.set	1			; SCALED = 0 - not scaled version
						; SCALED = 1 - scaled version



;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;


      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  

      PSH T2
      PSH T3
	PSHBOTH XAR5
	PSHBOTH XAR6
	PSHBOTH XAR7


;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;
; Save entry values for later
;----------------------------------------------------------------

	MOV AR0, *sp(data_ptr) ; 
      MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.

        
            ; save all save-on-entry regs that are modified
            


;-----------------------------------------------------------------------
; Modification of status registers

	  
        BSET #FRCT, ST1_55          
        BCLR #ARMS, ST2_55          
	  BCLR #C54CM, ST1_55  
   



              
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage


    ; --------------------------------------------------------------        
        ; First in-place radix-4 stage for CIFFT
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) - (bi - di)
        ; ci' =  (ai - ci) + (br - dr)
        ;
        ; dr' =  (ar - cr) + (bi - di)
        ; di' =  (ai - ci) - (br - dr)
        ;        
        ; ar7, -> temp
        ; ar6  -> temp1
        ;
        ; ar0-> a
        ; ar1-> b
        ; ar2-> c
        ; ar3-> d
        ;
        ; ar5 = ar2
        ;
        ; t0 = 1
        ; t1 = 2
        ;       
        ;
        ; ac0-ac3 modified
        ; t1-t2 modified
        ;
        ; --------------------------------------------------------------        
       
          
                
    ; AR0 contains    #(fftdata)                 ; a

	  MOV XAR0, XAR2
	  MOV XAR0, XAR1
	  MOV XAR0, XAR3
      ADD  *sp(data_sz), AR0, AR2			; c: ar2 = #(fftdata + 2*2*FFT_SIZE/4)
     
      SFTS T0, #-1					; T0 = FFT_SIZE/2
      mov ar2, ar3    
 
	ADD  *sp(data_ptr), T0, AR1			; b: ar1 = #(fftdata + 1*2*FFT_SIZE/4)
	

      ADD  T0, AR3					; d: ar3 = #(fftdata + 3*2*FFT_SIZE/4)
      SFTS T0, #-1					;T0 = FFT_SIZE/4
	
      SUB #2, T0
	
	AMOV #(tempmem1), XAR7
      AMOV #tempmem, XAR6
       

	MOV #2, T1 							; 
	||MOV dbl(*AR0), AC0					; in (ar,ai)
       
      MOV T0, BRC0
	||ADD	dual(*AR2), AC0, AC2	 		; (ar+cr)/ ; (ai+ci) 
	 		   
    
    MOV XAR2, XAR5 
    MOV #1, T0
     
       
    MOV dbl(*AR1) ,AC1 				; in (br,bi)
	||	MOV AC2, dbl(*AR6) 		; temp (ar+cr),(ai+ci)   
    
    SUB	dual(*AR3), AC1, AC2   		; (br-dr)/(bi-di)
	 		
    
        
    SUB	dual(*AR2+), AC0    		; (ar-cr)/(ai-ci) 
    || MOV Hi(AC2),T3 	                    ; move (br-dr)
    
  	ADD	dual(*AR3), AC1, AC3 		; (br+dr)/ (bi+di)
 	||	MOV AC2, T2				; move (bi-di)        
        	    
        
    ADD	dual(*AR6), AC3, AC0   		; (ar+cr) + (dr+br) = ar'
	                        		; (ai+ci) + (di+bi)	= ai'
	||MOV AC0, dbl(*AR7(T0))            ; (ar-cr),(ai-ci) unaligned

          
    SUB	AC3, dual(*AR6), AC3    		; (ar+cr) - (dr+br) = br'
					 		; (ai+ci) - (di+bi)	= bi'
    ||MOV AC0, dbl(*AR0+)                 ; out (ar';ai')
         
    ADDSUB	T2, *AR7(T0), AC0   		; (ar-cr) - (bi-di)	= cr' (low part)
							; (ar-cr) + (bi-di)	= dr' (high part)

    SUBADD	T3, *AR7, AC1 			; (ai-ci) + (br-dr)	= ci' (low part)
 							; (ai-ci) - (br-dr)	= di' (high part)

        
        
        
        RPTBLOCAL r4_loop
        
    
      MOV AC3, dbl(*AR1+)				; out(br', bi')								; 
	||MOV  dbl(*AR0), AC3				; in (ar,ai)
       
       MOV 	pair(LO(AC0)),dbl(*AR5+)       		; out(cr',ci')
	||ADD	dual(*AR2), AC3, AC2 			; (ar+cr) 
	    							; (ai+ci)   
       
       MOV   dbl(*AR1), AC1				; in (br,bi)
	|| MOV  pair(HI(AC0)), dbl(*AR3+) 	            ; out (dr', di')
    
    SUB	dual(*AR3), AC1, AC2      		; (br-dr)/(bi-di) 
    || MOV AC2, dbl(*AR6) 				; temp (ar+cr),(ai+ci)
    
        
   SUB	dual(*AR2+), AC3, AC0     	      ; (ar-cr)/(ai-ci) 
    || MOV  Hi(AC2), T3                         ; move(br-dr)
    
       ADD	dual(*AR3), AC1, AC3    		; (br+dr)/(bi+di) 
 	||	MOV AC2, T2 				; move (bi-di)        
        	    
        
   	ADD dual(*AR6), AC3, AC0 			; (ar+cr) + (dr+br) = ar'
						 		; (ai+ci) + (di+bi)	= ai' 
	||MOV AC0, dbl(*AR7(T0))			; (ar-cr),(ai-ci) unaligned
	  
           
   SUB	AC3, dual(*AR6), AC3      		; (ar+cr) - (dr+br) = br'
							; (ai+ci) - (di+bi)	= bi'
    ||MOV AC0, dbl(*AR0+)    ; out (ar';ai')
         
    ADDSUB	T2, *AR7(T0), AC0    			; (ar-cr) - (bi-di)	= cr'
								; (ar-cr) + (bi-di)	= dr'

r4_loop:    SUBADD	T3, *AR7, AC1   		; (ai-ci) + (br-dr)	= ci'
 								; (ai-ci) - (br-dr)	= di'

     
    MOV AC3, dbl(*AR1+) 				; out(br', bi')	  
    MOV pair(LO(AC0)), dbl(*AR5+)      ; out(cr',ci')       
    MOV pair(HI(AC0)),	dbl(*AR3+)	    ; out (dr', di')      




;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )
        


        ; main initialization
        ; --------------------
        
       MOV *sp(data_ptr), AR0		; ar0 = #fftdata
       
            ; 1 - circular buffer initializations

        
            ; modify ST2 to select linear or circular addressing modes
       OR	#0x57 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
         

            ; circular buffer starting addresses
        ADD #2, ar0,ar1
        MOV mmap(@ar0),bsa23       ; P  leg
        MOV mmap(@ar0),bsa45       ; P' leg    (in-place butterflies)
        MOV mmap(@ar1),bsa01       ; Q  leg
        MOV mmap(@ar1),bsa67       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
	  MOV *sp(data_sz), T0
        MOV T0, T1		; T1 =  #FFT_SIZE
	  SFTS T0, #1        
        SUB #2, T0
    
        MOV mmap(@T0_L), bk03          	; bk03 = (2*FFT_SIZE-2), 
        MOV mmap(@T0_L), bk47   ; bk47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
       MOV *sp(data_sz), T0
       SFTS T0, #-1
       SFTS T0, #-1
        
        MOV T0, ar5   ; 2*number of groups for stage 3    
        MOV #2, ar7          ; 1/2 * number of butterflies per group for stage 3
       

        AMOV #twiddle, xar3        ; not modified during iteration of the stages
	  ADD #2, AR3				 ; n=0 processed outside inner loop
        MOV xar0,xar1            ; data page = data page of indata
        MOV xar0,xar2            ; data page = data page of indata
        MOV xar0,xar4   ; data page = data page of indata (in-place butterflies)
        MOV xar0,xar6   ; data page = data page of indata (in-place butterflies)
        MOV xar3,xcdp      ; data page = data page of twiddles
        

        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------


            ; 1 - loop counter updates
        
            ; butterfly counter update
       SFTS ar7, #1
    ||    MOV #0, ar4 
        SUB #2,ar7,ar0
        MOV ar0, brc1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS ar5, #-1
        SUB  #1,ar5,ar0     
        MOV ar0, brc0         

            ; stage "counter" update (t0=0 <=> last stage)
         AMOV ar0, t0

            ; 2 - pointer modifier update
                            
            ; t1 is the pointer modifier                    
    ||   SFTS  t1,#-1        

            ; 3 - index updates                  
            ; ar0 -> Qr[0]
            ; ar1 -> Qi[0]
            ; ar2 -> Pr[0]
            ; ar4 -> Pr'[0]  (performed above to use parallelism)
            ; ar6 -> Qr'[0]

 
        SFTS ar0, #1
        ADD #1, ar0,ar1
        MOV #0, ar2
    ||  MOV ar0, ar6 
        
        
        
group:  ; begining of a new group
        

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (cdp) is updated inside the loop
        ; - same twiddle table as for FFT: (wr, wi) = (cos, -sin)
        
                
        RPTBLOCAL r2_loop1        
                ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
    ||  ADD  t1,ar1       
        
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pi'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
      ||    MOV ar3, cdp    ; #(twiddle+1) has to be loaded in CDP because
      						; n=0 is processed outside inner loop 

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]

  	SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0, dbl(*(ar4+t1))               
     
		                                                                        
                                                                                                                                                                                        
          RPTBLOCAL r2_loop2          


                    ; ac2=Qr[n]*cos                                    
                    ; ac3=Qi[n]*cos
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*cos+Qr[n]*sin   
                    ; ac2=Qr[n]*cos-Qi[n]*sin   				        


  		MACR	*(AR0+T1), *CDP+, AC3   	; 
        	::MASR	*(AR1+T1), *CDP+, AC2   ; 
            
            
                    ; ac2=(Qr[n]*cos-Qi[n]*sin):(Qi[n]*cos+Qr[n]*sin)

         
          OR AC3 << #-16, AC2    
                    ; hi(ac0)=Pr[n]+(Qr[n]*cos-Qi[n]*sin)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qi[n]*cos+Qr[n]*sin)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1, dbl(*(ar6+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*cos-Qi[n]*sin)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qi[n]*cos+Qr[n]*sin)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop2:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0, dbl(*(ar4+t1)) 
        
                                   ; end of butterfly loop
                                   
                                   
                         
        
r2_loop1:        MOV AC1, dbl(*(ar6+t1))      ; store last Qr':Qi'
        
                                   ; end of group loop
    
        
        BCC stage,t0!=#0       ; end of stage loop       	
   	   
                       
end_benchmark:


;Context restore 

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP


	POPBOTH XAR7
	POPBOTH XAR6
	POPBOTH XAR5
      POP T3
      POP T2 


      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)


 

	
	RET 

	.end         
        






cifft_scale.asm/1161799552  0     0     0       20802     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex IFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    All stages are in radix-2.
; Usage:    void cifft (DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2000
;	- 07/02/2003	D. Elam added support for 8 point
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; ar0       ->    fftdata pointer
; t0        ->    fft size
;
;-------------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

	.ref twiddle
	         


        .def _cifft_SCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5549
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

		.bss tempmem, 2, , 2
		.bss tempmem1, 2, , 2 

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	


      
        .text           


_cifft_SCALE



;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;

      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  

      PSH T2
      PSH T3
	PSHBOTH XAR5
	PSHBOTH XAR6
	PSHBOTH XAR7
	
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
	

;
; Save entry values for later
;----------------------------------------------------------------

	MOV AR0, *sp(data_ptr) ; 
    MOV T0, *sp(data_sz)   ;

;-----------------------------------------------------------------------
; IFFT implementation
;
; The IFFT is implemented in log2(FFT_SIZE)-1 radix-2 stages:
;

        
            ; save all save-on-entry regs that are modified
            


;-----------------------------------------------------------------------
; Modification of status registers

	  
        BSET	FRCT
        BSET	SATD
        BSET	SXMD          
        BCLR #ARMS, ST2_55          
	  BCLR #C54CM, ST1_55 

; Define CSR for scaling loop

        SUB	#2, T0, T1                          
        MOV	T1, CSR                               ; CSR = fftsize - 2
 
;*******************************************************************************
; SCALING LOOP: Data scaled by 2 before first stage 
;*******************************************************************************
        
        MOV XAR0, XAR1                                 ; ar0 = #fftdata
        MOV	dbl(*AR0+), AC0                        ; scale by 2 - prime the pipe
        RPT	CSR
	MOV	AC0 >> #1, dual(*AR1+)
	||MOV	dbl(*AR0+), AC0
	MOV	AC0 >> #1, dual(*AR1+)

scale_loop


;*******************************************************************************
; END SCALING LOOP
;*******************************************************************************



; radix-2 stage 1
;
; 
         MOV #2, T1
         MOV XAR0, XAR2
         MOV XAR0, XAR4
         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         AADD T0, AR0               ; ar0 = fftdata + fft_size
         MOV XAR0, XAR5				; ar5 = fftdata + fft_size
         MOV T0, T2
         SFTS T2, #-1               ; T2 = fft_size/2 
         MOV T2, AR7
         SUB #2, AR7
         MOV AR7, BRC0
        
        
        
                 ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2      
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
           
       ADD	dual(*AR2), AC2, AC0 
   

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                       
                 
        RPTBLOCAL r2_loop00 -1          


        MOV dbl(*(ar0+t1)), ac2         	; load Q            
        || MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   
        
           
         ADD	dual(*AR2), AC2, AC0        ; new P   
            
          SUB	AC2, dual(*(AR2+T1)), AC1   ; new Q 
      || MOV ac0>>#1, dual(*(ar4+t1))       ; store new P  

r2_loop00:	
		 
                    
         MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   

; radix-2 stage 2
;
; groupe #1 twiddle = #1  


         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         ADD T2, AR0                ; ar0 = fftdata + fft_size/2
         MOV AR0, AR5				; ar5 = fftdata + fft_size/2  
         MOV T2, T3                 ; T3= fft_size/2
         SFTS T2, #-1               ; T2 = fft_size/4 
         SUB #2, T2
         MOV T2, BRC0               ; BRC0 = fft_size/4 - 2
       
                                	
 
                   ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
   

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                       
                 
        RPTBLOCAL r2_loop01 -1          


        MOV dbl(*(ar0+t1)), ac2         	; load Q            
        || MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q   
        
           
         ADD	dual(*AR2), AC2, AC0        ; new P   
 
       SUB	AC2, dual(*(AR2+T1)), AC1   ; new Q 
      || MOV ac0>>#1, dual(*(ar4+t1))       ; store new P  

r2_loop01:	
		 
                    
         MOV ac1>>#1, dual(*(ar5+t1))     ; store new Q    
         
         
         
 
; radix-2 stage 2
;
; groupe #2 twiddle = #-1    


         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         ADD T0, AR2				; ar2 = #fftdata + fft_size
         MOV AR2, AR4               ; ar4 = #fftdata + fft_size  
         MOV AR2, AR0
         ADD T3,  AR0               ; ar0 = #fftdata + 3/2*fft_size 
         MOV AR0, AR1
         ADD #1, AR1
         MOV AR0, AR5				; ar5 = #fftdata + 3/2*fft_size
         MOV T2, BRC0               ; ; BRC0 = fft_size/4 - 2                           	
         AMOV #twiddle, xar3		; 
         ADD #2, AR3    			; 
         MOV XAR3, XCDP				; 

                      
                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3  
       
                   ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

         
          MACR	*(AR0+T1), *CDP-, AC3
         ::MASR	*(AR1+T1), *CDP-, AC2 
        
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
         OR AC3 << #-16, AC2
         
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                             
         	   ADD	dual(*AR2), AC2, AC0            
   
                       ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

    	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
   
                                                          
        
          RPTBLOCAL r2_loop02          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi  --correct commenting!

          
        MACR	*(AR0+T1), *CDP-, AC3   
         :: MASR	*(AR1+T1), *CDP-, AC2  
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
          OR AC3 << #-16, AC2     
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1>>#1, dual(*(ar5+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop02:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
        
                                   ; end of butterfly loop
                              
            MOV ac1>>#1, dual(*(ar5+t1))  

		  MOV *sp(data_sz), T0		  
		  SUB #8, T0		  
		  BCC final_stage, T0==#0  	; branch to final stage if 8-point fft

 
 
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )
        


        ; main initialization
        ; --------------------
        
       MOV *sp(data_ptr), AR0		; ar0 = #fftdata
       ;MOV  #twiddle, AR3 
            ; 1 - circular buffer initializations

        
            ; modify ST2 to select linear or circular addressing modes
       OR	#0x57 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
         

            ; circular buffer starting addresses
        ADD #2, ar0,ar1
        MOV mmap(@ar0),bsa23       ; P  leg
        MOV mmap(@ar0),bsa45       ; P' leg    (in-place butterflies)
        MOV mmap(@ar1),bsa01       ; Q  leg
        MOV mmap(@ar1),bsa67       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
	  MOV *sp(data_sz), T0
        MOV T0, T1		; T1 =  #FFT_SIZE
	  SFTS T0, #1        
        SUB #2, T0
    
        MOV mmap(@T0_L), bk03          	; bk03 = (2*FFT_SIZE-2), 
        MOV mmap(@T0_L), bk47   ; bk47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
       MOV *sp(data_sz), T0
       SFTS T0, #-1
       SFTS T0, #-1
        
        MOV T0, ar5   ; 2*number of groups for stage 3    
        MOV #2, ar7          ; 1/2 * number of butterflies per group for stage 3
       

        ;AMOV #twiddle, xar3        ; not modified during iteration of the stages
        MOV xar0,xar1            ; data page = data page of indata
        MOV xar0,xar2            ; data page = data page of indata
        MOV xar0,xar4   ; data page = data page of indata (in-place butterflies)
        MOV xar0,xar6   ; data page = data page of indata (in-place butterflies)
        MOV xar3,xcdp      ; data page = data page of twiddles
        

        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------


            ; 1 - loop counter updates
        
            ; butterfly counter update
       SFTS ar7, #1
    ||    MOV #0, ar4 
        SUB #2,ar7,ar0
        MOV ar0, brc1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS ar5, #-1
        SUB  #1,ar5,ar0     
        MOV ar0, brc0         

            ; stage "counter" update (t0=0 <=> last stage)
         AMOV ar0, t0

            ; 2 - pointer modifier update
                            
            ; t1 is the pointer modifier                    
    ||   SFTS  t1,#-1        

            ; 3 - index updates                  
            ; ar0 -> Qr[0]
            ; ar1 -> Qi[0]
            ; ar2 -> Pr[0]
            ; ar4 -> Pr'[0]  (performed above to use parallelism)
            ; ar6 -> Qr'[0]

 
        SFTS ar0, #1
        ADD #1, ar0,ar1
        MOV #0, ar2
    ||  MOV ar0, ar6 
        
        
        
group:  ; begining of a new group
        

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (cdp) is updated inside the loop
        
                
        RPTBLOCAL r2_loop1

        
                ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
    ||  ADD  t1,ar1       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 
      ||    MOV ar3, cdp

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0>>#1, dual(*(ar4+t1))               
                                                          
        ; --------------------------------------------------------------        
        ; DIT radix-2 butterfly
        ;
        ; Register usage:
        ; 
        ;     address registers
        ; ar0 = Qr
        ; ar1 = Qi
        ; ar2 = Pr:Pi
        ; ar4 = Pr':Pi'
        ; ar6 = Qr':Qi'
        ; cdp = Wr:Wi
        ;
        ;     temporary registers
        ; t1 pointer modifier (jump between two consecutive legs)
        ; t2, t3 - both modified
        ;
        ;     accu registers
        ; ac0, ac1, ac2, ac3 are all modified
        ; 
        ;
        ; Comments:
        ;
        ; This butterfly supports both in-place and out-if-place
        ; implementations.
        ;
        ; input data assumed to be in order (bit-reversion after fft)
        ;
        ; twiddle table
        ;   - assumed to be in bit-reversed order
        ;     - the twiddle factors stored in the tables are the pairs
        ;      {cos(2*pi*k/N) , sin(2*pi*k/N)} = {Wr[k] , -Wi[k]}
        ;   - first twiddle pair {1,0} is suppressed (since the first
        ;       butterfly is computed out of the inner loop)
        ;   - second twiddle pair {0,1} replaced by {0,-1} (-1 can be
        ;     represented with full precision but not 1)
        ;   - when inner loop starts, cdp should point to the
        ;     third twiddle pair {1/sqrt(2),1/sqrt(2)}
        ;
        ; pointer registers
        ;   ar0 -> Qr[]
        ;   ar1 -> Qi[]
        ;   ar2 -> Pr[]
        ;   ar4 -> Pr'[]
        ;   ar6 -> Qr'[]
        ;   cdp -> W[] (bit-reversed twiddle table)
        ;
        ; --------------------------------------------------------------        
        
        
          RPTBLOCAL r2_loop2          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

          
         MACR	*(AR0+T1), *CDP+, AC3   
         ::MASR	*(AR1+T1), *CDP+, AC2   
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

         
          OR AC3 << #-16, AC2      
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1>>#1, dual(*(ar6+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop2:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0>>#1, dual(*(ar4+t1)) 
        
                                   ; end of butterfly loop
        
r2_loop1:        MOV AC1>>#1, dual(*(ar6+t1))      ; store last Qr':Qi'
        
                                   ; end of group loop

        SUB #1, T0
        
        BCC stage,t0!=#0       ; end of stage loop       	
   	   
; last r2 stage
; no scaling performed
;
; modify ST2 to select linear or circular addressing modes
final_stage:      AND	#0xF000 , mmap(ST2_55)  ; circular ar0, ar1, ar2, ar4 and ar6
      
         MOV #2, T1  
         MOV *sp(data_sz), T0       ; t0 = #fftsize
         MOV *sp(data_ptr), AR2		; ar2 = #fftdata  
         MOV AR2, AR4               ; ar4 = #fftdata  
         MOV AR2, AR0
         AADD T1, AR0               ; ar0 = fftdata + 2 
         MOV #7, AR1
         ADD AR2, AR1               ; 
         MOV AR0, AR5				; ar5 = fftdata + 2 
         SFTS T0, #-1  
         SUB #2, T0
         MOV T0, BRC0               ; brc0 = fftsize/2-2 
         MOV #4, T1
         MOV ar3, cdp             
                      
              ; ac2=Qr[0]:Qi[0] 
        MOV dbl(*(ar0+t1)), ac2
       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; cdp = #twiddle
       ADD	dual(*AR2), AC2, AC0 

        
                ; ac1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
       SUB	AC2, dual(*(AR2+T1)), AC1    
      || MOV ac0, dbl(*(ar4+t1))               
                                                          
        
          RPTBLOCAL r2_loop3          


                    ; ac2=Qr[n]*Wr                                    
                    ; ac3=Qi[n]*Wr
          MPY	*AR0, *CDP+, AC2               
        ::MPY	*AR1, *CDP+, AC3                           
                
        
                    ; ac3=Qi[n]*Wr+Qr[n]*Wi
                    ; ac2=Qr[n]*Wr-Qi[n]*Wi

        MASR	*(AR1+T1), *CDP+, AC2  
        ::MACR	*(AR0+T1), *CDP+, AC3   
            
            
                    ; ac2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

        
          OR AC3 << #-16, AC2      
                    ; hi(ac0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(ac0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                    ; store Qr'[n-1]:Qi'[n-1]

	   ADD	dual(*AR2), AC2, AC0
	   ||  MOV ac1, dbl(*(ar5+t1)) 
    
    
                    ; hi(ac1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(ac1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

r2_loop3:	SUB	AC2, dual(*(AR2+T1)), AC1
		|| MOV ac0, dbl(*(ar4+t1)) 
        
                                   ; end of butterfly loop
                              
                      
        MOV AC1, dbl(*(ar5+t1))
      
              
end_benchmark:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP


;Context restore 



	POPBOTH XAR7
	POPBOTH XAR6
	POPBOTH XAR5
      POP T3
      POP T2 

      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)

 

	
	RET 

	.end         
        






convol.asm/     1161799571  0     0     0       5183      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    convol
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              single-MAC approach.  C-callable.
;
; Usage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             ushort nr,
;                             ushort nh)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer

      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000000000010b   ;circular/linear pointers


      .global _convol

      .text
_convol:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------


; x pointer - passed in its destination register, need do nothing

; h pointer - setup

	MOV	mmap(AR1), h_base	;base address of h[]

	SUB	#1, T1, h_ptr		;h_ptr = nh-1 (end of h[])

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior

	MOV	#ST2mask, mmap(ST2_55)	;configure circular/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
	SUB	#1, T0			;T0 = nr - 1
	MOV	T0, outer_cnt		;outer loop executes nr times
	SUB	#3, T1, T0		;T0 = nh - 3
	MOV	T0, inner_cnt		;inner loop executes nh-2 times

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
	SUB	#2, T1			;T1 = nh-2, adjustment for x_ptr

;
; Start of outer loop
;----------------------------------------------------------------
	||RPTBLOCAL	loop1-1		;start the outer loop

;1st iteration
	MPYM	*x_ptr+, *h_ptr-, AC0

;inner loop
	||RPT	inner_cnt
	MACM	*x_ptr+, *h_ptr-, AC0

;last iteration has different pointer adjustment and rounding
	MACMR	*(x_ptr-T1), *h_ptr-, AC0

;store result to memory
	MOV	HI(AC0), *r_ptr+	;store Q15 result to memory

loop1:					;end of outer loop

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred
check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	||RET				;return to calling function

;----------------------------------------------------------------
;End of file

convol1.asm/    1161799559  0     0     0       6297      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    convol1
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              dual-MAC approach.  C-callable.
;
; Useage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             ushort nr,
;                             ushort nh)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ    .set 1               ;return address
REG_SAVE_SZ    .set 0               ;save-on-entry registers saved
FRAME_SZ       .set 0               ;local variables
ARG_BLK_SZ     .set 0               ;argument block

PARAM_OFFSET   .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz
      .asg     XCDP, xh_base        ;extended base address for h_ptr

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000100000000b    ;circular/linear pointers


      .global _convol1

      .text
_convol1:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

      AND	#001FFh, mmap(ST0_55)     ;clear all ACOVx,TC1, TC2, C

      OR	#04140h, mmap(ST1_55)     ;set CPL, SXMD, FRCT
      
      AND	#0F9DFh, mmap(ST1_55)     ;clear M40, SATD, 54CM

      AND	#07A00h, mmap(ST2_55)     ;clear ARMS, RDM, CDPLC, AR[0-7]LC
      
      AND	#0FFDDh, mmap(ST3_55)     ;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer - setup
      MOV	XAR1, xh_base               ;extended base address for h_ptr

      SUB	#1, T1, AC0                ;AC0 = nh-1

      MOV	mmap(AC0L), h_ptr                ;h_ptr = nh-1 (end of h[])

      MOV	mmap(AR1), h_base               ;base address of coefficients

      MOV	mmap(T1), h_sz                  ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior
      MOV	#ST2mask, mmap(ST2_55)            ;configure circular/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
      SFTS	T0, #-1                 ;T0 = nr/2
      SUB	#1, T0                  ;T0 = (nr/2 - 1)
      MOV	T0, outer_cnt                ;outer loop executes nr/2 times
      SUB	#3, T1, T0                 ;T0 = nh-3

      MOV	T0, inner_cnt                ;inner loop executes nh-2 times
      ||MOV	#1, T0                     ;x_ptr offset for parallel computation

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
      SUB	#3, T1                  ;DR1 = nh-3, adjustment for x_ptr

;
; Start of outer loop
;----------------------------------------------------------------
      ||RPTBLOCAL	loop1-1               ;start the outer loop

;1st iteration
      MPY	*x_ptr+, *h_ptr-, AC0                   ;part 1 of dual-MPY
      ::MPY	*x_ptr(T0), *h_ptr-, AC1                 ;part 2 of dual-MPY

;inner loop
      ||RPT	inner_cnt
      MAC	*x_ptr+,  *h_ptr-, AC0           ;part 1 of dual-MAC
      ::MAC	*x_ptr(T0), *h_ptr-, AC1         ;part 2 of dual-MAC

;last iteration has different pointer adjustment and rounding
      MACR	*(x_ptr-T1), *h_ptr-, AC0  ;part 1 of dual-MAC
      ::MACR	*x_ptr(T0), *h_ptr-, AC1    ;part 2 of dual-MAC

;store result to memory
      MOV	HI(AC0), *r_ptr+             ;store 1st Q15 result to memory
      MOV	HI(AC1), *r_ptr+             ;store 2nd Q15 result to memory

loop1:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      MOV	#0, oflag                                        ;clear oflag

      XCCPART	check1, overflow(AC0)               ;clears ACOV0
      ||MOV	#1, oflag                                      ;overflow occurred
check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
      BCLR	FRCT      ;clear FRCT

      AND	#0FE00h, mmap(ST2_55)     ;clear CDPLC and AR[7-0]LC

      BSET	ARMS      ;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
      ||RET                      ;return to calling function

;----------------------------------------------------------------
;End of file

convol2.asm/    1161799565  0     0     0       5654      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    convol3
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              dual-MAC approach.  C-callable.
;
; Usage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             ushort nr,
;                             ushort nh)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ    .set 1               ;return address
REG_SAVE_SZ    .set 0               ;save-on-entry registers saved
FRAME_SZ       .set 0               ;local variables
ARG_BLK_SZ     .set 0               ;argument block

PARAM_OFFSET   .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz
      .asg     XCDP, xh_base        ;extended base address for h_ptr

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000100000000b    ;circular/linear pointers


      .global _convol2

      .text
_convol2:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer - setup

	MOV	XAR1, xh_base		;extended base address for h_ptr

	SUB	#1, T1, AC0		;AC0 = nh - 1

	MOV	mmap(AC0L), h_ptr	;h_ptr = nh-1(end of h[])

	MOV	mmap(AR1), h_base	;base address of coefficients

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior
	MOV	#ST2mask, mmap(ST2_55)	;configure circular/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
	SFTS	T0, #-1			;T0 = nr/2
	SUB	#1, T0			;T0 = (nr/2 - 1)
	MOV	T0, outer_cnt		;outer loop executes nr/2 times
	SUB	#3, T1, T0		;T0 = nh - 3

	MOV	T0, inner_cnt		;inner loop executes nh-2 times
	||MOV	#1, T0			;x_ptr offset for parallel computation

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
	SUB	#3, T1			;T1 = nh-3, adjustment for x_ptr

;
; Start of outer loop
;----------------------------------------------------------------
	RPTBLOCAL	loop1-1		;start the outer loop

;1st iteration
	MPY	*x_ptr+, *h_ptr-, AC0		;part 1 of dual-MPY
	::MPY	*x_ptr(T0), *h_ptr-, AC1	;part 2 of dual-MPY

;inner loop
	||RPT	inner_cnt
	MAC	*x_ptr+, *h_ptr-, AC0		;part 1 pf dual-MAC
	::MAC	*x_ptr(T0), *h_ptr-, AC1	;part 2 of dual-MAC

;last iteration has different pointer adjustment and rounding
	MACR	*(x_ptr-T1), *h_ptr-, AC0	;part 1 pf dual-MAC
	::MACR	*x_ptr(T0), *h_ptr-, AC1	;part 2 of dual-MAC

;store result to memory
	MOV	pair(HI(AC0)), dbl(*r_ptr+)		;store both Q15 results to memory

loop1:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred
check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	||RET				;return to calling function

;----------------------------------------------------------------
;End of file
craw.asm/       1161799579  0     0     0       10198     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    corr_raw
; Processor:   C55xx
; Description: raw full length correlation of two vectors
;
;
; Usage: ushort corr_raw(DATA *x, DATA *r, ushort nx, ushort nr)
;
; Copyright Texas instruments Inc, 2000
; History:
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
	.global _corr_raw
	.text
    
_corr_raw

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ	
	.asg    "0 + FRAME_SZ", SAVE_AR6
	.asg    "2 + FRAME_SZ", SAVE_AR7
	.asg    "4 + FRAME_SZ", SAVE_AR5
	.asg    0 + REG_SAVE_SZ + FRAME_SZ, RETURN_ADDR
	.asg    0,	y_orig

	.asg	AR0, x_ptr
	.asg	XAR0, Xx_ptr
	.asg	AR1, y_ptr
	.asg	XAR1, Xy_ptr
	.asg	AR2, r_ptr
	.asg    AR3, mac_cnt
	.asg    AR4, x_save
	.asg    XAR4, Xx_save
	.asg    AR6, x2_save
	.asg    XAR6, Xx2_save
	.asg	AR5, y_save
	.asg	XAR5, Xy_save
	.asg    AR7, region1_and_3_loop_cnt

	.asg	T0, nx
	.asg	T1, ny
	
    .asg	AC2, odd
    
	.asg	AC1, B
	.asg	AC0, A
;	.asg    AC0, oflag           ;returned value
    .asg    T0, oflag   		; for C55, return value in T0, c54 in AC0
	
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
    PSH mmap(ST0_55)
    PSH mmap(ST1_55)
    PSH mmap(ST2_55)
    PSH mmap(ST3_55)
	AADD #-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 
	|| BSET #ST1_SXMD, ST1_55

	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6 
	|| BSET #ST1_FRCT, ST1_55
	
        MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 

;---------- X pointer setup    
; x_ptr		-	X pointer as passed
; x_save	-	X+nx
; x2_save	-	X
	MOV Xx_ptr, Xx2_save ;
	MOV Xx_ptr, Xx_save ;
	MOV x_ptr, A
	ADD nx, A
	MOV A, x_save
	
;---------- Y pointer setup    
; y_ptr		-	Y pointer as passed
; y_orig	-	Unchainged original Y pointer
	MOV Xy_ptr, Xy_save
	MOV Xy_ptr ,dbl(*sp(#(y_orig)))
	
; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
	MOV nx, B
	SUB #4, B
;    region1_and_3_loop_cnt = B
	MOV B, region1_and_3_loop_cnt
	SUB #1, x_save

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
;	TC1 = bit(region1_and_3_loop_cnt, @#0)	; Test to see if the LSB 
											; of NR is set. If it is, 
											; then we have an odd number
	BTST @#0, region1_and_3_loop_cnt, TC1
	; If !#0 (even), then we actually have an odd number of MAC's to 
	; do!
	MOV #0, odd
;	if (!TC1) execute(D_unit)
    .if  $isdefed("SI_BUGS")
	XCC temp000529, !TC1
	.else
	XCCPART temp000529, !TC1
	.endif
 	MOV #-1, odd            ; Setup the odd flag for later use 
temp000529:	
	
; Begin Region 1:                                      
;----------------------------------------------------------------
REGION1:
	MOV Xy_save, Xy_ptr
	MOV Xx_save, Xx_ptr
		
; For the dual MAC, we need to divide by two followed
; by a subsequent subtraction by 1 only if we have and odd number
; of MAC's to do. 
; 	region1_and_3_loop_cnt = region1_and_3_loop_cnt >> #1;
	SFTL region1_and_3_loop_cnt, #-1
;	if (odd<#0) execute(d_unit)								
    .if  $isdefed("SI_BUGS")
	XCC temp000529b, odd < #0
	.else
	XCCPART temp000529b, odd < #0
	.endif
	SUB #1, region1_and_3_loop_cnt
temp000529b:
    MOV region1_and_3_loop_cnt, BRC0
	MOV #0, mac_cnt             ; 2 cycles 

; Calculate first couple of elements outside of the loop     
; ---- 1 -----
	MPYMR *x_ptr, *y_ptr+, A
	MOV HI(A), *r_ptr+
	
; ---- 2 and Pointer stuff ----

	MPYM *x_ptr-, *y_ptr-, A || ADD #2, y_save

	MACMR *x_ptr, *y_ptr, A, A
	    
	MOV Xx_save, XCDP
	MOV Xy_save, Xx_ptr
	MOV Xx_ptr, Xy_ptr
	ADD #1, x_ptr, y_ptr    ; Setup the secondary point in case
						; we enter the Dual MAC	
	
	MOV HI(A), *r_ptr+
	
;If there is an even number, skip the extra MAC
	BCC REGION1_LOOP, odd == #0
	
; ---- 3 -----
REGION1_extra_mac:
	MPYM  *x_ptr-, *CDP-, A || ADD #1, y_save 

	MACM *x_ptr-, *CDP-, A
	
	MACMR *x_ptr-, *CDP-, A || MOV x_save, CDP
	
	MOV Xy_save, Xx_ptr
	MOV Xx_ptr, Xy_ptr
	ADD #1, x_ptr, y_ptr
	ADD #1, mac_cnt
	MOV mac_cnt, CSR
	MOV HI(A), *r_ptr+

REGION1_LOOP:
	
	RPTBLOCAL endlocal1
    ADD #2, y_save

; ---- Preload A ----
	MPY *x_ptr-, *CDP-, B :: MPY *y_ptr-, *CDP-, A
	
; ---- Main Dual MAC loop  ----        
	RPTADD CSR, #2
	MAC *x_ptr-, *CDP-, B :: MAC *y_ptr-, *CDP-, A

; ---- Cleanup MAC ----
	MACMR *x_ptr, *CDP, B
	MACM *y_ptr-, *CDP-, A
	MACMR *y_ptr-, *CDP-, A

; ---- Reload Pointers ----	
	MOV Xx_save, XCDP
	MOV Xy_save, Xx_ptr
	MOV Xx_ptr, Xy_ptr
	ADD #1, x_ptr, y_ptr

; ---- Store ----    
			MOV HI(B), *r_ptr+
endlocal1:	MOV HI(A), *r_ptr+

    

; ---- Reload Pointers ----	
	MOV dbl(*sp(#(y_orig))), Xy_save
	MOV Xx2_save, Xx_save

;
; Begin Loop for Region 2:                                      
;----------------------------------------------------------------
REGION2:
	MOV ny, A
	SUB nx, A
	  
	MOV A, DR3
	MOV DR3, BRC0

	MOV nx, mac_cnt
	
	MOV Xx_save, Xx_ptr
	SUB #3, mac_cnt
	MOV Xy_save, Xy_ptr

REGION2_LOOP:
	MOV mac_cnt, CSR
	RPTBLOCAL localend2
; ---- Setup pointers ----
	ADD #1, y_save
	
; ---- Preload A ----
	MPYM *x_ptr+, *y_ptr+, A
    
; ---- Main MAC loop  ---- 
;	MOV mac_cnt, CSR       ; moved out of loop for reduce cycle
	RPT CSR
	MACM *x_ptr+, *y_ptr+, A, A

; ---- Cleanup ----
	MACMR *x_ptr+, *y_ptr+, A, A
	
; ---- Setup for subsequent passes through Region 2 ----     
	MOV Xx_save, Xx_ptr
	MOV Xy_save, Xy_ptr
	
; ---- Store ----      
localend2:	MOV HI(A), *r_ptr+

;
; Begin REGION3 loop:                                           
;----------------------------------------------------------------
REGION3:

	MOV region1_and_3_loop_cnt, BRC0
	MOV Xx_save, XCDP
	MOV Xy_save, Xx_ptr
	MOV Xx_ptr, Xy_ptr
	ADD #1, x_ptr, y_ptr

    ; We are re-loading mac_cnt to remove the dependency 
    ; from the region 2 setup code
	MOV nx, mac_cnt
	SUB #5, mac_cnt
	MOV mac_cnt, CSR
	
REGION3_LOOP:
	RPTBLOCAL localend3
	ADD #2, y_save
	
; ---- Preload A ----
	MPY *x_ptr+, *CDP+, B :: MPY *y_ptr+, *CDP+, A
   
; ---- Main Dual MAC loop  ----        
	RPTSUB CSR, #2
	MAC *x_ptr+, *CDP+, B :: MAC *y_ptr+, *CDP+, A
	
; ---- Cleanup MAC ----
	MACMR *y_ptr, *CDP, A
	MACM *x_ptr+, *CDP+, B
	MACMR *x_ptr, *CDP, B

; ---- Reload Pointers ----	
	MOV Xx_save, XCDP
	MOV Xy_save, Xx_ptr
	MOV Xx_ptr, Xy_ptr
	ADD #1, x_ptr, y_ptr
	
; ---- Store ----    
			MOV HI(B), *r_ptr+
localend3:	MOV HI(A), *r_ptr+

;
; Calculate last correlation elements outside of loop       
;----------------------------------------------------------------
	BCC REGION3_FINAL, odd == #0

; ---- 3 -----
	MPYM *x_ptr+, *CDP+, A || ADD #1, y_save
	
    MACM *x_ptr+, *CDP+, A
    MACMR *x_ptr, *CDP, A
    
	MOV Xx_save, XCDP
	MOV Xy_save, Xx_ptr
	MOV HI(A), *r_ptr+

; ---- 2 -----
REGION3_FINAL:
	MPYM *x_ptr+, *CDP+, A
	MACMR *x_ptr, *CDP-, A
	MOV HI(A), *r_ptr+

; ---- 1 -----
	MPYM *x_ptr, *CDP, A
	MOV HI(A), *r_ptr+
	
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV #0, oflag
	
    .if  $isdefed("SI_BUGS")
	XCC dummy1, overflow(A)
	.else
	XCCPART dummy1, overflow(A)
	.endif
; dummy1:  MOV #1, A			; bug! put in oflag
dummy1:  MOV #1, oflag 		; 
	
    .if  $isdefed("SI_BUGS")
	XCC dummy2, overflow(B)
	.else
	XCCPART dummy2, overflow(B)
	.endif
; dummy1:  MOV #1, A			; bug! put in oflag
dummy2:	MOV #1, oflag 

; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
	MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7
	|| BCLR #ST1_SATD, ST1_55
	
	MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6
	|| BCLR SATA
	
	MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5
	|| BCLR #ST1_FRCT, ST1_55	
      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP
      POP mmap(ST3_55)
      POP mmap(ST2_55)
      POP mmap(ST1_55)
      POP mmap(ST0_55)
;
; Return to calling function
;----------------------------------------------------------------
	return ; RETD
;----------------------------------------------------------------
;End of file
cubias.asm/     1161799584  0     0     0       11324     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    corr_unbias
; Description: unbiased full length correlation of two vectors
; Processor:   C55xx
;
; Useage: ushort corr_raw(DATA *x, DATA *r, ushort nx, ushort nr)
; Copyright Texas instruments Inc, 2000
;
; History:
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
	.global _corr_unbias
_corr_unbias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
;REG_SAVE_SZ       .set 3            ;save-on-entry registers saved
REG_SAVE_SZ       .set 6            ;save-on-entry registers saved
FRAME_SZ          .set 8            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------
PARAM_OFFSET    .set   REG_SAVE_SZ + FRAME_SZ

	.asg    0, temp
	.asg    1, x_orig
	.asg    3, y_orig
	.asg    5, r_orig
	
	.asg    "0 + FRAME_SZ", SAVE_AR6
	.asg    "2 + FRAME_SZ", SAVE_AR7
	.asg    "4 + FRAME_SZ", SAVE_AR5
	.asg    "0 + REG_SAVE_SZ + FRAME_SZ", RETURN_ADDR

	.asg	AR0, x_ptr
	.asg	XAR0, Xx_ptr	
	.asg	AR1, y_ptr
	.asg	XAR1, Xy_ptr
	.asg	AR2, r_ptr
	.asg	XAR2, Xr_ptr
	.asg    AR3, mac_cnt
	.asg    AR4, x_save
	.asg    XAR4, Xx_save
	.asg	AR5, y_save
	.asg	XAR5, Xy_save	
	.asg	AR6, r1_r3_count
	.asg    AR7, r2_ptr
	.asg    XAR7, Xr2_ptr
	
	.asg	T0, nx
	.asg	T1, ny
	
    .asg	AC2, odd
	.asg	AC3, mytemp
	.asg	AC1, B
	.asg	AC0, A
	.asg    AC0, oflag           ;returned value

	
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        PSH mmap(ST0_55)	
        PSH mmap(ST1_55)	
        PSH mmap(ST2_55)	
        PSH mmap(ST3_55)	
	AADD #-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
	MOV	XAR5, dbl(*SP(#(SAVE_AR5)))	; PSHM    XAR5 
	|| BSET #ST1_SXMD, ST1_55

        MOV	XAR7, dbl(*SP(#(SAVE_AR7)))	; PSHM    XAR7 
	|| BSET #ST1_FRCT, ST1_55
	
	MOV	XAR6, dbl(*SP(#(SAVE_AR6)))	; PSHM    XAR6 

;---------- X pointer setup    
; x_ptr		-	X pointer as passed
; x_save	-	Used extensively in Region 3 and Region 2
; x_orig	-	Unchanged original X pointer
	MOV Xx_ptr, dbl(*sp(#(x_orig)))
	ADD nx, x_ptr
	SUB #1, x_ptr
	MOV Xx_ptr, Xx_save
  
;---------- Y pointer setup    
; y_ptr		-	Y pointer as passed
; y_save	-	Y+nx-2 and Y+nx-1 in Region 3
; y_orig		-	Unchainged original Y pointer
    MOV Xy_ptr, dbl(*sp(#(y_orig)))
	MOV y_ptr, A
	ADD nx, A
	SUB #2, A
	MOV Xy_ptr, Xy_save
	MOV A, y_save

;---------- R pointer setup    
; r_ptr		-	R pointer as passed. Eventually used and initialized as r+nx-2
; r2_ptr	-	r+ny
; r_orig	-	Unchainged original Y pointer
	MOV Xr_ptr,dbl( *sp(#(r_orig)))
	MOV r_ptr, A
	MOV r_ptr, B
	ADD nx, B
	SUB #2, B
	MOV B, r_ptr
	|| ADD ny, A
	MOV Xr_ptr, Xr2_ptr
	MOV A, r2_ptr

;
; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
	|| MOV nx, B
	MOV nx, A
	SUB #4, B
	SUB #1, A
	|| MOV B, mac_cnt
	MOV B, r1_r3_count


;+++++++++++ BIAS Calculator +++++++++++++++
; Upon entry:
; r_ptr	=	r+nx-2
; r2_ptr	=	r+ny
; mac_cnt	=	nx-4
; temp		=	nx-1
	;Setup BRC for localrepeat
;	BRC0 = mac_cnt
	;Setup n_mac
;	|| *sp(#(temp)) = A
	MOV mac_cnt, BRC0 || MOV A, *sp(#(temp))
		
	; Clear SXMD
;	bit(ST1,#ST1_SXMD) = #0	; Clear SXMD
	BCLR #ST1_SXMD, ST1_55
		
	RPTBLOCAL biascalclocalend
	
	;Compute bias value
	MOV #32767, A || RPT #15
    
    SUBC *sp(#(temp)), A, A
    
	; Adjust the temp value
	ADD #-1, *sp(#(temp))
	
	;Store bias value twice into output array
					MOV A, *r_ptr-
biascalclocalend:	MOV A, *r2_ptr+
	
	; Setup SXMD
	BSET #ST1_SXMD, ST1_55
			
;+++++++++++ End of BIAS calculator +++++++++++++++

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
	BTST @#0, r1_r3_count, TC1
	MOV #0, odd
    .if  $isdefed("SI_BUGS")
	XCC temp000529, !TC1
	.else
	XCCPART temp000529, !TC1
	.endif
	MOV #-1, odd
temp000529: 

; For the dual MAC, we need to divide by two followed
; by a subsequent subtraction by 1 only if we have and odd number
; of MAC's to do. 
; 	r1_r3_count = r1_r3_count >> #1;
;	|| if (odd<#0) execute(d_unit)								
;		r1_r3_count = r1_r3_count - #1
;   BRC0 = r1_r3_count

	SFTL r1_r3_count, #-1
    .if  $isdefed("SI_BUGS")
	XCC temp000529b, odd < #0
	.else
	XCCPART temp000529b, odd < #0
	.endif
	SUB #1, r1_r3_count
temp000529b:
    MOV r1_r3_count, BRC0

	|| MOV nx, B
	SUB #4, B
	MOV B, mac_cnt
	
    
; Initial lag is in region 1, load initial MAC count and      
; number of elements to calculate in region 1                 
;----------------------------------------------------------------

REGION1_AND_3:

; ---- Pointer Setup ----
	MOV Xy_save, Xy_ptr
	MOV Xy_ptr, Xx_ptr
	SUB #1, y_ptr, x_ptr
	MOV Xx_save, XCDP
	    
	;Reset r_ptr to initial values
	MOV dbl(*sp(#(r_orig))), B
	ADD nx, B
	SUB #2, B
	MOV B, Xr_ptr

;--------- Calculate sum in region 1  
	MOV mac_cnt, CSR

	RPTBLOCAL endlocal1
    SUB #2, y_save
    
; ---- Preload A ----
	MPY *x_ptr-, *CDP-, A :: MPY *y_ptr-, *CDP-, B
	
; ---- Main Dual MAC loop  ---- 	
	RPTSUB CSR, #2
	MAC *x_ptr-, *CDP-, A :: MAC *y_ptr-, *CDP-, B
		
; ---- Cleanup MAC ----
    MACM *y_ptr-, *CDP-, B
    MOV Xx_save, XCDP
    
; ---- BIAS A and B and Store ----	
	MPYMR *r_ptr, B, B
	MOV Xy_save, Xy_ptr
	
	MOV Xy_ptr, Xx_ptr
	SUB #1, x_ptr
	MOV HI(B), *r_ptr-
	MPYMR *r_ptr, A, A
endlocal1:	MOV HI(A), *r_ptr-
; ---- Setup for Region 1 ----       

;---------- Calculate some MAC's outside of the loop
	BCC REGION1_FINAL, odd == #0
	
; ---- 3 -----	
	MPYM *y_ptr-, *CDP-, A
	MACM *y_ptr-, *CDP-, A
	MACM *y_ptr, *CDP, A
	
	; BIAS
	MPYMR *r_ptr, A, A	
	
	MOV HI(A), *r_ptr-
	
	; Setup pointers for next loop
	SUB #1, y_save
	MOV Xx_save, XCDP
	MOV Xy_save, Xy_ptr


; ---- 2 -----	
REGION1_FINAL:
	MPYM *y_ptr-, *CDP-, A
	MACMR *y_ptr, *CDP+, A
	MOV HI(A << #-1), *r_ptr-

; ---- 1 -----	
	MPYM *y_ptr, *CDP, A
	MOV HI(A), *r_ptr-

;--------- Calculate sum in region 3                              
	MOV r1_r3_count, BRC0
	MOV mac_cnt, CSR

; ---- Pointer Setup ----
	MOV dbl(*sp(#(y_orig))), B
	ADD ny, B
	SUB #1, B
	MOV B, Xy_save
	MOV Xy_save, XCDP

	; Compute x_save=X+nx-2
	MOV dbl(*sp(#(x_orig))), Xx_save
	ADD nx, x_save
	SUB #2, x_save

	MOV Xx_save, Xy_ptr
	MOV Xy_ptr, Xx_ptr
	SUB #1, y_ptr, x_ptr
	
	;Reset r2_ptr to initial values
	MOV dbl(*sp(#(r_orig))), A
	ADD ny, A
	MOV A, Xr2_ptr

	RPTBLOCAL localend3
	SUB #2, x_save
	
; ---- Preload A ----
	MPY *x_ptr-, *CDP-, A :: MPY *y_ptr-, *CDP-, B
	
; ---- Main Dual MAC loop  ---- 	
	RPTSUB CSR, #2
	MAC *x_ptr-, *CDP-, A :: MAC *y_ptr-, *CDP-, B

; ---- Cleanup MAC ----
    MACM *y_ptr-, *CDP-, B
    MOV Xy_save, XCDP
        
; ---- BIAS A and B and Store ----	
	MPYMR *r2_ptr, B, B
    MOV Xx_save, Xy_ptr
	    
	MOV Xy_ptr, Xx_ptr
	SUB #1, x_ptr
	MOV HI(B), *r2_ptr+
	MPYMR *r2_ptr, A, A
localend3:	MOV HI(A), *r2_ptr+

; ---- Setup for Region 3 ----     

; ---- 3 -----	
	BCC REGION3_FINAL, odd == #0	
	
	; no need for division since the previous one did it for me already
	
	; MACs
	MPYM *y_ptr-, *CDP-, A
	MACM *y_ptr-, *CDP-, A
	MACM *y_ptr, *CDP, A
	
		
	; BIAS
	MPYMR *r2_ptr, A, A	
	
	MOV HI(A), *r2_ptr+
         
	; Setup pointers for next loop
	SUB #1, x_save
	MOV Xx_save, XCDP
	MOV Xy_save, Xy_ptr

; ---- 2 -----	
REGION3_FINAL:
	MPYM *y_ptr-, *CDP-, A
	MACMR *y_ptr+, *CDP, A
	MOV HI(A << #-1), *r2_ptr+
	
; ---- 1 -----	
	MPYM *y_ptr, *CDP, A
	MOV HI(A), *r2_ptr

;--------- Calculate sum in region 2
; ---- BIAS calculation -----	
	; Clear SXMD
	BCLR #ST1_SXMD, ST1_55
	
	; Actual calculation
	MOV #32767, A
	MOV nx, *sp(#(temp))
	RPT #15
	SUBC *sp(#(temp)), A, A
	ADD #1, A
	MOV A, *sp(#(temp))
	
	; Set SXMD
	BSET #ST1_SXMD, ST1_55
	
;----------
;	.end
;----------

REGION2:
	; Repeat setup
	MOV ny, A
	SUB nx, A
	MOV A, T3
	MOV T3, BRC0
	MOV nx, mac_cnt
 	SUB #2, mac_cnt
 	
	; R pointer setup
	MOV nx, B
	SUB #1, B
	ADD dbl(*sp(#(r_orig))), B
	MOV B, Xr_ptr

	; Setup pointers
	MOV dbl(*sp(#(y_orig))), Xy_save
	MOV dbl(*sp(#(x_orig))), Xx_save
	MOV Xx_save, XCDP
	MOV Xy_save, Xy_ptr
	MOV mac_cnt, CSR
	
REGION2_LOOP:
	RPTBLOCAL r2localloop

; ---- Setup pointers ----
	ADD #1, y_save

; ---- Preload A ----
	MPYM *y_ptr+, *CDP+, A

; ---- Main MAC loop  ---- 
;	MOV mac_cnt, CSR
	RPT	CSR
	MACM *y_ptr+, *CDP+, A
	
; ---- BIAS ----
	MPYMR *sp(#(temp)), A, A

; ---- Setup for subsequent passes through Region 2 ----     
	MOV Xx_save, XCDP
	MOV Xy_save, Xy_ptr
	
; ---- Store ----      
r2localloop:	MOV HI(A), *r_ptr+


; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV #0, oflag
	
    .if  $isdefed("SI_BUGS")
	XCC dummy1, overflow(A)
	.else
	XCCPART dummy1, overflow(A)
	.endif
dummy1:  MOV #1, A
	
    .if  $isdefed("SI_BUGS")
	XCC dummy2, overflow(B)
	.else
	XCCPART dummy2, overflow(B)
	.endif
dummy2:	MOV #1, A 

;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
	MOV	dbl(*SP(#(SAVE_AR7))), XAR7	; POPM    AR7
	|| BCLR #ST1_SATD, ST1_55
	
	MOV	dbl(*SP(#(SAVE_AR6))), XAR6	; POPM    AR6
	|| BCLR SATA
	
	MOV	dbl(*SP(#(SAVE_AR5))), XAR5	; POPM    AR5
	|| BCLR #ST1_FRCT, ST1_55

                                           	
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
        POP mmap(ST3_55)	
        POP mmap(ST2_55)	
        POP mmap(ST1_55)	
        POP mmap(ST0_55)	

;
; Return to calling function
;----------------------------------------------------------------
	return ; RETD
;----------------------------------------------------------------
;End of file
decimate.asm/   1161799593  0     0     0       6570      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    firdec
; Processor:   C55xx
; Description: Decimation filter with user specified FIR coefficients
;
;					
; Usage:   ushort firdec(DATA *x,	XAR0 
;			DATA *h,	XAR1 
;			DATA *r,	XAR2
;			DATA *dbuffer,	XAR3 
;			ushort nh,	T0 
;			ushort nx,	T1 
;			ushort D);	XAR4
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

	.ARMS_off		;enable assembler for ARMS=0
	.CPL_on			;enable assembler for CPL=1
	.mmregs			;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ	.set	1	;return address
REG_SAVE_SZ	.set	0	;save-on-entry registers saved
FRAME_SZ	.set	0	;local variables
ARG_BLK_SZ	.set	0	;argument block

PARAM_OFFSET	.set	ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
	.asg	AR0, x_ptr	;linear pointer
	.asg	AR1, h_ptr	;circular pointer
	.asg	AR2, r_ptr	;linear pointer
	.asg	AR4, db_ptr	;circular pointer

	.asg	BSA01, h_base	;base addr for h_ptr
	.asg	BK03, h_sz	;circ buffer size for h_sz
	.asg	BSA45, db_base	;base addr for db_ptr
	.asg	XAR4, xdb_base	;extended base addr for db_ptr
	.asg	BK47, db_sz	;circ buffer size for db_ptr
	.asg	BK47_L, db_sz_L	;for memory mapped access

	.asg	CSR, inner_cnt	;inner loop count
	.asg	BRC0, outer_cnt	;outer loop count

	.asg	T0, oflag	;returned value
	.asg	T2, DecFac	;decimation factor

ST2mask	.set	0000000000010010b	;circular/linear pointers


	.global	_firdec

	.text
_firdec:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

	PSH T2

	AND	#01FFh,mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C
	OR	#4140h,mmap(ST1_55)	;set CPL, SXMD, FRCT
	AND	#0F9DFh,mmap(ST1_55)	;clear M40, SATD, 54CM 
	AND	#07A00h,mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC
	AND	#0FFDDh,mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
	MOV	mmap(AR1),h_base	;base address of coefficients
	MOV	#0,h_ptr		;point to first coefficient
	MOV	mmap(T0),h_sz		;coefficient array size h_sz = nh

; r pointer - already passed in its destination register

; db pointer
	MOV	AR4,DecFac		;save DecFac = D
	MOV	XAR3,xdb_base		;db array address
	MOV	*AR3+,db_ptr		;index of oldest db entry
	MOV	mmap(AR3),db_base	;base address for db_ptr

	MOV	mmap(T0),db_sz		;db_sz = nh
	;?ADD #1,mmap(db_sz)		;db_sz = nh+1

; Set circular/linear ARx behavior
	OR	#ST2mask,mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
	BCLR	SXM
	MOV	T1,AC0			;AC0 = nx
	||RPT	#(16-1)
	SUBC	mmap(DecFac),AC0		
	SUB	#1,AC0			;
	MOV	AC0,mmap(outer_cnt)	;outer_cnt = (nx/D)-1
	BSET	SXM
	
	SUB	#3,T0			;setup reload for FIR taps inner_cnt = nh-3
	SUB	#2,DecFac		;setup reload for sample-to-db inner_cnt = D-2
	
	BCC	No_Decim, DecFac<0	
	
;
; Start of outer loop  D>=2
;----------------------------------------------------------------
	RPTBLOCAL	L1-1		;outer loop (nx/D) iterations
	
	;move next input value into delay buffer
	MOV	T0,inner_cnt		;inner_cnt = nh-3 (2 iter outside loop)
	||MOV	*x_ptr+,*db_ptr		

	;Sum h*x nh-iterations for next r value
	MPYM	*db_ptr+,*h_ptr+,AC0      
	||RPT	inner_cnt
	MACM	*db_ptr+,*h_ptr+,AC0,AC0
	MACMR	*db_ptr,*h_ptr+,AC0,AC0

	;store result to memory
	||MOV	DecFac,inner_cnt	;inner_cnt = D-2
	MOV	HI(AC0),*r_ptr+		;store Q15 value to memory
	
	;Move next D-1 input samples into delay buffer
	||RPT	inner_cnt
	MOV	*x_ptr+,*db_ptr-
L1:					;end of outer loop

	B	L2			;goto exit procedure
;
; Start of outer loop  D=1
;----------------------------------------------------------------
No_Decim:
	MOV	T0,inner_cnt		;inner_cnt = nh-3 (2 iter outside loop)
	RPTBLOCAL	L2-1		;start the outer loop
	
	;move next input value into delay buffer
	MOV	*x_ptr+,*db_ptr		

	;Sum h*x nh-iterations for next r value
	MPYM	*db_ptr+,*h_ptr+,AC0      
	||RPT	inner_cnt
	MACM	*db_ptr+,*h_ptr+,AC0,AC0
	MACMR	*db_ptr,*h_ptr+,AC0,AC0

	;store result to memory
	MOV	HI(AC0),*r_ptr+		;store Q15 value to memory
L2:					;end of outer loop
	
;
; Update the db entry point
;----------------------------------------------------------------
	MOV db_ptr,*-AR3		;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV #0,oflag			;clear oflag

	XCCPART overf_label, overflow(AC0) ;clears ACOV0
	||MOV #1,oflag			;overflow occurred
overf_label:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;	BCLR #ST1_FRCT,ST1_55		;clear FRCT
;	AND #0FE00h,mmap(ST2_55)	;clear CDPLC and AR[7-0]LC
;	BSET #ST2_ARMS,ST2_55		;set ARMS            
;	;BSET #ST1_FRCT,ST1_55		;set FRCT            

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
      POP T2
      POP   mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
      RET                         ;return to calling function

;----------------------------------------------------------------
;End of file
DLMS.asm/       1161799599  0     0     0       5568      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	dlms
; Processor:   C55xx
; Description: dlms fir filter
;
; Usage: short oflag = dlms(DATA *h, DATA *x, DATA *r, DATA *des,
;			DATA *dbuffer, DATA step, ushort nh, ushort nx)
;
; ...where
;	h[nh]		Pointer to coefficient vector of size nh
;			- h is stored in reverse order: h(n-1), ... h(0)
;	x[nx]		Pointer to input vector of size nx
;	r[xn]		Pointer to output data vector.
;			- r can be equal to x
;	des[nx]		Pointer to expected-output array
;	dbuffer[nh+2]	Pointer to delay buffer structure
;			- first element of structure is index into array
;			  of OLDEST data (to be overwritten with new)
;			- remaining elements are modulo-addressed for
;			  sample 0 to nh. NOTE that this delay buffer
;			  yields an array length of nh+1, which is used
;			  for Dual-MAC operations(not used here).
;	step		Scale factor to control adaptation rate = 2*mu
;	nh		Number of filter coefficients. Filter order = nh-1.
;	nx		Number of input samples to process (length of input
;			and output data vectors).
;	oflag	Overflow Flag
;			- If oflag = 1, a 32-bit overflow has occured
;			- If oflag = 0, a 32-bit overflow has not occured
;
;  Copyright Texas instruments Inc, 2000
;
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
;****************************************************************
		.length 32767
        .cpl_on

	.asg	0, save_T3		; 2*mu*error(i) variable
	.asg	1, save_AR5
	.asg	2, ret_addr
	.asg	3, arg_nx

; register usage
;	XAR0-XAR4, T0 & T1 as well as accumulators are all available to callee
;	XAR0 through XAR4 are already loaded with *x, *h, *r, *des and *dbuffer
;	 respectively upon entry.
;	While T0 and T1 are loaded with the values of STEP and NH, respectively

	.asg	ar0, ar_input
	.asg	ar1, ar_coef
	.asg	ar2, ar_output
	.asg	ar3, ar_des
	.asg	ar4, ar_dbuffer
	.asg	ar5, ar_data
	.asg	T0, T_step
	.asg	T1, T_nh

;*****************************************************************************
	.def	_dlms

_dlms:

; Preserve registers
;-------------------
	PSH T3, AR5					;AR5 will be used for the index into dbuffer
								;T3 is needed for LMS instruction

; Set math and overflow modes
;---------------------------
; Status registers
	MOV #0, mmap(ST0_55)		;all fields cleared (OVx, C, TCx)
	OR #4140h, mmap(ST1_55)	;set CPL, FRCT, SXMD
	AND #07940h, mmap(ST1_55)	;clear BRAF, M40, SATD, C16, 54CM, ASM
	OR #0022h, mmap(ST2_55)	;AR1 & AR5 pointers put in circular mode
	BCLR ARMS					;disable ARMS bit in ST2
	BCLR SST					;make sure Saturate-on-STore bit in ST3 is disabled

;
; Get arguments
;---------------
	MOV *ar_dbuffer+, ar_data	;set AR5 to index in data array
								; of oldest input sample
	MOV mmap(AR4), BSA45		;set BSA45 to start of data buffer
								; NOTE that this is the SECOND
								; element of the dbuffer structure
	MOV mmap(AR1), BSA01		;copy start of coeffs to BSA01
	MOV #0, ar_coef 			;...then set AR0 to zero (1st coeff)
	ADD #-1, *SP(arg_nx)		;sub 1 from # of inputs for loopcount
	MOV *SP(arg_nx), BRC0		;set outer loop to number of inputs-1
	MOV mmap(T_nh), BK03		;load BK03 with # of coeffs for use w/ AR2
	AADD #1, T_nh
	MOV mmap(T_nh), BK47		;load BK03 with # of data samples (nh+1)
								; in delay-line for use w/ AR4
	ASUB #3, T_nh
	MOV mmap(T_nh), BRC1		;set inner loop to number of coeffs-2

; Loop through input data stream
;-------------------------------
StartSample:
	MOV #0, AC1					;clear AC1 for initial error term
 ||	RPTBLOCAL Outer_End-1			;...while starting outer loop
	 MOV  HI(AC1), T3			;place error term in T3
	 MOV *ar_input+, *ar_data+	;copy input -> state(0)
	 MPYM *ar_data+, T3, AC0	;place first update term in AC0
 ||	 MOV #0, AC1				;...while clearing FIR value
	 LMS *ar_coef, *ar_data, AC0, AC1	;AC0 = update coef
								;AC1 = start of FIR output
 ||  RPTBLOCAL Inner_End-1			;...while starting inner loop
	  MOV HI(AC0), *ar_coef+	;store updated coef
 ||	  MPYM *ar_data+, T3, AC0	;...while calculating next update term
	  LMS *ar_coef, *ar_data, AC0, AC1	;AC0 = update coef

Inner_End:
					;AC1 = update of FIR output
	 MOV HI(AC0), *ar_coef+		;store updated coef
 ||	 MOV rnd(HI(AC1)), *ar_output+	;...and store FIR output

	 SUB AC1, *ar_des+ << #16, AC2	;AC2 is error amount
 ||	 AMAR *ar_data+				;point to oldest data sample
	MPYR T_step, AC2, AC1		;place updated mu_error term in AC1

Outer_End:

	MOV ar_data, *-ar_dbuffer	;dbuffer.index = index of oldest data

; Return overflow flag
; --------------------
    ||	MOV #0, T0				;store zero for return value
	XCCPART OvrFlow, overflow(AC1)
    || 	MOV #1, T0				;return value 1 if overflow was encountered
OvrFlow:

;
; Restore stack to previous value
; Reset status regs to restore normal C operating environment
; Return to calling function
;----------------------------------------------------------------
	POP T3, AR5

;NO presumed values in ST0 by C-environment

	BCLR FRCT					;clear FRCT bit in ST1 for C-environment
	BSET ARMS					;set ARMS bit for C-environment
	AND #0F800h, mmap(ST2_55) 	;all pointers put in linear mode

;No presumed values of ST3 were modified

	RET							;return to calling function

        .end

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
dlmsfast.asm/   1161799606  0     0     0       17550     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	dlms
; Processor:   C55xx
; Description: dlms fir filter
;
; Usage: short oflag = dlms(DATA *h, DATA *x, DATA *r, DATA *des,
;			DATA *dbuffer, DATA step, ushort nh, ushort nx)
;
; ...where
;	h[2nh]		Pointer to coefficient vector of size nh
;			- h is stored in reverse order: h(n-1), ... h(0)
;	x[nx]		Pointer to input vector of size nx
;	r[xn]		Pointer to output data vector.
;			- r can be equal to x
;	des[nx]		Pointer to expected-output array
;	dbuffer[nh+3]	Pointer to delay buffer structure
;			- first element of structure is index into array
;			  of OLDEST data (to be overwritten with new)
;			- remaining elements are modulo-addressed for
;			  sample 0 to nh+1. NOTE that this delay buffer
;			  yields an array length of nh+1, which is used
;			  for Dual-MAC operations(not used here).
;	step		Scale factor to control adaptation rate = 2*mu
;	nh		Number of filter coefficients. Filter order = nh-1.
;	nx		Number of input samples to process (length of input
;			and output data vectors).
;	oflag	Overflow Flag
;			- If oflag = 1, a 32-bit overflow has occured
;			- If oflag = 0, a 32-bit overflow has not occured
;
;  Copyright Texas instruments Inc, 2000
;
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
;****************************************************************
		.length 32767
        .cpl_on

	.asg    0, coef_cntr
	.asg    1, filt_cntr
	.asg    2, index_filt
	.asg	3, save_AR6		
	.asg	4, save_AR7
	.asg	5, save_T3		; 2*mu*error(i) variable
	.asg	6, save_AR5
	.asg	7, ret_addr
	.asg	8, arg_nx

	
	
	;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

		.bss err, 1

; register usage
;	XAR0-XAR4, T0 & T1 as well as accumulators are all available to callee
;	XAR0 through XAR5 are already loaded with *x, *h, *r, *des and *dbuffer
;	 respectively upon entry.
;	While T0 and T1 are loaded with the values of STEP and NH, respectively

	.asg	ar0, ar_input
	.asg	ar1, ar_coef
	.asg	ar2, ar_scratch
	.asg	ar3, ar_des
	.asg	ar4, ar_dbuffer
	.asg    ar5, ar_output
	.asg	ar6, ar_data1
	.asg	ar7, ar_data2
	.asg	T3, T_step
	.asg	T1, T_nh

;*****************************************************************************
	.def	_dlmsfast
	
	
	; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 3            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ
	

_dlmsfast:


; Preserve registers
;-------------------
	PSH T3
	PSHBOTH XAR5				;AR5 will be used for the index into dbuffer
								;T3 is needed for LMS instruction

	PSHBOTH XAR6				;AR6 and AR7 are used in this function
	PSHBOTH XAR7				;AR6 and AR7 are used in this function

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
	AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - one local variable


; Set math and overflow modes
;---------------------------
; Status registers
    MOV #0, mmap(ST0_55)                                ;all fields cleared (OVx, C, TCx)
    OR #4140h, mmap(ST1_55)                             ;set CPL, FRCT, SXMD
    AND #07940h, mmap(ST1_55)                           ;clear BRAF, M40, SATD, C16, 54CM, ASM
    OR #00C6h, mmap(ST2_55)                             ;AR1, AR2, AR6, & AR7 pointers put in circular mode
    BCLR ARMS                                           ;disable ARMS bit in ST2
    BCLR SST                                            ;make sure Saturate-on-STore bit in ST3 is disabled


;
; Get arguments
;---------------

    MOV XAR2, XAR5;                                     ;XAR5 set to ar_output
    MOV T0, T_step

; NOTE!!!  the index value saved points to the oldest value:
; EXample: if we need to update x(-16) and X(-15) it will point to X(-16) 

    MOV *ar_dbuffer, ar_data2                           ;set AR6 to index in data array
                                                        ; of oldest input sample
    MOV *ar_dbuffer+, ar_data1							
							
	 
;***** Delay buffer ********
;       
;   |          |     
;   | x(0)     | <------ ar_data1 
;   | x(1)     | <------ ar_data2
;   | x(-N)	   |
;   | x(-(N-1))|
;   | .....    |
;   | x(-2)    |  
;   | x(-1)    |    
	
								
    MOV mmap(ar_dbuffer), BSA67                         ;set BSA67 to start of data buffer
                                                        ; NOTE that this is the SECOND
                                                        ; element of the dbuffer structure

    ; initialize delay buffer CDP pointer	
    MOV mmap(ar_dbuffer), BSAC			
																											
    MOV mmap(T_nh), T0      
    AADD  AR1, T0 								
    MOV mmap(T0), BSA23                                 ; BSA scratch = BSA coeff + NH
    MOV #0, ar_scratch				
								
    MOV mmap(AR1), BSA01                                ;copy start of coeffs to BSA01
    MOV #0, ar_coef                                     ;...then set AR0 to zero (1st coeff)
	
	
    ; initialize counter for Coef update loop
    MOV T1, T0
    SFTS	T0, #-1                                     ;T0 = nh/2
    SUB		#5, T0                                      ;T0 = (nh/2 - 2 - 3) => (-3) is for inner loop unroll
    MOV T0,*SP(coef_cntr)
	
    ; initialize counter for Filter loop
    MOV T1, T0
    SUB	#2, T0                                          ;T0 = (nh - 2 - 4) => 4 is for unrolls
    MOV T0,*SP(filt_cntr)
    MOV *SP(filt_cntr), CSR
	
    ;initialize the error 
    AMOV #err, XCDP	
    MOV mmap(T_nh), BK03                                ;load BK03 with # of coeffs for use w/ AR2
    AADD #2, T_nh
    MOV mmap(T_nh), BK47                                ;load BK47 with # of data samples (nh+2)
                                                        ;in delay-line for use w/ AR6,7
    MOV mmap(T_nh), BKC
															
    MOV *SP(arg_nx), T0
    SFTS T0, #-1
    SUB #1, T0
    MOV mmap(T0), BRC0                                  ;BRC0 = nx/2 -1

    MOV #0,*CDP 	                                    ;Set initial error is 0
    MOV #5, T1		                                    ;circular buffer pointer wrap
    MOV #2, T0

    MOV *ar_input+, *ar_data2+                          ;update the two oldest values 
    MOV *ar_input+, *(ar_data2+T0) 
    AMAR *(ar_data1+T0)

    MOV ar_data2, *SP(index_filt)	
				
    RPTB #(ext_loop-1)

;  First Coefficient update stage
;  ------------------------------
;  Update Coefficients from the previous error e(n-1)
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address. 
;
;  AR6 ---> h
;  AR7 ---> h'
;  AR1 ---> x[n-(N-(2*k))]
;  AR3 ---> x[n-(N-(2*k+1))]
;  CDP ---> e(n-1)
;  T0 = #2
;  BRC1 = NH/2 -2
; 

; 21 = 15AD + 6IBQ stalls in the LOOP

;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   | h(0)    |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  


;***** Delay buffer ********
;                      
;   | x(0)     | 
;   | x(1)     | 
;   | x(-N)	   | <------ ar_data1
;   | x(-(N-1))| <------ ar_data2
;   | .....    |
;   | x(-2)    |  
;   | x(-1)    | 

    MOV *SP(coef_cntr), BRC1                                   ; movethis instruction earlier for benchmarking purpose
	
    MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))

    ; Following 3 unrolls for BRC1 set up 4 cycles before rptb
    
    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
    || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	


    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
    || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	

    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
    || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	
    

    RPTBLOCAL   #(coef_updt1 -1)                ; 2 stalls 	; segment update loop       
    MACR  *(ar_data1+T0),*CDP,AC0    			; AC0=AC0+2^15+en*x[n-(N-(2*k))]
    :: MACR  *(ar_data2+T0),*CDP,AC1    			; AC1=AC1+2^15+en*x[n-(N-(2*k+1))]
    MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 		; h'(N-1-(2*k)) = HIGH(AC0)
    || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	        ; h'(N-1-(2*k+1)) = HIGH(AC1)
                                                                ; HI(AC0) = h[N-(2*k+2)]
                                                                ; HI(AC0) = h[N-(2*k+2+1)]
                                            
    ; 1 stall in rptblocal loop after 1st iteration                                         
coef_updt1:    
    ; modify arr_data1 and ar_data2 pointing to the correct position      
    MACR  *(ar_data1+T1),*CDP,AC0      			; AC0=AC0+2^15+en*x[n-1]
    ::MACR  *(ar_data2+T1),*CDP,AC1      			; AC1=AC1+2^15+en*x[n-2]
    MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	        ; h'[0] = HIGH(AC0)
    || NOP                           			; h'[1] = HIGH(AC1)

;   Filtering stage
;	----------------
;	Two filters are processes in parallel using the dual MAC instruction.
;   The filter coefficients are stored in the buffers h[n](k) and h[n+1](k).
;   (n is the time index and k is the coefficient index)
;   We will use the following notations:
;										h(k)  = h[i](k) 
;										h'(k) = h[i+1](k)
;
;   Equations:
;   ----------
;   y(i)   =            h(0) x(i-1)+h(1)(1)x(i-2)+ ... +h(N-2)x(i-(N-1))+h(N-1)x(i-N)
;   y(i+1) = h'(0)x(i)+ h'(1)x(i-1)+       ...         +h'(N-1)x(i-(N-1)
;
;   Implementation:
;	---------------
;   Head and tail are computed using single MAC, all the other mpys are 
;   implemented using dual MAC.
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address.
;
;   CDP ---> db , circular
;   AR6 ---> h
;   AR7 ---> h'  
;
;
;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   |  h(0)   |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  


;***** Delay buffer ********
;                      
;   | x(0)     | 
;   | x(1)     | 
;   | x(-N)	   |
;   | x(-(N-1))|
;   | x(-(N-2))| <------ CDP
;   | .....    |
;   | x(-2)    | 
;   | x(-1)    | 

; TEMP comments 
; ar_coef and ar_scratch should be in correct position since they are circular ptrs
; CDP has to be set circular ( parameters BKC, BSAC are set in initialization code)
; the index of CDP has to be set
; CSR has to be set

    BSET CDPLC					; 
    MOV #0, AC1
    MOV XAR4, XCDP		; initialize extended part
    
    MOV *SP(index_filt), CDP    ; 
    MPYM   *ar_coef+,*CDP+,AC0	;   4 stalls				    ; h(N-1)x(i-N)	    
    
     ; Following 4 unrolls are for RPTC setup
;    MAC   *ar_coef+,*CDP+,AC0
;    :: MAC   *ar_scratch+,*CDP+,AC1

;    MAC   *ar_coef+,*CDP+,AC0
;    :: MAC   *ar_scratch+,*CDP+,AC1

;    MAC   *ar_coef+,*CDP+,AC0
;    :: MAC   *ar_scratch+,*CDP+,AC1

;    MAC   *ar_coef+,*CDP+,AC0
;    :: MAC   *ar_scratch+,*CDP+,AC1
		
    || RPT   CSR
    MAC   *ar_coef+,*CDP+,AC0
    :: MAC   *ar_scratch+,*CDP+,AC1
    
    MACM   *ar_scratch+,*CDP+,AC1					; h'(0)x(i)
    AMAR *+CDP(#3)
    
    MOV CDP, *SP(index_filt)
	
    ; store output
    MOV rnd(HI(AC0)), *ar_output+;
    MOV rnd(HI(AC1)), *ar_output+;
	

;   Error computation stage
;	-----------------------
;	Computing e(n) and e(n+1)		
    BCLR    CDPLC                                   ; 5 stalls; Disable CDP for circ addressing
    SUB     AC0,*ar_des+<<#16,AC0                   ; AC0 = e(n) = y(n) - AC0
    MPYR    T_step, AC0
    AMOV     #err, XCDP

    SUB     AC1,*ar_des+<<#16,AC2                   ; AC1 = e(n+1) = y(n+1) - AC1
    MPYR    T_step, AC2
    ||MOV     HI(AC0), *CDP                           ; 3 stalls
     
;  Second Coefficient update stage
;  ------------------------------
;  Update Coefficients from the previous error e(n)
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address. 
;
;  AR6 ---> h
;  AR7 ---> h'
;  AR1 ---> x[n-(N-(2*k))]
;  AR3 ---> x[n-(N-(2*k+1))]
;  CDP ---> e(n)
;  T0 = #2
;  BRC1 = NH/2 -2
; 				


;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   |  h(0)   |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  


;***** Delay buffer ********
;                      
;   | x(0)     | <------ ar_data1
;   | x(1)     | 
;   | x(-N)	   |
;   | x(-(N-1))| <------ ar_data1
;   | .....    | <------ ar_data2
;   | x(-2)    | 
;   | x(-1)    |  



    ; loop starts here	
    MOV *SP(coef_cntr), BRC1                    
    MOV   dbl(*(ar_scratch+T0)),PAIR(HI(AC0)) 		

    ; Following 3 unrolls are to allow BRC1 setup
    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
    || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))

    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
    || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))

    MACR  *(ar_data1+T0),*CDP,AC0    			
    :: MACR  *(ar_data2+T0),*CDP,AC1    		
    MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
    || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))

                                                
    RPTBLOCAL   #(coef_updt2-1)                                 ; 2 stalls   ; segment update loop            
    MACR  *(ar_data1+T0),*CDP,AC0                               ; AC0=AC0+2^15+en*x[n-(N-(2*k))]
    :: MACR  *(ar_data2+T0),*CDP,AC1                            ; AC1=AC1+2^15+en*x[n-(N-(2*k+1))]
    MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0))                      ; h'(N-1-(2*k)) = HIGH(AC0)
    || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))               ; h'(N-1-(2*k+1)) = HIGH(AC1)
                                                                ; HI(AC0) = h[N-(2*k+2)]
                                                                ; HI(AC0) = h[N-(2*k+2+1)]
                                                
    ; 1 stall in rptblocal loop after 1st iteration                                            
coef_updt2:          
	MACR  *(ar_data1+T1),*CDP,AC0                               ; AC0=AC0+2^15+en*x[n-1]
	::MACR  *(ar_data2+T0),*CDP,AC1                             ; AC1=AC1+2^15+en*x[n-2]
	MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0))                      ; h'[0] = HIGH(AC0)
	|| NOP                                                      ; h'[1] = HIGH(AC1)

;   Update the delay line
;  -------------------------
;	
    MOV *ar_input+, *ar_data2+                                  ;copy input -> state(0)
    MOV *ar_input+, *(ar_data2+T0)                              ;copy input -> state(0)
	
;  Preserve e(n+1) for next stage
;  ------------------------------
;  
    MOV     HI(AC2), *CDP

ext_loop:

; Return overflow flag
; --------------------
    MOV #0, T0                                                  ;store zero for return value
    XCCPART Check1, overflow(AC0)
    || MOV #1, T0                                               ;return value 1 if overflow was encountered
Check1:
    XCCPART Check2, overflow(AC1)
    || MOV #1, T0                                               ;return value 1 if overflow was encountered
Check2

;NO presumed values in ST0 by C-environment

    BCLR FRCT                                                   ;clear FRCT bit in ST1 for C-environment
    BSET ARMS                                                   ;set ARMS bit for C-environment
    AND #0F800h, mmap(ST2_55)                                   ;all pointers put in linear mode

;No presumed values of ST3 were modified

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
    AADD	#(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
	
	
;
; Restore stack to previous value
; Reset status regs to restore normal C operating environment
; Return to calling function
;----------------------------------------------------------------
    POPBOTH XAR7                                                ;AR6 and AR7 are used in this function
    POPBOTH XAR6                                                ;AR6 and AR7 are used in this function
    POPBOTH XAR5                                                ;AR6 and AR7 are used in this function
    POP T3


    RET                                                         ;return to calling function

    .end

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
expn.asm/       1161799613  0     0     0       2720      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	expn
;  Description: exponent vector evaluation via polynomial approximation
;
;  Copyright Texas instruments Inc, 2000
;
;  History
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;   Zhengting He - 10/25/2006
;********************************************************************************

	.mmregs

; Table containing the coefficients for the polynomial

	.data    
expn_coeffs:			; hex values in q4.12

	.word	0x0039	;0.0139		(coef for x^5 = c5)
	.word	0x008f	;0.0348		(coef for x^4 = c4)
	.word	0x02ba	;0.1705		(coef for x^3 = c3)
	.word	0x07fc	;0.4990		(coef for x^2 = c2)
	.word	0x1000	;1.0001		(coef for x^1 = c1)
	.word	0x1000	;1.0000		(coef for x^0 = c0)


;****************************************************************
	.global	_expn
	.text

; Get arguments and set modes
; ---------------------------

_expn:
	BSET	FRCT			;set FRCT on
	BSET	SATD			
	BSET	SXMD	

	SUB	#1, T0			;b = n-1
	MOV	T0, mmap(BRC0)		;BRC = n-1

	RPTB	loop 			;repeat n times

; Start polynomial evaluation
; ---------------------------

; this should be moved out from the loop and rewound
; back to beginning by t1 register. It is not possible yet with beta tools.

	AMAR	*(#expn_coeffs), XAR4	;pointer to coeff table

	MOV	*AR0+, T0		;t = x(sign-extended)
	MOV	dbl(*AR4+), pair(HI(AC0))

	MOV	*AR4+ << #16, AC1
	||MACR	AC0, T0, AC1, AC0	;a = ah*t + b
					;  = c5*x + c4
					;bh = c3  point to c2

	MOV	*AR4+ << #16, AC1	
	||MACR	AC0, T0, AC1, AC0	;a = ah*t + b
					;  = (c5*x + c4)*x + c3
					;  =  c5*x^2 + c4*x + c3
					; bh = c2	point to c1

	MOV	*AR4+ << #16, AC1	
	||MACR	AC0, T0, AC1, AC0	;a = ah*t + b
					;   = (c5*x^2+c4*x+c3)*x + c2
					;   = c5*x^3+c4*x^2+c3*x + c2
					; bh = c1	point to c0

	MOV	*AR4+ << #16, AC1	
	||MACR	AC0, T0, AC1, AC0	;a = ah*t + b
					;   = (c5*x^3+c4*x^2+c3*x + c2)*x + c1
					;   = c5*x^4+c4*x^3+c3*x^2+c2*x +c1
					; bh = c0	point to c(-1)

	MAC	AC0, T0, AC1, AC0	; a = ah*t + b				
					;   = (c5*x^4+c4*x^3+c3*x^2 + c2*x+c1)*x + c0
					;   = c5*x^5+c4*x^4+c3*x^3+c2*x^2 +c1*x + c0


	MOV	HI(AC0), *AR1+		;store q4.12 output
loop:

; Return overflow flag
; --------------------
; bug: original code put return value in AC0
; fix: put to T0
	MOV	#0, T0
	XCC	check, overflow(AC0)
	MOV	#1, T0
check:

	BCLR	FRCT
	BCLR	SATD

	RET
;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor	
fir.asm/        1161799650  0     0     0       5951      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    fir
; Processor:   C55xx
; Description: Implements finite impulse response filter using
;              single-MAC approach.  C-callable.
;
; Useage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             DATA *dbuffer,
;                             ushort nx,
;                             ushort nh)
;
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, db_ptr          ;circular pointer

      .asg     BSA45, db_base       ;base addr for db_ptr
      .asg     XAR4, xdb_base       ;extended base addr for db_ptr
      .asg     BK47, db_sz          ;circ buffer size for db_ptr
      .asg     BK47_L, db_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers


      .global _fir

      .text
_fir:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx, TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer

	MOV	mmap(AR1), h_base	;base address of coefficients

	MOV	#0, h_ptr		;point to first coefficient

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointer

	MOV	XAR3, xdb_base		;db array address
	MOV	*AR3+, db_ptr		;index of oldest db entry

	MOV	mmap(AR3), db_base	;base address for db_ptr

	MOV	mmap(T1), db_sz		;db_sz = nh

	ADD	#1, mmap(db_sz)		;db_sz = nh+1

; Set circular/linear ARx behavior

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------

	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times
	SUB	#3, T1, T0		;T0 = nh-3
	MOV	T0, inner_cnt		;inner loop executes nh-2 times

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
; - computation not needed since T1 still contains nh

;
; Start of outer loop
;----------------------------------------------------------------

	||RPTBLOCAL	loop1-1		;start the outer loop

	MOV	*x_ptr+, *db_ptr	;get next input value

;ist iteration
	MPYM	*h_ptr+, *db_ptr+, AC0

;inner loop
	||RPT	inner_cnt
	MACM	*h_ptr+, *db_ptr+, AC0

;last iteration has different pointer adjustment and rounding
	MACMR	*h_ptr+, *(db_ptr-T1), AC0

;store result to memory
	MOV	HI(AC0), *r_ptr+	;store Q15 value to memory

loop1:					;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------

	MOV	db_ptr, *-AR3		;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

	||MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred

check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	||RET

;----------------------------------------------------------------
;End of file

fir2.asm/       1161799623  0     0     0       7324      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    fir2
; Processor:   C55xx
; Description: Implements finite impulse response filter using
;              dual-MAC approach.  C-callable.
;
; Useage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             DATA *dbuffer,
;                             ushort nx,
;                             ushort nh)
;
; Copyright Texas instruments Inc, 2000
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block
PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, db_ptr1         ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR3, db_ptr2         ;circular pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSA01, db_base1      ;base addr for db_ptr1
      .asg     XAR1, xdb_base1      ;extended base addr for db_ptr1
      .asg     BSA23, db_base2      ;base addr for db_ptr2
      .asg     BK03, db_sz          ;circ buffer size for db_ptr1 and db_ptr2
      .asg     BK03_L, db_sz_L      ;for memory mapped access
      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     XCDP, xh_base        ;extended base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000100001010b    ;circular/linear pointers


      .global _fir2

      .text
_fir2:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)     ;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)     ;set CPL, SXMD, FRCT
      
	AND	#0F9DFh, mmap(ST1_55)     ;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)     ;clear ARMS, RDM, CDPLC, AR[0-7]LC
      
	AND	#0FFDDh, mmap(ST3_55)     ;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
	MOV	XAR1, xh_base		;extended base address for h_ptr
	MOV	#0, h_ptr		;point to first coefficient

	MOV	mmap(AR1), h_base	;base address of coefficients

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointers, part 1 - must come before circ/linear ARx setup
	MOV	XAR3, XAR4		;save db array address
	MOV	XAR4, xdb_base1		;extended base address for db_ptr1
					;xdb_base2 already setup via argument pass
	MOV	*AR4, db_ptr1		;index of oldest db entry
	MOV	*AR4+, db_ptr2		;index of oldest db entry

	MOV	mmap(AR4), db_base1	;base address for db_ptr1

	MOV	mmap(AR4), db_base2	;base address for db_ptr2

; Set circular/linear ARx behavior
	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

	MOV	mmap(T1), db_sz		;db_sz = nh

	ADD	#1, mmap(db_sz)		;db_sz = nh+1

; db pointers, part 2 - must come after circ/linear ARx setup
	AMAR	*db_ptr2-		;index of 2nd oldest db entry

;
; Setup loop counts
;----------------------------------------------------------------
	||SFTS	T0, #-1			;T0 = nx/2

	SUB	#1, T0			;T0 = (nx/2 - 1)
	MOV	T0, outer_cnt		;outer loop executes nx/2 times
	SUB	#3, T1, T0		;T0 = nh-3
	MOV	T0, inner_cnt		;inner loop executes nh-2 times

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
	ADD	#1, T1			;T1 = nh+1, adjustment for db_ptr1, db_ptr2

	MOV	*x_ptr+, *db_ptr1	;get 1st new input value
	MOV	*x_ptr+, *db_ptr2	;get 2nd new input value (newest)

;
; Start of outer loop
;----------------------------------------------------------------
	||RPTBLOCAL	loop1-1		;start the outer loop



;1st iteration
	MPY	*db_ptr1+, *h_ptr+, AC0		;part 1 of dual-MPY
	::MPY	*db_ptr2+, *h_ptr+, AC1		;part 2 of dual-MPY

;inner loop
	||RPT	inner_cnt
	MAC	*db_ptr1+, *h_ptr+, AC0		;part 1 of dual-MAC
	::MAC	*db_ptr2+, *h_ptr+, AC1		;part 2 of dual-MAC

;last iteration has different pointer adjustment and rounding
	MACR	*(db_ptr1-T1), *h_ptr+, AC0	;part 1 of dual-MAC
	::MACR	*(db_ptr2-T1), *h_ptr+, AC1	;part 2 of dual-MAC
	
	MOV	*x_ptr+, *db_ptr1	;get 1st new input value
	MOV	*x_ptr+, *db_ptr2	;get 2nd new input value (newest)

;store results to memory	
	MOV pair(HI(AC0)), dbl(*r_ptr+)    ;store 1st Q15 result to memory
	                                   ;store 2nd Q15 result to memory

loop1:					;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
	MOV	db_ptr1, *-AR4		;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred
check1:

	XCCPART	check2, overflow(AC1)	;clears ACOV1
	||MOV	#1, oflag		;overflow occurred
check2:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS 

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	||RET			;return to calling function

;----------------------------------------------------------------
;End of file

firlat.asm/     1161799654  0     0     0       7367      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    firlat
; Processor:   C55xx
; Description: Computes a real lattice FIR filter implementation 
;		using coefficient stored in vector h. The real data 
;		input is stored in vector x. The filter output result 
;		is stored in vector r .  This function retains the 
;		address of the delay filter memory d containing the 
;		previous delayed values to allow consecutive processing 
;		of blocks. This function can be used for both 
;		block-by-block and  sample-by-sample filtering (nx=1).   
;		C-callable.
;
; Useage: short oflag = firlat (DATA *x, 
;				 DATA *h, 
;				 DATA *r,
;				 DATA *pbuffer, 
;				 int nx, 
;				 int nh)
;
;Algorithm:
; 
;	e(0)[0]  = e'(0)[0]=x[0]
; 	e(i)[n]  = e(i-1)[n] + k(i)*e'(i-1)[n-1]   i=1,2,.. nh
;       e'(i)[n] = k(i)*e(i-1)[n] + e'(i-1)[n-1]   i=1,2,.. nh
;	e(nh)[n] = r[n]
;
;
;pbuffer: procession buffer of nh length
;      e'0[n-1]
;      e'1[n-1]
;      e'2[n-1]
;      e'3[n-1]
;	.
;	.
;      e'nh-2[n-1]
;      e'nh-1[n-1]
;
;x: input of length nx
;	x[0]
;	x[1]
;	.
;	.
;	.
;	x[nx-2]
;	x[nx-1]
;
;h: input of length nh
;	h[0]
;	h[1]
;	.
;	.
;	.
;	h[nx-2]
;	h[nx-1]
;
;y: output of length nx
;	y[0]
;	y[1]
;	.
;	.
;	.
;	y[nx-2]
;	y[nx-1]                                          
;
;
; Copyright Texas instruments Inc, 2000
;
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
*********************************************************************/


      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, p_ptr           ;circular pointer
      .asg     AR3, temp	        ; temp buffer
     
      .asg     BSA45, p_base       ;base addr for p_ptr
      .asg     XAR4, xp_base      ;extended base addr for p_ptr
      .asg     BK47, p_sz          ;circ buffer size for p_ptr
      .asg     BK47_L, p_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     BRC1, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag           ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers, AR4, AR1 circular

;ST2mask  .set  0000001000010000b    ;circular/linear pointers, AR4, cdp circular


      .global _firlat

      .text
_firlat:

     PSH	mmap(ST3_55)

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx, TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer

	MOV	mmap(AR1), h_base	;base address of coefficients

	MOV	#0, h_ptr		;point to first coefficient

	MOV	mmap(T1), h_sz		;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointer

	MOV XAR3, XAR4

	MOV	mmap(AR3), p_base	;base address for p_ptr

	MOV	#0, p_ptr		;point to first coeffiecient

	MOV	mmap(T1), p_sz		;p_sz = nh

; Set circular/linear ARx behavior

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------

	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times
	SUB	#2, T1, T0		;T0 = nh-3
	MOV	T0, inner_cnt		;inner loop executes nh-2 times

;
; Start of outer loop
;----------------------------------------------------------------

	RPTBLOCAL	loop1-1		;start the outer loop

;1st iteration

	MOV	*x_ptr+ << #16, AC0	;setup for e(0): input value
	MOV	HI(AC0), temp

;inner loop
	||RPTBLOCAL	loop2-1
	MOV	*p_ptr << #16, AC1	;setup for e'(0): input value
	MACM	*h_ptr, AC0, AC1	;calculate e'(0)
	MACM	*p_ptr, *h_ptr+, AC0	;calculate e(0)

	MOV	temp, *p_ptr+		;store previously cacluclated e'(i)
	||MOV	HI(AC1), temp

loop2:

;last iteration has rounding

	MACMR	*p_ptr, *h_ptr+, AC0

	MOV	temp, *p_ptr+		;store previously cacluclated e'(i)

; Store result to memory
	||MOV	HI(AC0), *r_ptr+	;store Q15 value to memory

loop1:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

    .if  $isdefed("SI_BUGS")
	MOV	#0, oflag		;clear oflag
	XCC	check1, overflow(AC0)	;clears ACOV0
	.else
	MOV	#0, oflag		;clear oflag
	||XCCPART	check1, overflow(AC0)	;clears ACOV0
	.endif
	MOV	#1, oflag		;overflow occurred

check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BCLR	FRCT			;clear FRCT

	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

     POP	mmap(ST3_55)

;
; Return to calling function
;----------------------------------------------------------------
	RET

;----------------------------------------------------------------
;End of file

firs.asm/       1161799660  0     0     0       6003      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    firs
; Processor:   C55xx
; Description: Implements symmetric finite impulse response
;              filter using FIRS approach.  C-callable.
;
; Useage: ushort oflag = firs(DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             DATA *dbuffer,
;                             ushort nx,
;                             ushort nh2)
;
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg    AR0, x_ptr            ;linear pointer
      .asg    AR1, db_ptr1          ;circular pointer
      .asg    AR2, r_ptr            ;linear pointer
      .asg    AR3, db_ptr2          ;circular pointer
      .asg    CDP, h_ptr            ;circular pointer

      .asg    BSA01, db_base1       ;base addr for db_ptr1
      .asg    XAR1, xdb_base1       ;extended base addr for db_ptr1
      .asg    BSA23, db_base2       ;base addr for db_ptr2
      .asg    BK03, db_sz           ;circ buffer size for db_ptr1 and db_ptr2
      .asg    BSAC, h_base          ;base addr for h_ptr
      .asg    XCDP, xh_base         ;extended base addr for h_ptr
      .asg    BKC, h_sz             ;circ buffer size for h_sz

      .asg    CSR, inner_cnt        ;inner loop count
      .asg    BRC0, outer_cnt       ;outer loop count

      .asg    T0, oflag             ;returned value

ST2mask  .set  0000000100001010b    ;circular/linear pointers


      .global _firs

      .text
_firs:

     PSH	mmap(ST3_55)
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)

	OR	#04140h, mmap(ST1_55)
      
	AND	#0F9DFh, mmap(ST1_55)

	AND	#07A00h, mmap(ST2_55)
      
	AND	#0FFDDh, mmap(ST3_55)

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
	MOV	XAR1, xh_base
	MOV	#0, h_ptr

	MOV	mmap(AR1), h_base

	MOV	mmap(T1), h_sz

; r pointer - passed in its destination register, need do nothing

; db pointers, part 1 - must come before circ/linear ARx setup
	MOV	XAR3, XAR4
	MOV	XAR4, xdb_base1

	MOV	*AR4, db_ptr1

	MOV	*AR4+, db_ptr2
	||MOV	#1, AC0

	MOV	mmap(AR4), db_base1
	
	MOV	mmap(AR4), db_base2

; Set circular/linear ARx behavior
	OR	#ST2mask, mmap(ST2_55)

	ADD	mmap(T1) << #1, AC0

	MOV	mmap(AC0L), db_sz

; db pointers, part 2 - must come after circ/linear ARx setup
	AMAR	*db_ptr2-

;
; Setup loop counts
;----------------------------------------------------------------
	||SUB	#1, T0

	MOV	T0, outer_cnt
	||AMAR	*db_ptr2-

	SUB	#3, T1, T0
	MOV	T0, inner_cnt

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
	MOV	T1, T0
	SUB	#2, T1
      
    MOV	*x_ptr+, *db_ptr1  
;
; Start of outer loop
;----------------------------------------------------------------
	||RPTBLOCAL	loop1-1

;clear AC0 and pre-load AC1 with the sum of the 1st and last inputs
	
	ADD	*db_ptr1+, *db_ptr2-, AC1

;inner loop
	||RPT	inner_cnt
	FIRSADD	*db_ptr1+, *db_ptr2-, *h_ptr+, AC1, AC0	

;2nd to last iteration has different pointer adjustment
	FIRSADD	*(db_ptr1-T0), *(db_ptr2+T1), *h_ptr+, AC1, AC0

;last iteration is a MAC with rounding
	MACMR	*h_ptr+, AC1, AC0

    MOV	*x_ptr+, *db_ptr1
    
;store result to memory
	MOV	HI(AC0), *r_ptr+	
    
    ||MOV	#0, AC0
    
loop1:

;
; Update the db entry point
;----------------------------------------------------------------
	MOV	db_ptr1, *-AR4

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred

check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT

	AND	#0FE00h, mmap(ST2_55)

	BSET	ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
     POP	mmap(ST3_55)
;
; Return to calling function
;----------------------------------------------------------------
	RET

;----------------------------------------------------------------
;End of file

fltoq15.asm/    1161799666  0     0     0       3999      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	fltoq15
; Processor:   C55xx
; Description: convert IEEE floating point to Q15"
; Copyright Texas instruments Inc, 2000
; Note:
; 1. optimize the code by using AR0, AR1 directly
; 
; T2 registered is pushed and poped.
;  Zhengting He 10/25/2006
;****************************************************************

        .ARMS_off                     ;enable assembler for ARMS=0
        .CPL_on                       ;enable assembler for CPL=1
	.mmregs


;----------------------------------------------------------------
; Function definition:
;----------------------------------------------------------------

	.global	_fltoq15

_fltoq15:


;----------------------------------------------------------------
; Prologue: establish local frame, reset sign extension mode
;----------------------------------------------------------------
    PSH     T2
;   ZHENGTING ADDED TO PUSH T2 (SAVE)

	AADD	#-13, SP
	BCLR	SXMD

;----------------------------------------------------------------
; Process function arguments
;----------------------------------------------------------------

;	MOV	AR0, AR2
;	MOV	AR1, AR3
	||MOV	T0, AC1
	SUB	#1, AC1
	MOV	AC1, mmap(BRC0)

;----------------------------------------------------------------
; Store function constants
;----------------------------------------------------------------

	MOV	#127, *SP(#5)
	MOV	#15, *SP(#6)
	MOV	#32768 << #16, AC1
	MOV	HI(AC1 << #0), *SP(#7)
	NOT	AC1
	MOV	AC1, dbl(*SP(#0))
	MOV	#32768, *SP(#7)
	MOV	#1, *SP(#8)
	MOV	#32767, *SP(#9)
	MOV40	dbl(*AR0+), AC0
	
;----------------------------------------------------------------
; Convert each element of vector A, to Q15 format
; Pre-Load first vector element
;----------------------------------------------------------------

	||RPTB	end_loop-1

loop_start:

	AND	#32768 << #16, AC0, AC1
	MOV	HI(AC1 << #0), *SP(#11)
	MOV40	dbl(*SP(#0)), AC1
	AND	AC1, AC0
	BCC	zero, AC0 == 0
	AND	#32640 << #16, AC0, AC1
	MOV	*(#(12)) << #-7, AC1
	SUB	*SP(#5), AC1

;----------------------------------------------------------------
; If unbiased exponent is >= 0, then value is too large to
; represent in Q15 format
;----------------------------------------------------------------

	BCC	too_large, AC1 >= #0

;----------------------------------------------------------------
; If exponent (abs) exp > abs(min_exp) then value is too small
; to represent in Q15 format. (min_exp = -15, since 2^-15 is
; least significant bit of Q15 number
;----------------------------------------------------------------

	MOV	AC1 << #0, *SP(#3)
	ABS	AC1
	SUB	*SP(#6), AC1
	
	BCC	too_small, AC1 > #0

;----------------------------------------------------------------
; Shift floating point mantissa to keep only the most significant
; 15 bits. The implied 1 of the IEEE floating point format is ORed
; in as most significant bit.
;----------------------------------------------------------------

	MOV	*SP(#11), AC1
	SFTSC	AC0, #-7
	MOV	*(#(8)) << #-1, AC0
	AND	#65504, mmap(ST1)
	MOV	*SP(#3), T2
	OR	*SP(#7), AC0
	SFTS	AC0, T2
	XCC	check1, AC1 != #0
	NEG	AC0
check1:

P4_9:
	B	store_result

too_small:
	MOV	#2, *SP(#10)

zero:
	MOV	#0, AC0
	B	store_result

too_large:
	MOV	*SP(#11), AC1
	MOV	#1, *SP(#4)
	MOV	*SP(#9), AC0
	XCC	check2, AC1 > #0
	ADD	*SP(#8), AC0
check2:

store_result:
	MOV	AC0 << #0, *AR1+
	MOV40	dbl(*AR0+), AC0

end_loop:

;----------------------------------------------------------------
; Return to calling program. Set error conditions on return"
;----------------------------------------------------------------"

Epilogue:

	MOV	*SP(#4), T0
	OR	*SP(#10), T0

	AADD	#13, SP

	POP     T2
; ZHENGTING ADDED TO RESTORE T2

	BSET	SXMD
	RET
	



hilb16.asm/     1161799670  0     0     0       6921      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    hilb16
; Processor:   C55xx
; Description: Hilbert tansformer using FIR filter - single MAC approach
;
;
; Useage: ushort oflag = hilb16 (DATA *x,
;                             DATA *h,
;                             DATA *r,
;                             DATA *dbuffer,
;                             ushort nx,
;                             ushort nh)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, db_ptr          ;circular pointer

      .asg     BSA45, db_base       ;base addr for db_ptr
      .asg     XAR4, xdb_base       ;extended base addr for db_ptr
      .asg     BK47, db_sz          ;circ buffer size for db_ptr
      .asg     BK47_L, db_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers


      .global _hilb16

      .text
_hilb16:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

      AND #01FFh,mmap(ST0_55)       ;clear all ACOVx,TC1, TC2, C
      OR #4140h,mmap(ST1_55)        ;set CPL, SXMD, FRCT
      AND #0F9DFh,mmap(ST1_55)       ;clear M40, SATD, 54CM 
      AND #07A00h,mmap(ST2_55)       ;clear ARMS, RDM, CDPLC, AR[0-7]LC
      AND #0FFDDh,mmap(ST3_55)       ;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
      MOV mmap(AR1),h_base          ;base address of coefficients
      MOV #0,h_ptr                  ;point to first coefficient
      MOV mmap(T1),h_sz             ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointer
      MOV XAR3,xdb_base             ;db array address
      MOV *AR3+,db_ptr              ;index of oldest db entry

      MOV mmap(AR3),db_base         ;base address for db_ptr

      MOV mmap(T1),db_sz            ;db_sz = nh

      ADD #1,mmap(db_sz)          ;db_sz = nh+1

; Set circular/linear ARx behavior
      OR #ST2mask,mmap(ST2_55)      ;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
      SUB #1,T0                     ;T0 = nx-1
      MOV T0,outer_cnt              ;outer loop executes nx times
      SUB #1,T1                     ;adjust T1=nh-1 and store it to T0
      SUB #5,T1,T0                  ;T0 = nh-6
      SFTS T0,#-1                   ;T0 = (nh-6)/2
      MOV T0,inner_cnt              ;inner loop executes (nh/2)-2 times

;
; Setup step to 2 because of decimation
;
      MOV #2,T0                     ;circular buffer step = 2 
;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
; - computation not needed since T1 still contains nh

;
; Start of outer loop
;----------------------------------------------------------------
      ||RPTBLOCAL outloop-1         ;start the outer loop
      MOV *x_ptr+,*db_ptr           ;get next input value
    
;1st iteration
      MPYM *(db_ptr+T0),*(h_ptr+T0),AC0      

;inner loop
      ||RPT inner_cnt
      MACM *(db_ptr+T0),*(h_ptr+T0),AC0,AC0

;last iteration has different pointer adjustment and rounding
      MACMR *(db_ptr-T1),*(h_ptr+T0),AC0,AC0

;store result to memory
      MOV HI(AC0),*r_ptr+           ;store Q15 value to memory
outloop:
                                    ;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
      MOV db_ptr,*-AR3              ;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      ||MOV #0,oflag                            ;clear oflag

      XCCPART overf_label, overflow(AC0)        ;clears ACOV0
      ||MOV #1,oflag                            ;overflow occurred
overf_label:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;      BCLR #ST1_FRCT,ST1_55         ;clear FRCT

;      AND #0FE00h,mmap(ST2_55)      ;clear CDPLC and AR[7-0]LC

;      BSET #ST2_ARMS,ST2_55        ;set ARMS            

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
      RET                         ;return to calling function

;----------------------------------------------------------------
;End of file

iircas32.asm/   1161799683  0     0     0       10047     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	 iircas32
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;                using 32 bit coefficients and delay buffer
;
; Copyright Texas instruments Inc, 2000
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.-----x-- + --> y(n)
;           /|      |    b0   |\
;          | |    [z-1]       | |
;          | |      |         | |
;          | |      v         | | 
;          | |--x-d(n-1)--x---| |         
;          |  -a1   |    b1     | 
;          |        |           |
;          |      [z-1]         |
;          |        |           |
;          |        v           |
;          |---x--d(n-2)--x-----|
;            -a2         b2 
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = b0*d(n) + b1*d(n-1) + b2*d(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag = iircas4(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.					16 bit
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[2(5*nbiq)]: PASSED in XAR1.				32 bit
;        Pointer to filter coefficient vector with the following format:
;        H = a11 a21 b21 b01 b11 ....a1i a2i b2i b0i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.					16 bit
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[2*(2*nbiq + 2)]: PASSED in XAR3.	32 bit
;        Pointer to delay buffer of length 2*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;        The first element in this array is special in that it 
;        contains the array index of the first buffer element in the 
;        delay buffer.  This is needed for multiple-buffering schemes, 
;        and should be initialized to zero (like all the other array 
;        entries) for the first block only.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[2*(2*nbiq+2)]"        "h[2*(5*nbiq)]"
;               index             AR1(h)->b21H
;               dummy                     b21L 
;       R3(dn)-->d21L                     b11H
;               d21H                      b11L
;               d11L                      b01H
;               d11H                      b01L
;               d22L                      a21H
;               d22H                      a21L
;               d12L                      a11H
;               d12H                      a11L
;                :                         :
;               d1nH                       :
;               extra 
;               dummy
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #


	.arms_off
	.cpl_off
	.mmregs
;******************************************
;*       Assigns
;******************************************
	.def	_iir32

;******************************************
;*       Constant Defines
;******************************************
SCALE	.set	0

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iir32
;Context save
	psh mmap(ST0_55)
	psh mmap(ST1_55)
	psh mmap(ST2_55)
	psh mmap(ST3_55)

	bclr CPL, ST1_55				;DP relative addressing	
;	psh mmap(@DP)
;	mov #0, DP						;set DP=0 for mmreg accesses
;   ADDED REGARDING THE BUG REPORT, ZHENGTING
	PSH mmap(DP)
	PSH mmap(DPH)
	AMOV #0, XDP

	.dp 0    

	psh @T2
	psh @T3
	pshboth XAR5
	pshboth XAR7

;Initialization
	bset	SXMD, ST1_55			;sign extention enable
	bclr	SATD, ST1_55			;D-unit saturate disable
	bset	FRCT, ST1_55			;fractional mode enable
	bclr	SATA, ST3_55			;A-unit saturate disable
    
;Save pointer to index at dbuffer[0]    
	mov 	XAR3, XAR5

; Setup loop counters
	sub		#1, T1, T3				;compute nx-1
	mov		T3, BRC0				;init outer loop counter (nx-1)
	
	sub		#1, T0, T3				;init inner loop counter (#bi-quads-1)
	mov		T3, BRC1

; Setup circular addressing
	mov 	#4, T3					;size of single biquad delay buffer
    mov		@T3, BK03				;init AR0-3 circular buf size (2 delay elements)
	bset	AR3LC, ST2_55			;init AR3 = circular (dbuffer)
; 	add		#2, AR3					;adjust AR3 to buffer start
;	mov		@AR3, BSA23				;init AR2-3 circular start addr: dbuffer[2]
	mov		*AR5, AR3				;init AR3 offset to buffer start
	add		#2, AR5					;adjust AR5 to buffer start address (d20L)

	mov		XAR1, XAR7				;save coeff buffer start address to reinit pntr

; Setup offset registers
	mov		#3, T0					;b0 bypass index
	mov		#5, T1					;b0 pick up index
	mov		#SCALE, T2				;scale factor          
	
; Kernel
;  XAR0: x[] input (16 bit)
;  XAR1: h[] coefficients (32 bit: H/L)
;  XAR2: r[] result (16 bit)
;  XAR3: dbuffer[] (32 bit: H/L)
;  XAR5: dbuffer d2jL pointer 
;  XAR7: reinit XAR1
;
;                                                               
; BIQUAD's are calculated as follows                            
;    tmp = b2*d[n-2] + b1*d[n-1]                                
;    d[n] = x[n] or y[n]   (depending on BIQUAD)                
;    d[n] = d[n] - a2*d[n-2] - a1*d[n-1] 
;    store new d[n]                        
;    y[n] = b0*d[n] + tmp
;    store y[n]
;
; Note: u---L * u---L not needed for 32 bit result. 
;        Saves one MAC per tap.
;----------------------------------------------------------------                                                               
	rptb outer					; Outer Loop: Process a new input
;  for(i=0; i<nx; i++)
	 mov		@AR5, T3		; Init BSA23 for 1st biquad (d20L)
	 mov		@T3, BSA23
; HI(AC0) = x(n)
	 mov		*AR0+ << #16, AC0	
	 ||  rptb inner				; Inner Loop: Process a bi-quad
;      for(j=0; j<nbiq; j++)

; AC2 = b2 * d[n-2]
		mpym	*AR1, uns(*AR3+), AC3		; b2jH * ud2jL
		mpym	*AR1+, *AR3, AC2            ; b2jH * d2jH
		macm	uns(*AR1+), *AR3+, AC3      ; ub2jL * d2jH
		add		AC3 << #-16, AC2
		
; AC2 += b1 * d[n-1]
		mpym	*AR1, uns(*AR3+), AC3		; b1jH * ud1jL
		macm	*AR1+, *AR3, AC2			; b1jH * d1jH
		macm	uns(*(AR1+T0)), *AR3+, AC3	; ub1jL * d1jH
		add		AC3 << #-16, AC2
;   AR3 circular addressing -> last d2jL
;   AR1+index -> a2jH 
;    (skip b0j temporarily)

; AC0 -= a2 * d[n-2]
		mpym	*AR1, uns(*AR3+), AC1		; a2jH * ud2jL
		masm	*AR1+, *AR3, AC0			; a2jH * d2jH
		macm	uns(*AR1+), *AR3+, AC1		; ua2jL * d2jH
		sub		AC1 << #-16, AC0

; d[n] = AC0 -= a1 * d[n-1]
		mpym	*AR1, uns(*AR3+), AC1		; a1jH * ud1jL
		masm	*AR1+, *AR3, AC0			; a1jH * d1jH
		macm	uns(*(AR1-T1)), *AR3+, AC1	; ua1jL * d1jH
		sub		AC1 << #-16, AC0
;   AR3 circular addressing -> last d2jL
;   AR1-index -> b0jH

;   Replace d[n-2] with new d[n]
		mov		AC0 << T2, *AR3+			; d0jL
		mov		HI(AC0 << T2), *AR3-		; d0jH

; AC0 = b0 * d[n]
		mpym	*AR1, uns(*AR3+), AC1		; b0jH * ud0jL
		mpym	*AR1+, *AR3, AC0			; b0jH * d0jH
		macm	uns(*AR1+), *AR3-, AC1		; ub0jL * d0jH
		add		AC1 << #-16, AC0
;   AR3 adjusted -> last d2jH

; y[n] = AC0 += AC2
;  or input to next biquad
		add		AC2, AC0

;   update AR1 -> b2jH
		add		#4, AR1
                                    
;   update BSA23 -> next biquad (d2jL)
		add		#4, T3
inner:
		mov		@T3, BSA23
;  end of inner loop

	 aadd		#2, AR3				; Adjust dbuffer offset for next sample
	 mov		XAR7, XAR1			; reinitialize coeff pointer
outer:
	 mov	rnd(HI(AC0)), *AR2+		; store result to output buffer
;  end of outer loop

;Signal overflow check
	mov		#0, T0
	xcc		next, overflow(AC0)
	  mov	#1, T0
next:	

    sub		#2, AR5
;Save last index value
	mov		AR3, *AR5		; save index to dbuffer[0]

;Context restore
	popboth	XAR7
	popboth	XAR5
	pop		@T3
	pop		@T2
;	pop		mmap(@DP)
;   ZHENGTING ADDED
	POP mmap(DPH)
	POP mmap(DP)
	pop		mmap(ST3_55)
	pop		mmap(ST2_55)
	pop		mmap(ST1_55)
	pop		mmap(ST0_55)
	 
	ret


 
iircas4.asm/    1161799218  0     0     0       10590     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	 iircas4
;  Description:  cascaded IIR direct form II using 4-coefs per biquad
;
;  Copyright Texas instruments Inc, 1999
;-----------------------------------------------------------------------------
; Revision History:
; 1.00  T. Horner, 2/15/00. Original version. Started from code by Rosemarie 
;   Piedra, Greg Peake, and Karim Djafarian.
; 1.01  Li Yuan, 6/13/00. Fixed pop up order error.
; 2.00  C. Iovescu, 5/20/02 Modified implementation to use Dual Mac
; 2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;*****************************************************************************
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.----- + --> y(n)
;           /|      |      |\
;          | |    [z-1]    | |
;          |        |        |
;          | |      v      | | 
;          | |--x-d(n-1)-x-| |         
;          |  -a1   |   b1   | 
;          |        |        |
;          |      [z-1]      |
;          |        |        |
;          |        v        |
;          |---x--d(n-2)--x--|
;            -a2         b2
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = d(n) + b1*d(n-1) + b2*d(n-2)
;
;
; Function Call
; -------------
;
;  short oflag = iircas4(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[4*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = a11 a21 b21 b11 ....a1i a2i b2i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[2*nbiq + 2]: PASSED in XAR3.
;        Pointer to delay buffer of length 2*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;        The first element in this array is special in that it 
;        contains the array index of the first buffer element in the 
;        delay buffer.  This is needed for multiple-buffering schemes, 
;        and should be initialized to zero (like all the other array 
;        entries) for the first  block only.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     newest
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  oldest
;
;
;      "dbuffer[2*nbiq+1]"            "h[4*nbiq]"
;                index            AR1(h)->a11
;      AR3(dn)-->d11                      b11 
;                d21                      a21
;                 :                       b21
;                dn1                      
; 				 dn2                      a12
;                                         b12
;                                         a22
;                                         b22
;                                          :
;                                         a1i
;                                         b1i
;                                         a2i
;                                         b2i
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #

	.arms_off
	.cpl_off
	.mmregs    
	.noremark  5579
;******************************************
;*       Assigns
;******************************************
	.def	_iircas4

;******************************************
;*       Constant Defines
;******************************************
SCALE	.set	0

;******************************************
;*       Variable Declarations
;******************************************

;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
	.asg     CDP, db_ptr        ;circular pointer
 	.asg     AR0, in_ptr        ;linear pointer
 	.asg     AR1, h_ptr         ;circular pointer
 	.asg     AR2, out_ptr       ;linear pointer
      .asg     AR3, index         ;
	.asg     AR4, tap_updt      ;circular pointer

 

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas4
;Context save

     PSH mmap(@ST1_L)
     PSH mmap(@ST2_L)
     PSH mmap(@ST3_L)

;
; Configure the status registers as needed.
;----------------------------------------------------------------
     BCLR #CPL, ST1_55	       ;DP relative addressing

	;PSH mmap(@DP_L)
    ;MOV  #0, DP			;set DP=0 for mmreg accesses
;   ADDED REGARDING THE BUG REPORT, ZHENGTING
	PSH mmap(DP)
	PSH mmap(DPH)
	AMOV #0, XDP

	.dp 0     

      PSH T2
      PSH T3
	PSHBOTH XAR5

;Initialization   
    BSET #CDPLC, ST2_55                ;init CDP = circular (dbuffer)    
    BSET #AR1LC, ST2_55                ;init AR3 = circular (dbuffer)
    BSET #AR4LC, ST2_55                ;init AR4 = circular (coeff)
    BSET #SXMD, ST1_55                 ;sign extention enable
    BCLR #SATD, ST1_55                 ;D-unit saturate disable
    BSET #FRCT, ST1_55                 ;fractional mode enable
    BCLR #SATA, ST3_55                 ;A-unit saturate disable
    BCLR #C54CM, ST1_55
    BCLR #ARMS, ST2_55
    
;Save pointer to index at dbuffer[0]    
    MOV XAR3, XAR5 

;Restore index of the current dbuffer location
    MOV *ar5, index 

; Setup circular addressing for db_ptr (CDP) and tap_updt (AR4)
    MOV T0, T3                              ;compute 2*nbiq
    SFTL T3, #1
    ADD #1, T3 
    MOV @T3_L, BKC                      ;init CDP circular buf size (2*nbiq+1)
    MOV @T3_L,BK47				  ;init AR4 circular buf size (2*nbiq+1)
    ADD #1, AR5 
    MOV @AR5_L,BSAC                    ;init CDP circular start addr: dbuffer
    MOV @AR5_L,BSA45
     MOV XAR3, XCDP              ; MOV index, db_ptr
    
    AMAR *db_ptr+
    
     MOV XAR3, XAR4               ;MOV index, tap_updt

 ; Setup circular addressing for h_ptr (AR1)
    MOV T0,T3                            ;compute 4*nbiq
    SFTL T3, #1   
    SFTL T3, #1
    MOV @T3_L,BK03                      ;init AR0-3 circular buf size (4*nbiq)
    MOV @AR1_L, BSA01                     ;init AR0-1 circular start addr: coeff
    MOV #0,AR1
 
 ; Store loop counters 
            
    SUB #1, T1,T3                        ;compute nx-1
    MOV T3,BRC0                           ;init outer loop counter (nx-1)                
	
    MOV T0, T3                            ;init inner loop counter (#bi-quads/2-1)
    SFTL T3, #-1 
    SUB #1,T3
    MOV T3,BRC1  

; Define Address indexes 
    MOV #1,T0
    MOV #2,T1 

; Define scale factor
	MOV #SCALE, T2                         ;scale factor
	||SUB AC2, AC2 
; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR3: dbuffer[]
;  XAR7: reinit XAR1

    RPTBLOCAL outer_loop                       ; Outer Loop: Process a new input

      MOV *in_ptr+ << #16, AC0                 ; HI(AC2) = x(n)
   || RPTBLOCAL inner_loop                       ; Inner Loop: Process a bi-quad
       
   MOV #0, AC3
   ||  
   MAS *(h_ptr+T1), *db_ptr+, AC0		; AC0 = x(n) - a1*d(n-1)
   :: MAC *h_ptr(T0), *db_ptr+, AC2  	; AC2 = b1*d(n-1)
 
 
   MAS *(h_ptr+T1), *db_ptr+, AC0         ; AC0=d(n)=x(n)-a1*d(n-1)-a2*d(n-2)
    :: MAC *h_ptr(T0), *db_ptr+, AC2      ; AC2=b1*d(n-1)+b2*d(n-2)


  MOV HI(AC0<<T2),*(tap_updt+T1)                 ; T1 = #2 , X2 
  || ADD AC2,AC0                                 ; AC0 =  d(n) + b1*d(n-1) + b2*d(n-2)
         
; Beginning of second Biquad
                    
   MOV #0, AC2
   ||  
   MAS *(h_ptr+T1), *db_ptr+, AC0        ; AC0 = x(n) - a1*d(n-1)
   :: MAC *h_ptr(T0), *db_ptr+, AC3      ; AC3 = b1*d(n-1)
 
 
    MAS *(h_ptr+T1), *db_ptr+, AC0       ; AC0=d(n)=x(n)-a1*d(n-1)-a2*d(n-2)
    :: MAC *h_ptr(T0), *db_ptr+, AC3     ; AC2=b1*d(n-1)+b2*d(n-2)
      
inner_loop:  MOV HI(AC0<<T2),*(tap_updt+T1)       ; T1 = #2 , T2 = #SCALE 
             ||ADD AC3,AC0
             
outer_loop:      
      MOV rnd(HI(AC0)), *out_ptr+                 ; store result to output buf
       
    
  

;Signal overflow
	MOV #0, T0
	XCC label1, overflow(AC0) 
label1:
	MOV #1,T0 

;Save last index value
	MOV AR3, *AR5                              ; save index to dbuffer[0]



;Context restore
	POPBOTH XAR5
      POP T3
      POP T2
;      POP mmap(@DP_L)
;   ZHENGTING ADDED
	POP mmap(DPH)
	POP mmap(DP)

	POP mmap(@ST3_L)
      POP mmap(@ST2_L)
      POP mmap(@ST1_L)
	
	 
	RET


 iircas5.asm/    1161799678  0     0     0       7282      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	 iircas5
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;
; Copyright Texas instruments Inc, 2000
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.-----x-- + --> y(n)
;           /|      |    b0   |\
;          | |    [z-1]       | |
;          | |      |         | |
;          | |      v         | | 
;          | |--x-d(n-1)--x---| |         
;          |  -a1   |    b1     | 
;          |        |           |
;          |      [z-1]         |
;          |        |           |
;          |        v           |
;          |---x--d(n-2)--x-----|
;            -a2         b2 
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = b0*d(n) + b1*d(n-1) + b2*d(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag = iircas4(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[5*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = a11 a21 b21 b01 b11 ....a1i a2i b2i b0i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[2*nbiq]: PASSED in XAR3.
;        Pointer to delay buffer of length 2*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[2*nbiq]"            "h[5*nbiq]"
;                                 AR1(h)->a11
;      AR3(dn)-->d11                      a21 
;                d12                      b21
;                 :                       b01
;                d1n                      b11
;                d21                      a12
;                d22                      a22
;                 :                       b22
;                d2n                      b02
;                                         b12
;                                          :
;                                         a1i
;                                         a2i
;                                         b2i
;                                         b0i
;                                         b1i
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #


	.arms_off
	.cpl_off
	.mmregs
;******************************************
;*       Assigns
;******************************************
	.def	_iircas5

;******************************************
;*       Constant Defines
;******************************************
SCALE	.set	0

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas5
;Context save
	PSH	mmap(ST0_55)

	PSH	mmap(ST1_55)

	PSH	mmap(ST2_55)

	PSH	mmap(ST3_55)


	BCLR	CPL		;DP relative addressing

	;PSH	mmap(DP)
	;MOV	#0, DP		;set DP=0 for mmreg accesses
;   ADDED REGARDING THE BUG REPORT, ZHENGTING
	PSH mmap(DP)
	PSH mmap(DPH)
	AMOV #0, XDP

	.dp 0    

	PSH	T2
	PSH	T3
	PSHBOTH	XAR5
	PSHBOTH	XAR7

;Initialization
	BSET	SXMD		;sign extention enable
	BCLR	SATD		;D-unit saturate disable
	BSET	FRCT		;fractional mode enable
	BCLR	SATA		;A-unit saturate disable
    

; Setup circular addressing
	MOV	T0, T3		;compute 2*nbiq
	SFTS	T3, #1
	MOV	@T3, BK03	;init AR0-3 circular buf size (2*nbiq)

	BSET	AR3LC		;init AR3 = circular (dbuffer)
	MOV	@AR3, BSA23	;init AR2-3 circular start addr: dbuffer(0)

   
  	MOV #0, AR3               
	SUB	#1, T1, T3	;compute nx-1
	MOV	T3, BRC0	;init outer loop counter (nx-1)                

	MOV	XAR1, XAR7	;save original value to reinitialize coeff buffer pntr
	
	SUB	#1, T0, T3	;init inner loop counter (#bi-quads-1)
	MOV	T3, BRC1   

	MOV	#SCALE, T2	;scale factor
	
; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR3: dbuffer[] 
;  XAR7: reinit XAR1

	RPTBLOCAL	loop1-1		; Outer Loop: Process a new input

	MOV	*AR0+ << #16, AC0	; HI(AC0) = x(n)
	||RPTBLOCAL	loop2-1		; Inner Loop: Process a bi-quad

	MASM  T3= *(AR3+T0), *AR1+, AC0	; AC0 -= a1*d(n-1)      (1)

	MASM T3= *AR3, *AR1+, AC0	; AC0 -= a2*d(n-2)      (2)

	MPYM	*AR1+, T3, AC0		; AC0 = b2*d(n-2)       (3)
	::MOV	HI(AC0 << T2), *AR3	;  d(n) replaces d(n-2)
           
	MACM	*(AR3+T0), *AR1+, AC0	; AC0 += b0*d(n)        (4)
                                      
	MACM	*AR3+, *AR1+, AC0	; AC0 += b1*d(n-1)      (5)
					;   input to next biquad

loop2:

	MOV	XAR7, XAR1		; reinitialize coeff pointer

	MOV	rnd(HI(AC0)), *AR2+	; store result to output buffer

loop1:

;Signal overflow
	MOV	#0, T0
	XCC	check1, overflow(AC0)
	MOV	#1, T0
check1:


;Context restore
	POPBOTH	XAR7
	POPBOTH	XAR5
	POP	T3
	POP	T2
	;POP	mmap(DP)
;   ZHENGTING ADDED
	POP mmap(DPH)
	POP mmap(DP)

	POP	mmap(ST3_55)
	POP	mmap(ST2_55)
	POP	mmap(ST1_55)
	POP	mmap(ST0_55)

	RET


 
iircas51.asm/   1161799688  0     0     0       7847      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:	 iircas51
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;
; Copyright Texas instruments Inc, 2000
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                          
;  x(n) ------.-----x-->+ -------> + -----.---------> y(n)
;             |    b0   |\        /|      |       
;           [z-1]       | |      | |    [z-1]     
;             |         | |      | |      |       
;             v         | |      | |      v       
;           x(n-1)--x---| |      | |--x-d(n-1)           
;             |    b1     |      |  -a1   |       
;             |           |      |        |       
;           [z-1]         |      |      [z-1]     
;             |           |      |        |       
;             v           |      |        v       
;           x(n-2)--x-----|      |---x--d(n-2)    
;                  b2              -a2            
;            
;                 "FF"             "FB"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  y(n)= b0*x(n) + b1*x(n-1) + b2*x(n-2) - a1*y(n-1) - a2*y(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag = iircas51(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[5*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = b01 b11 b21 a11 a21 ....b0i b1i b2i a1i a2i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[4*nbiq]: PASSED in XAR3.
;        Pointer to delay buffer of length 4*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[4*nbiq]"            "h[5*nbiq]"
;                                 AR1(h)->b01
;      AR3(xn)-->x11                      b11 
;                x12                      b21
;                 :                       a11
;                x1n                      a21
;                x21                      b02
;                x22                      b12
;                 :                       b22
;                x2n                      a12
;      AR4(yn)-->y11                      a22
;                y12                       :
;                 :                       b0i
;                y1n                      b1i
;                y21                      b2i
;                y22                      a1i
;                 :                       a2i
;                y2n
;               
;
;      Def: xij/yij/aij/bij  where i = delay #
;                                  j = biquad #


	.arms_off
	.cpl_off
	.mmregs
;******************************************
;*       Assigns
;******************************************
	.def	_iircas51

;******************************************
;*       Constant Defines
;******************************************

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas51
;Context save

	PSH	mmap(ST0_55)
	PSH	mmap(ST1_55)
	PSH	mmap(ST2_55)
	PSH	mmap(ST3_55)

	BCLR	CPL			;DP relative addressing

;	PSH	mmap(DP)
;	MOV	#0, DP
;   ADDED REGARDING THE BUG REPORT, ZHENGTING
	PSH mmap(DP)
	PSH mmap(DPH)
	AMOV #0, XDP

	.dp	0

	PSH	@T3_L
	PSHBOTH	XAR4
	PSHBOTH	XAR7

;initialization
	BSET	SXMD			;sign extension enable
	BCLR	SATD			;D-unit saturate disable
	BSET	FRCT			;fractional mode enable
	BCLR	SATA			;A-unit saturate disable


;setup circular addressing
	MOV	T0, T3			;compute 2*nbiq
	SFTS	T3, #1
	MOV	@T3_L, BK03		;init AR0-3 circular buf size (2*nbiq)
	MOV	@T3_L, BK47		;init AR4-7 circular buf size (2*nbiq)

	BSET	AR3LC			;init AR3 = circular (dbuffer)
	MOV	@AR3_L, BSA23		;init AR2-3 circular start addr: dbuffer(1)

	BSET	AR4LC			;init AR4 = circular (dbuffer)
	MOV	XAR3, XAR4		;adjust AR4 to buffer start
	ADD	T3, AR4
	MOV	@AR4_L, BSA45		;init AR45 circ start addr: dbuffer(1+nbiq)

	MOV	#0, AR3		;init AR3 offset to x(n) buffer start
	MOV	#0, AR4		;init AR4 offset to y(n) buffer start

	SUB	#1, T1, T3		;compute nx-1
	MOV	T3, BRC0		;init outer loop counter (nx-1)

	MOV	XAR1, XAR7		;save original value to reinitialize coeff buffer pntr

	SUB	#1, T0, T3		;init inner loop counter (#bi-quads-1)
	MOV	T3, BRC1

	ADD	#1, T0, T1		;index for buffer reset

; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR3: dbuffer[x]
;  XAR4: dbuffer[y]
;  XAR7: reinit XAR1

	RPTBLOCAL	loop1-1		;outer loop: process a new input

	MOV	*AR0+ << #16, AC1	; HI(AC1) = x(n)
	||RPTBLOCAL	loop2-1		;inner loop: process a bi-quad

	MPYM	*AR1+, AC1, AC0		; AC0 = b0*x(n)

	MACM	*AR1+, *(AR3+T0), AC0	; AC0 += b1*x(n-1)

	MACM	*AR1+, *AR3, AC0	; AC0 += b2*x(n-2)

	MOV	HI(AC1), *AR3		; x(n) replaces x(n-2) 
	||AADD	T1, AR3			; point to next x(n-1)

	MASM	*AR1+, *(AR4+T0), AC0	; AC0 -= a0*y(n-1) 

	MASM	*AR1+, *AR4, AC0	; AC0 -= a1*y(n-2) 

	MOV	rnd(HI(AC0)), *AR4	; y(n) replaces y(n-2)
	||AADD	T1, AR4			;point to next y(n-1)

	MOV	AC0, AC1		;input to next biquad

loop2:

	MOV	XAR7, XAR1		;reinitialize coeff pointer

	MOV	rnd(HI(AC0)), *AR2+	;store result to output buffer

loop1:

; Signal overflow
	MOV	#0, T0
	XCC	check1, overflow(AC0)
	MOV	#1, T0
check1:



;Context restore
	POPBOTH	XAR7
	POPBOTH	XAR4
	POP	@T3_L
;	POP	mmap(DP_L)
;   ZHENGTING ADDED
	POP mmap(DPH)
	POP mmap(DP)

	POP	mmap(ST3_55)
	POP	mmap(ST2_55)
	POP	mmap(ST1_55)
	POP	mmap(ST0_55)

	RET	
	

iirlat.asm/     1161799694  0     0     0       7490      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
; Function:    iirlat
; Processor:   C55xx
; Description: Computes a real lattice IIR filter implementation using 
;		coefficient stored in vector h. The real data input is 
;		stored in vector x. The filter output result is stored 
;		in vector r .  This function retains the address of the 
;		delay filter memory d containing the previous delayed 
;		values to allow consecutive processing of blocks. This 
;		function can be used for both block-by-block and  
;		sample-by-sample filtering (nx=1).    
;		C-callable.
;
; Useage: short oflag = iirlat (DATA *x, 
;				DATA *h, 
;				DATA *r, 
;				DATA *pbuffer, 
;				int nx, 
;				int nh)
; Copyright Texas instruments Inc, 2000
;****************************************************************
*;Algorithm:
*; 	e(nh)[n] = x[n]
*;	
*; 	e(i-1)[n]  = e(i)[n] + k(i)*e'(i-1)[n-1]   i=nh,nh-1,.. 1
*;       e'(i)[n] = k(i)*e(i-1)[n] + e'(i-1)[n-1]   i=nh,nh-1,.. 1
*;	r[n] = e(0)[n]=e'(0)[0]
*;
*;
*;pbuffer: procession buffer of nh length
*;      e'0[n-1]
*;      e'1[n-1]
*;      e'2[n-1]
*;      e'3[n-1]
*;	.
*;	.
*;      e'nh-2[n-1]
*;      e'nh-1[n-1]
*;
*;x: input of length nx
*;	x[0]
*;	x[1]
*;	.
*;	.
*;	.
*;	x[nx-2]
*;	x[nx-1]
*;
*;h: input of length nh-1 (zero pad 1st value)
*;	0
;	h[1]
;	.
;	.
;	.
;	h[nh-1]
;	h[nh]
;
;r: output of length nx
;	r[0]
;	r[1]
;	.
;	.
;	.
;	r[nx-2]
;	r[nx-1]  
;
;
;****************************************************************


      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, p_ptr           ;circular pointer
      .asg     AR3, temp	    ;temp buffer
	
       
      .asg     BSA45, p_base        ;base addr for p_ptr
      .asg     XAR4, xdb_base       ;extended base addr for p_ptr
      .asg     BK47, p_sz           ;circ buffer size for p_ptr
      .asg     BK47_L, p_sz_L       ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     BRC1, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag           ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers, AR4, AR1 circular


      .global _iirlat

      .text
_iirlat:

        PSH	mmap(ST3_55)


;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT
      
	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC
      
	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer 
		
	MOV	mmap(AR1), h_base	;base address of coefficients
					; passed in AR1
    
	MOV	mmap(T1), h_sz		;h_sz = nh

; r pointer - passed in its destination register, need do nothing

; p pointer

	MOV XAR3, XAR4
  
	MOV	mmap(AR3), p_base	;base address for p_ptr
      
	MOV	mmap(T1), p_sz		;p_sz = nh


; Set circular/linear ARx behavior
	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------
	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times
	SUB	#2, T1, T0		;T0 = nh-2
	MOV	T0, inner_cnt		;inner loop executes nh-1 times
	SUB	#1, T1			; T1 = nh-1   
      
	MOV	mmap(T1), p_ptr		;point to last coefficient
            
	MOV	mmap(T1), h_ptr		;point to last coefficient
      
	MOV	#-1, T0		; setup offset register 
      
;
; Start of outer loop
;----------------------------------------------------------------
	RPTBLOCAL	loop1-1		;start the outer loop
	
;1st iteration
      
	MOV	*x_ptr+ << #16, AC0	; setup for e(0): input value
       
       
;inner loop
	||RPTBLOCAL	loop2-1
	MOV	*p_ptr(T0) <<#16, AC1	; setup for e'(0): input value
      
	MASM	*h_ptr, *p_ptr(T0), AC0	; calculate e(0)
	MACM	*h_ptr-, AC0, AC1		; calculate e'(0)
	MOV	HI(AC1), *p_ptr-		; store e'(i)
      		
loop2:      	     

;last iteration has rounding
      
	MACMR	*h_ptr-, *p_ptr(T0), AC0
     
      
	MOV	HI(AC0), *p_ptr-		; store previously cacluclated e'(i)
							
;store result to memory
	||MOV	HI(AC0), *r_ptr+		;store Q15 value to memory

loop1:						;end of outer loop

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
    .if  $isdefed("SI_BUGS")
	MOV	#0, oflag		;clear oflag
	XCC	check1, overflow(AC0)	;clears ACOV0
    .else
	MOV	#0, oflag		;clear oflag
	||XCCPART	check1, overflow(AC0)	;clears ACOV0
	.endif
	MOV	#1, oflag			;overflow occurred
check1:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR	FRCT			;clear FRCT

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC
      
	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

      POP	mmap(ST3_55)

;
; Return to calling function
;----------------------------------------------------------------
	RET			;return to calling function

;----------------------------------------------------------------
;End of file
interp.asm/     1161799699  0     0     0       6911      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    firinterp
; Processor:   C55xx
; Description: Interpolation filter with user specified FIR coefficients
;
;						Passing:
; Usage:   short firinterp(	DATA *x,	XAR0
;				DATA *h,	XAR1
;				DATA *r,	XAR2
;				DATA *dbuffer,	XAR3
;				ushort nh,	T0
;				ushort nx,	T1
;				ushort I);	XAR4
;
; Requirements:	I >= 1
;		nh/I >= 3
;		x[nx]
;		h[nh]
;		r[nx*I]
;		dbuffer[(nh/I)+1]
;			dbuffer[0] is ptr to last db entry
;			dbuffer[1..(nh/I)+1] is db data
; Copyright Texas instruments Inc, 2000
;****************************************************************

	.ARMS_off			;enable assembler for ARMS=0
	.CPL_on				;enable assembler for CPL=1
	.mmregs				;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ	.set	1		;return address
REG_SAVE_SZ	.set	0		;save-on-entry registers saved
FRAME_SZ	.set	0		;local variables
ARG_BLK_SZ	.set	0		;argument block

PARAM_OFFSET	.set	ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
	.asg	AR0, x_ptr		;linear pointer
	.asg	AR1, h_ptr		;circular pointer
	.asg	AR2, r_ptr		;linear pointer
	.asg	AR4, db_ptr		;circular pointer

	.asg	BSA01, h_base		;base addr for h_ptr
	.asg	BK03, h_sz		;circ buffer size for h_sz
	.asg	BSA45, db_base		;base addr for db_ptr
	.asg	XAR4, xdb_base		;extended base addr for db_ptr
	.asg	BK47, db_sz		;circ buffer size for db_ptr
	.asg	BK47_L, db_sz_L		;for memory mapped access
                                	
	.asg	CSR, inner_cnt		;inner loop count
	.asg	BRC0, outer_cnt		;outer loop count
	.asg	BRC1, mid_cnt		;outer loop count

	.asg	T0, oflag		;returned value
	.asg	T1, I			;interpolation factor

ST2mask	.set	0000000000010010b	;circular/linear pointers


	.global	_firinterp

	.text
_firinterp:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

	AND	#01FFh,mmap(ST0_55)	;clear all ACOVx,TC1, TC2, C
	OR	#4140h,mmap(ST1_55)	;set CPL, SXMD, FRCT
	AND	#0F9DFh,mmap(ST1_55)	;clear M40, SATD, 54CM 
	AND	#07A00h,mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC
	AND	#0FFDDh,mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
; Setup loop counts
;----------------------------------------------------------------

; outer loop count
	SUB	#1,T1
	MOV	T1,outer_cnt		;outer_cnt = nx-1

; x pointer - passed in its destination register, need do nothing

; h pointer
	MOV	mmap(AR1),h_base	;base address of coefficients
	MOV	#0,h_ptr		;point to first coefficient
	MOV	mmap(T0),h_sz		;coefficient array size h_sz = nh

; r pointer - already passed in its destination register

; db pointer
	MOV	AR4,I			;save I (interpolation factor)
	MOV	XAR3,xdb_base		;db array address
	MOV	*AR3+,db_ptr		;index of oldest db entry
	MOV	mmap(AR3),db_base	;base address for db_ptr

; Set circular/linear ARx behavior
	OR	#ST2mask,mmap(ST2_55)	;config circ/linear pointers

; Setup loop counts
	BCLR	SXM
	MOV	T0,AC0			;AC0 = nh
	||RPT	#(16-1)
	SUBC	mmap(I),AC0		;LO(AC0) = (nh/I)
	MOV	HI(AC0),mmap(T0)	;T0 = remainder of (nh/I)
	MOV	AC0,mmap(db_sz)		;db_sz = (nh/I)
	SUB	#3,AC0			;
	MOV	AC0,mmap(inner_cnt)	;inner_cnt = (nh/I)-3 (reload for FIR taps)
	ADD	mmap(I),T0		;
	ADD	#1,T0			;T0 = remainder+I+1 (last tap hptr update)
	BSET	SXM

	SUB	#1,I,T2			;T2 = I-1
	MOV	T2,mid_cnt		;mid_cnt = I-1	
	
	BCC	No_Interp, T3<0	
	
;
; Start of outer loop  I>=2
;----------------------------------------------------------------
	RPTBLOCAL	L1-1		;outer loop (nx iterations)
	
	;move next input value into delay buffer
	MOV	*x_ptr+,*db_ptr		

	||RPTBLOCAL	L2-1		;  middle loop (I iterations)
	 
	;Sum h*x (nh/I)-iterations (only non-zero) for next r value
	MPYM	*db_ptr+,*(h_ptr+I),AC0	;    inner loop (nh/I iterations)      
	||RPT	inner_cnt
	MACM	*db_ptr+,*(h_ptr+I),AC0,AC0
	MACMR	*db_ptr+,*(h_ptr+T0),AC0,AC0
	
	;store result to memory
	MOV	HI(AC0),*r_ptr+		;    store Q15 value to memory
L2:	
	;reset h_ptr
	AMAR	*(h_ptr-I)		;  h_ptr = &h[0]	
	
	;Point db_ptr to new entry
	||AMAR	*db_ptr-		;
L1:					;end of outer loop

	B	L3			;goto exit procedure
;
; Start of outer loop  I=1
;----------------------------------------------------------------
No_Interp:
	MOV	T2,inner_cnt		;inner_cnt = nh-3 (2 iter outside loop)
	RPTBLOCAL L3-1			;start the outer loop
	
	;move next input value into delay buffer
	MOV	*x_ptr+,*db_ptr		

	;Sum h*x nh-iterations for next r value
	MPYM	*db_ptr+,*h_ptr+,AC0      
	||RPT	inner_cnt
	MACM	*db_ptr+,*h_ptr+,AC0,AC0
	MACMR	*db_ptr,*h_ptr+,AC0,AC0

	;store result to memory
	MOV	HI(AC0),*r_ptr+		;store Q15 value to memory
L3:					;end of outer loop
	
;
; Update the db entry point
;----------------------------------------------------------------
	MOV db_ptr,*-AR3		;update 1st element of db array

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV #0,oflag			;clear oflag

	XCCPART overf_label, overflow(AC0) ;clears ACOV0
	||MOV #1,oflag			;overflow occurred
overf_label:

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;	BCLR #ST1_FRCT,ST1_55		;clear FRCT
;	AND #0FE00h,mmap(ST2_55)	;clear CDPLC and AR[7-0]LC
;	BSET #ST2_ARMS,ST2_55		;set ARMS            

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
      RET                         ;return to calling function

;----------------------------------------------------------------
;End of file

ldiv16.asm/     1161799704  0     0     0       6567      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    ldiv16
; Processor:   C55xx
; Description: Implements long division function.  Reciperical of Q15, y 
; 	       is calculated then multiplied times Q31 x. C-callable.
;
; Useage: void ldiv16(LDATA *x, 
;			DATA *y, 
;			DATA *z, 
;			DATA *zexp, 
;			ushort nx)
;
; Algorithm:
;     This routine returns the fractional and exponential portion
;  of the division in the form of :
;          
;               z[i] * zexp[i] = reciprocal
;
; History:
;         07/07/2003 - d. elam fixed bug in range test 
; Copyright Texas instruments Inc, 2000
;****************************************************************
   
      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, y_ptr	    ;linear pointer
      .asg     AR2, z_ptr           ;linear pointer
      .asg     AR3, zexp_ptr        ;linear pointer
      .asg     T0, norm_ptr	    ;temp linear pointer
      .asg     AR4, ye_ptr	    ;table linear pointer
      	     
      
      .asg     BRC0, outer_cnt      ;outer loop count

      
ST2mask  .set  0000000000000000b    ;circular/linear pointers


      .global _ldiv16
      
      .text
_ldiv16:

       PSH	mmap(ST3_55)


;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx, TC1, TC2, C

	OR	#04100h, mmap(ST1_55)	;set CPL, SXMD
	
	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; z pointer - passed in its destination register, need do nothing
      
; zexp  pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------

	MOV	#1, BRC1		;repeat inner loop 2x

	SUB	#1, T0			;T0 = n-1
	MOV	T0, outer_cnt		;outer loop executes n times

;
; Start of outer loop
;----------------------------------------------------------------
	RPTB	loop1-1			;start the outer loop
	MOV	*y_ptr+ << #16, AC1	;load first input value
	MANT	AC1, AC0		;calculate normalization of 1st value
	::NEXP	AC1, T1
	NEG	T1			;exponent value for the offset pointer
	ADD	#1, T1, ye_ptr		;offset pointer to exponent
	MOV	HI(AC0), norm_ptr	;store xnorm
	||SFTS	AC0, #-1		;shift right by one for 1st approximation
	XOR	#1FFFh << #16, AC0	;estimate the first Ym value
	MOV	HI(AC0), *z_ptr		;store first Ym

; First two iterations      Calculate Ym = 2*Ym - Ym^2*X
	||RPTBLOCAL	loop2-1
	MOV	*z_ptr << #15, AC0
	||MOV	*z_ptr, T1
	MPYM	*z_ptr, norm_ptr, AC1
	MOV	HI(AC1 << #1), *z_ptr
	MPYM	*z_ptr, T1, AC1
	SUB	AC1 << #1, AC0
	MOV	HI(AC0 << #2), *z_ptr

loop2:

; final iteration - same as previous loop without final command
; Calculate Ym = 2*Ym - Ym^2*X

	MOV	*z_ptr << #15, AC0
	||MOV	*z_ptr, T1
	MPYM	*z_ptr, norm_ptr, AC1
	MOV	HI(AC1 << #1), *z_ptr
	MPYM	*z_ptr, T1, AC1
	SUB	AC1 << #1, AC0
	
;-------------------------------------------------------------------------
; Check if value is in range 8000h <= Ym <= 7fffh, Adjust sign of result
;-------------------------------------------------------------------------
	BSET SATD
	SFTS    AC0, #3 
	MOV	HI(AC0), *z_ptr
	BCLR SATD
	
;-------------------------------------------------------------------------
; Multiply numerator by reciprocal of denominator
;-------------------------------------------------------------------------
	MPYM	*z_ptr, *x_ptr+, AC0		;numerator high * denominator high
	MPYM	*z_ptr, uns(*x_ptr+), AC1		;numeratot low * denominator high

;	OR	#04000h, mmap(ST1_55)		;turn off SXMD, set CPL

	ADD	AC1 << #-16, AC0
	SFTS	AC0, #1

	OR	#04100h, mmap(ST1_55)		;set CPL, SXMD


	ADD	#8000h, AC0		;rounding
	MANT	AC0, AC1
	::NEXP	AC0, T1		;calculate normalization of 1st value
	ADD	ye_ptr, T1		;offset pointer to exponent values
	MOV	#1, AC2
	||BCC final, T1 >= #0
	MOV	*(AC1H) << T1, AC1
	MOV	*(AC1L) << #16, AC1
	MOV	#0, T1

final:	
	SFTS	AC2, T1, AC0		;calculate exponent value
	||MOV	HI(AC1), *z_ptr+
	MOV	AC0, *zexp_ptr+		;store exponent

loop1:					;end of outer loop

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

       POP	mmap(ST3_55)
;
; Return to calling function
;----------------------------------------------------------------
      RET			;return to calling function

	
;----------------------------------------------------------------
;End of file


log_10.asm/     1161799714  0     0     0       3494      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	log_10
;  Description: Calculate log base 10 of 16-bit Q15 number
;
;  Copyright Texas instruments Inc, 2000
;********************************************************************************

	.mmregs		; assign Memory-Mapped Register names as global symbols
	.def		_log_10

	.asg    #04000h, CST_4000
	.asg    #0DC56h, LB6
	.asg    #54adh, LB5
	.asg    #9e8ah, LB4
	.asg    #50d5h, LB3
	.asg    #0c056h, LB2
	.asg    #3ffdh, LB1
	.asg    #062dh, LB0
	.asg    #1h, CST_1                        
	.asg    #58B9h, CST_ln2

	.text    		; begin assembling into .text section
	
_log_10:            
    PSH	mmap(ST1_55)
	AADD	#-15, SP
	NOP
;initialization for Logarithm calculation  

	MOV	XSP, XAR2
	MOV	CST_4000, *AR2+
	MOV	LB6, *AR2+
	MOV	LB5, *AR2+
	MOV	LB4, *AR2+
	MOV	LB3, *AR2+
	MOV	LB2, *AR2+
	MOV	LB1, *AR2+
	MOV	LB0, *AR2+
	MOV	CST_1, *AR2+
	MOV	CST_ln2, *AR2

	MOV	T0, AC0
	SUB	#1, AC0
	MOV	AC0, mmap(BRC0)

	RPTB	loop1-1
**************
* Normalize x
**************
    MOV	SP, AR2
	MOV	*AR0+ << #16, AC0		;A = x << 16
	EXP	AC0, T0				;T = number of leading bits
	BCLR	FRCT
	SFTS	AC0, T0, AC1
    
***************************
* Polynomial approximation 
***************************
   
	SFTS	AC1, #-15, AC0		;A <- 2*M
	SUB	*AR2+ << #1, AC0		;A <- (2*M-1) Q15

	MOV	AC0, T1			        ;U <- (2*M-1) Q15 (between 0.0 and 1.0)

	MOV	*AR2+ << #16, AC0		;B6 
	MOV	*AR2+ << #16, AC1		;B5 load [(Q18)<<16]=Q34

	
	MOV	*AR2+ << #16, AC1		;B4 load
	||MACR	AC0, T1, AC1, AC0   ;A(32-16) <- B6*U + B5
						        ;Q34 + Q18 << 16 = Q34
	
	MOV	*AR2+ << #16, AC1		;B3 load
	||MACR	AC0, T1, AC1, AC0	;A <- (B6*U + B5)*U + B4
						        ;Q33 + Q17 << 16 = Q33

	MOV	*AR2+ << #16, AC1		;B2 load
	||MACR	AC0, T1, AC1, AC0	;A <- ((B6*U+B5)*U+B4)*U+B3
						        ;Q32 + Q16 << 16 = Q32
	
	MOV	*AR2+ << #16, AC1		;B1 load
	||MACR	AC0, T1, AC1, AC0	;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
						        ;Q31 + Q15 << 16 = Q31

	MOV	*AR2 << #16, AC1		;B0 load
	||MACR	AC0, T1, AC1, AC0	;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
						        ;Q30 + Q14 << 16 = Q30

	SFTSC	AC0, #1
	MPY	T1, AC0
	ADD	*AR2+, AC0		; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U
					    ; + B1)*U + B0
					    ;Q30 + Q30 = Q30

*******************
* Process exponent
*******************
	NEG	T0, AC1			;AC1 <- number of leading bits
	SUB	*AR2+, AC1		;AC1 <- P-1
	MOV	AC1, T0
	SFTS	AC0, #-15
	MPYM	*AR2, T0, AC1			;AC1 <- ln2 * (P-1)

*************************
* Add both contributions
*************************

	ADD	AC1, AC0			; AC0 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)

	AND	#7FFFh, AC0, AC1		;store low word of AC0

	MOV	#03797h, T1
	BSET	FRCT

	||SFTSC	AC0, #1				;shift for 17 mpy
	MPY	T1, AC0
	SFTSC	AC0, #-1			;Hi word in AC0

	SFTSC	AC1, #16			;process low word
	MPY	T1, AC1
	SFTSC	AC1, #-16			;Lo word in AC1

	ADD	AC1, AC0			;add words together
	MOV	AC0, dbl(*AR1+)
endlog	;BCLR	FRCT

loop1:

************************
* Return overflow flag
************************

	AADD	#15, SP
	POP	mmap(ST1_55)
	
	MOV	#0, T0
	XCC	check, overflow(AC0)
	MOV	#1, T0
check:

	RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
	
log_2.asm/      1161799709  0     0     0       3525      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	log_2
;  Description: Calculate log base 2 of 16-bit Q15 number
;
;  Copyright Texas instruments Inc, 2000
;********************************************************************************

	.mmregs		; assign Memory-Mapped Register names as global symbols
	.def		_log_2

	.asg    #04000h, CST_4000
	.asg    #0DC56h, LB6
	.asg    #54adh, LB5
	.asg    #9e8ah, LB4
	.asg    #50d5h, LB3
	.asg    #0c056h, LB2
	.asg    #3ffdh, LB1
	.asg    #062dh, LB0
	.asg    #1h, CST_1                        
	.asg    #58B9h, CST_ln2
	.asg    #0D8B9h, NCST_ln2

	.text		; begin assembling into .text section
	
_log_2:            
       PSH	mmap(ST1_55)
	AADD	#-15, SP
	NOP
;initialization for Logarithm calculation  

	MOV	XSP, XAR2
	MOV	CST_4000, *AR2+
	MOV	LB6, *AR2+
	MOV	LB5, *AR2+
	MOV	LB4, *AR2+
	MOV	LB3, *AR2+
	MOV	LB2, *AR2+
	MOV	LB1, *AR2+
	MOV	LB0, *AR2+
	MOV	CST_1, *AR2+
	MOV	CST_ln2, *AR2

	MOV	T0, AC0
	SUB	#1, AC0
	MOV	AC0, mmap(BRC0)

	RPTB	loop1 - 1
**************
* Normalize x
**************
	MOV	SP, AR2
	MOV	*AR0+ << #16, AC0		;A = x << 16
	EXP	AC0, T0				;T = number of leading bits
	BCLR	FRCT
	SFTS	AC0, T0, AC1

***************************
* Polynomial approximation 
***************************
   
	SFTS	AC1, #-15, AC0		;A <- 2*M
	SUB	*AR2+ << #1, AC0		;A <- (2*M-1) Q15

	MOV	AC0, T1			;U <- (2*M-1) Q15 (between 0.0 and 1.0)

	MOV	*AR2+ << #16, AC0		;B6 load
	MOV	*AR2+ << #16, AC1		;B5 load

	MOV	*AR2+ << #16, AC1		;B4 load
	||MACR	AC0, T1, AC1, AC0		;A(32-16) <- B6*U + B5
						;Q34 + Q18 << 16 = Q34
	
	MOV	*AR2+ << #16, AC1		;B3 load
	||MACR	AC0, T1, AC1, AC0		;A <- (B6*U + B5)*U + B4
						;Q33 + Q17 << 16 = Q33

	MOV	*AR2+ << #16, AC1		;B2 load
	||MACR	AC0, T1, AC1, AC0		;A <- ((B6*U+B5)*U+B4)*U+B3
						;Q32 + Q16 << 16 = Q32
	
	MOV	*AR2+ << #16, AC1		;B1 load
	||MACR	AC0, T1, AC1, AC0		;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
						;Q31 + Q15 << 16 = Q31

	MOV	*AR2 << #16, AC1		;B0 load
	||MACR	AC0, T1, AC1, AC0		;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
						;Q30 + Q14 << 16 = Q30

	SFTSC	AC0, #1
	MPY	T1, AC0
	ADD	*AR2+, AC0		; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U
									; + B1)*U + B0
					;Q30 + Q30 = Q30

*******************
* Process exponent
*******************
	NEG	T0, AC1			;AC1 <- number of leading bits
	SUB	*AR2+, AC1			;AC1 <- P-1
	MOV	AC1, T0
	SFTS	AC0, #-15
	MPYM	*AR2, T0, AC1			;AC1 <- ln2 * (P-1)

*************************
* Add both contributions
*************************

	ADD	AC1, AC0			; AC0 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)

	MOV	AC0, AC1			;store AC0 temporarily

	MOV	#038AAh, T1			;0.4427 in hex
	BSET	FRCT				

	||SFTSC	AC0, #1				;shift for 17 mpy
	MPY	T1, AC0
	SFTSC	AC0, #-1			;Hi word in AC0

	ADD	AC1, AC0
	AND	#7FFFh, AC1			;take out low word from old AC0

	SFTSC	AC1, #16			;process low word
	MPY	T1, AC1
	SFTSC	AC1, #-16			;Lo word in AC1

	ADD	AC1, AC0			;add words together
	MOV	AC0, dbl(*AR1+)
endlog	

loop1:

************************
* Return overflow flag
************************

	AADD	#15, SP
	POP	mmap(ST1_55)

	MOV	#0, T0
	XCC	check, overflow(AC0)
	MOV	#1, T0
check:

	RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor


	

logn.asm/       1161799719  0     0     0       3079      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function: log_n
;  Description: Calculate natural log of 16-bit Q15 number
;
;  Copyright Texas instruments Inc, 2000
;********************************************************************************

	.mmregs		; assign Memory-Mapped Register names as global symbols
	.def		_logn

	.asg    #04000h, CST_4000
	.asg    #0DC56h, LB6
	.asg    #54adh, LB5
	.asg    #9e8ah, LB4
	.asg    #50d5h, LB3
	.asg    #0c056h, LB2
	.asg    #3ffdh, LB1
	.asg    #062dh, LB0
	.asg    #1h, CST_1                        
	.asg    #58B9h, CST_ln2

	.text
	
_logn:            

	PSH	mmap(ST1_55)

	SSBX SXMD

	AADD	#-15, SP
	NOP

;  Initialization for Logarithm calculation

	MOV	XSP, XAR2
	MOV	CST_4000, *AR2+
	MOV	LB6, *AR2+
	MOV	LB5, *AR2+
	MOV	LB4, *AR2+
	MOV	LB3, *AR2+
	MOV	LB2, *AR2+
	MOV	LB1, *AR2+
	MOV	LB0, *AR2+
	MOV	CST_1, *AR2+
	MOV	CST_ln2, *AR2

	MOV	T0, AC0
	SUB	#1, AC0
	MOV	AC0, mmap(BRC0)

	RPTB	loop1-1
**************
* Normalize x
**************
	MOV	SP, AR2
	MOV	*AR0+ << #16, AC0		;A = x << 16
	EXP	AC0, T0				;T = number of leading bits
	SFTS	AC0, T0, AC1

***************************
* Polynomial approximation 
***************************
   
	SFTS	AC1, #-15, AC0		;A <- 2*M
	SUB	*AR2+ << #1, AC0		;A <- (2*M-1) Q15

	MOV	AC0, T1			;U <- (2*M-1) Q15 (between 0.0 and 1.0)

	MOV	*AR2+ << #16, AC0		;B6 load
	MOV	*AR2+ << #16, AC1		;B5 load

	MOV	*AR2+ << #16, AC1		;B4 load
	||MACR	AC0, T1, AC1, AC0		;A(32-16) <- B6*U + B5
						;Q34 + Q18 << 16 = Q34
	
	MOV	*AR2+ << #16, AC1		;B3 load
	||MACR	AC0, T1, AC1, AC0		;A <- (B6*U + B5)*U + B4
						;Q33 + Q17 << 16 = Q33

	MOV	*AR2+ << #16, AC1		;B2 load
	||MACR	AC0, T1, AC1, AC0		;A <- ((B6*U+B5)*U+B4)*U+B3
						;Q32 + Q16 << 16 = Q32
	
	MOV	*AR2+ << #16, AC1		;B1 load
	||MACR	AC0, T1, AC1, AC0		;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
						;Q31 + Q15 << 16 = Q31

	MOV	*AR2 << #16, AC1		;B0 load
	||MACR	AC0, T1, AC1, AC0		;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
						;Q30 + Q14 << 16 = Q30

	SFTSC	AC0, #1
	MPY	T1, AC0
	ADD	*AR2+, AC0		; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U
									; + B1)*U + B0
					;Q30 + Q30 = Q30

*******************
* Process exponent
*******************
	NEG	T0, AC1			;AC1 <- number of leading bits
	SUB	*AR2+, AC1			;AC1 <- P-1
	MOV	AC1, T0
	SFTS	AC0, #-15
	MPYM	*AR2, T0, AC1			;AC1 <- ln2 * (P-1)

*************************
* Add both contributions
*************************
	ADD	AC1, AC0			; AC0 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)

endlog	MOV	AC0, dbl(*AR1+)

loop1:

************************
* Return overflow flag
************************

	AADD	#15, SP
	
	MOV	#0, T0
	XCC	check, overflow(AC0)
	MOV	#1, T0
check:

	POP	mmap(ST1_55)
	RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
 
	
	



maxidx.asm/     1161799729  0     0     0       7692      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;****************************************************************
; Function:    maxidx
; Processor:   C55xx
; Description: Description: Returns the index of the maximum element of a vector x. In case
;	of multiple maximum elements, r contains the index of the last maximum
;	element found
; Usage:    short r = maxidx (DATA *x, ushort ng, ushort ng_size)
;	Arguments:
;	*x Pointer to input vector of size nx 
;     ng Number of groups forming the x[NX] array
;     ng_size Size of the group  
;	r Index for vector element with maximum value
;
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains ng
;     T1   contains ng_size
;
;
;
; Copyright Texas instruments Inc, 2000
; History:
;  2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;  2.11 Li Yuan fixed code to work when the first element is the max 07/11/02
;****************************************************************
      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      
; Local variable
;----------------

      
      	.bss	MAX_VALUE, 2
MAX_INDEX	.set	MAX_VALUE + 1
      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
	.asg     AR0, x_ptr           ;linear pointer                    
	.asg     AR1, maxv_ptr		  ;linear pointer

      .asg     AR5, trn0_ptr    	  ; linear pointer
      .asg     AR6, trn1_ptr        ; linear pointer
    
      .asg     BRC0, outer_cnt      ;outer loop count

        .text                                                           
               
        .global _maxidx    
	
_maxidx:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
 

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

      PSH T2
      PSH T3
      PSHBOTH XAR5
      PSHBOTH XAR6
      PSHBOTH XAR7   
	
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	 
	   
      BCLR #C54CM, ST1_55
	BCLR #ARMS, ST2_55
      BCLR #CPL, ST1_55	       ;DP relative addressing
	

      PSH mmap(@DP_L)
      MOV  #0, DP			;set DP=0 for mmreg accesses
	.dp 0       

;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	
    
   ;Note: *AR1+ and *AR1- modifiers are needed in following instructions
   ;to allow parallelism with the blockrepeat instruction (cannot parallelize
   ;with *AR1(#1) = #0).
   AMOV #MAX_VALUE, XAR1	;pointer to .bss base
  

 ;
; Setup loop counts
;----------------------------------------------------------------
    SUB  #1, T0			;T0 = ng-1
    
    MOV T0, outer_cnt			;outer loop executes ng times
    || MOV *x_ptr, *maxv_ptr+ 	;MAX_VALUE = Aaddr[0]    

	MOV T1, T3
      || SUB AC3, AC3			; ac3 = #0 used to initialize TRN0,1

	SFTL T1, #-1
	|| MOV #TRN1_L, trn1_ptr 
	 
	SUB #2, T1

      MOV T1, CSR				;CSR = NG_SIZE/2 - 2
	|| MOV #TRN0_L, trn0_ptr

      MOV T1, AR3		;init position of leading zero 
  	 
  
  	SUB T1, T1
	||MOV #0ffh, AR7

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV T1, AR4			;save base index of max value initially
	
  	MOV #0, *AR1-	;MAX_INDEX = 0
    ||RPTBLOCAL outer_loop


;BENCHMARK KERNEL ******************************************************
;Data values are processed via the outer loop N_GROUP values at a time.
;The outer loop is therefore executed N_INPUT/N_GROUP times.
        


  ;START OF OUTER LOOP *******************

	MOV AC3, dbl(*AR6)		; AC3 = #0 ; init TRN1 = #0
      || MOV dbl(*AR0+), AC1		;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]

	MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
	|| RPT CSR		           ;repeat( #( (N_GROUP/2 - 1) - 1) )


  ;START OF INNER LOOP *******************

	MOV dbl(*AR0+), AC0
	|| MAXDIFF AC0, AC1, AC1, AC2  	;AC1_H/L contain max's

  ;END OF INNER LOOP ***************

    MOV *AR1, AC0       			;AC0 = old max value   
    ||SUB #2, AR0 
    
     MOV AC1, T0           ; T0    = odd max value
     || MOV @AC1_H, AC1    ; AC1_L = even max value

  ;test max(odd max value, even max value), Carry bit affected
	MAX T0, AC1		;AC1 = max(odd max value, even max value)
    
  ;test max(old max value, new max value)
	CMP AC1>AC0, TC1		;TC1 set if max(odd,even) value > old max value
   
  ;assume even max value > odd max value
	MOV T1, T0			;DR0 setup for even max index computation
	|| MOV @TRN0_L << #16, AC0		;AC0_H = TRN0 (setup for even max index)
 
	ADD T3, T1 		;T3 = #N_GROUP		;add N_GROUP to index base
  
     
     
	MOV AR3, AC2     ; AR3  = #(N_GROUP/2 - 2)		;index seed value
	|| XCCPART  label1, !CARRY			;if Carry=0 then odd max value > even max value
    
    ; move at the last place to take advantage of localrepeat 
label1:
    MOV @TRN1_L << #16, AC0		;AC0_H = TRN1 (setup for odd max index)
	|| ADD #1, T0		;DR0 modified for odd max index computation
 

  ;PERFORM IN_LOOP NECESSARY PORTION OF INDEX COMPUTATION **********

;  if TC1=1 or TC2=1, then a new max value is > old max value
    MOV AC3, *AR5     ; AC3 = #0 ; init TRN0 = #0
	||XCCPART label2 , TC1

 
label2:
  	 MOV T0, AR4			;save base index of max value
     || MOV  AR7, @AC0_G  			;AC0_G = 0xff, to isolate leading zero
   
    
    
	XCC label3, TC1

outer_loop:
label3:	EXP AC0, T2			;T2 = position of leading zero in AC0 
    || MOV AC1, *AR1    		;update MAX_VALUE

					;end outer loop


	
	SUB T2, AC2			;subtract lead zero position from index seed
	SFTL AC2, #1			;mult by 2 since 2 values tested per iteration
	ADD AR4,AC2 			;AC2 = index of max value
	 MOV AC2, T0 				; return value
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BSET #ARMS, ST2_55
      BSET #CPL, ST1_55	       ;SP relative addressing

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

    POP mmap(@DP_L)
	POPBOTH XAR7
      POPBOTH XAR6
      POPBOTH XAR5
      POP T3
      POP T2

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)



    RET        
        
        
        
        
        
        
        
        
        
        maxidx34.asm/   1161799724  0     0     0       5508      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;****************************************************************
; Function:    maxidx34
; Processor:   C55xx
; Description: Description: Returns the index of the maximum element of a vector x. In case
;	of multiple maximum elements, r contains the index of the last maximum
;	element found
; Usage:    short r = maxidx34 (DATA *x, ushort nx)
;	Arguments:
;	*x Pointer to input vector of size nx 
;   nx Number of elements in the x[NX] array  
;	r Index for vector element with maximum value
;
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains nx
;
;
;
; Copyright Texas instruments Inc, 2000
; History:
; 	2.10 Cesar I. original code. 08/03/01
;****************************************************************
      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      
      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
	.asg     AR0, x_ptr           ;linear pointer                    
	.asg     AR1, maxv_ptr		  ;linear pointer
    
    .asg     BRC0, outer_cnt      ;outer loop count

        .text                                                           
               
        .global _maxidx34    
	
_maxidx34:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
 

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

      PSH T2, T3   
	
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	 
	   
      BCLR #C54CM, ST1_55
	BCLR #ARMS, ST2_55
      BCLR #CPL, ST1_55	       ;DP relative addressing
	

      PSH mmap(@DP_L)
      MOV  #0, DP			;set DP=0 for mmreg accesses
	.dp 0    
      

;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	

; Setup loop counts
;----------------------------------------------------------------
	SFTL T0, #-1			;restore original value 
     ||SUB AC3, AC3

     SUB #2, T0  
     ||MOV @AC3_L,TRN0          ; TRN0 = #0

	MOV T0, CSR                ;CSR = NG_SIZE/2 - 2
     ||MOV @AC3_L,TRN1	      	; TRN1 = #0  
   
  	 SUB T1,T1 
      MOV T0, AR3

; start benchmark
	   
	MOV dbl(*AR0+), AC1	;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]
    
    ; 1 stall
	MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
	|| RPT CSR         ;repeat( #( (NX/2 - 1) - 1) )


	MOV dbl(*AR0+), AC0
	|| MAXDIFF AC0, AC1, AC1, AC2	   ;AC1_H/L contain max's
     ; 1 stall
     MOV AC1, T2           ; T0    = odd max value
     || MOV @AC1_H, AC1    ; AC1_L = even max value
        ;assume even max value > odd max value
	MOV T1, T0			;DR0 setup for even max index computation
	|| MOV @TRN0_L << #16, AC0		;AC0_H = TRN0 (setup for even max index)

  ;test max(odd max value, even max value), Carry bit affected
	MAX T2, AC1			;AC1 = max(odd max value, even max value) 

     
	MOV AR3,T3     ; AR3  = #(NX/2 - 2)		;index seed value
	|| XCCPART  label1, !CARRY			;if Carry=0 then odd max value > even max value
    
    ; move at the last place to take advantage of localrepeat 

    MOV @TRN1_L << #16, AC0		;AC0_H = TRN1 (setup for odd max index)
	|| ADD #1, T0		;DR0 modified for odd max index computation
 
    MOV  #0ffh, @AC0_G  			;AC0_G = 0xff, to isolate leading zero
    ; 1 stall
	EXP AC0, T2			;T2 = position of leading zero in AC0 
  
	SUB T2, T3  			;subtract lead zero position from index seed
	SFTL T3, #1 		;mult by 2 since 2 values tested per iteration
	ADD T3, T0 			;T0 = index of max value (return value)

;   
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BSET #ARMS, ST2_55
      BSET #CPL, ST1_55	       ;SP relative addressing


;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;    

	POP mmap(@DP_L)
	POP T2, T3

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)



    RET        
        
        
        
        
        
        
        
        
        
        maxval.asm/     1161799734  0     0     0       4052      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    maxval
; Processor:   C55xx
; Description: Description: Returns the value of the maximum element of a vector x
; Usage:    short r = maxval (DATA *x, ushort nx)
;	Arguments:
;	*x Pointer to input vector of size nx 
;     nx number of elements in the x[NX] array  
;	r maximum value
;
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains nx
;
;
;
; Copyright Texas instruments Inc, 2000
; History:
;  2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;****************************************************************
      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      

      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
    .asg     AR0, x_ptr           ;linear pointer                    
    .asg     BRC0, outer_cnt      ;outer loop count

        .text                                                           
               
        .global _maxval   
	
_maxval:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
 
  
	
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	 
	   
      BCLR #C54CM, ST1_55
	BCLR #ARMS, ST2_55
      BCLR #CPL, ST1_55	       ;DP relative addressing
	

      PSH mmap(@DP_L)
      MOV  #0, DP			;set DP=0 for mmreg accesses
	.dp 0    


;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	

; Setup loop counts
;----------------------------------------------------------------  

     SFTL  T0, #-1  			;divide by 2 
     SUB  #2, T0

     MOV T0, CSR				;CSR = NX/2 - 2
     || MOV dbl(*AR0+), AC1 		;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]

	MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
      || RPT CSR  
	

	MOV dbl(*AR0+), AC0
	|| MAXDIFF AC0, AC1, AC1, AC2	;AC1_H/L contain max's

    
	 MOV AC1, T0			   ;T0 = odd max value
	||MOV @AC1_H, AC3 		   ;AC1 = even max value
      
  ;test max(odd max value, even max value), Carry bit affected
	MAX AC3,T0        		;AC1 = max(odd max value, even max value)
				            ; return value in T0
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BSET #ARMS, ST2_55
      BSET #CPL, ST1_55	       ;SP relative addressing

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

    POP mmap(@DP_L)



;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)



    RET        
        
        
        
        
        
        
        
        
        
        maxvec.asm/     1161799739  0     0     0       1072      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:  MAXVEC
; Processor:   C55xx
; Description: maxvec: Value and Index of the maximum element of a vector
; Useage:	void maxvec (DATA *x, ushort nx, DATA *r_val, DATA *r_idx)
; Copyright Texas instruments Inc, 2000
;********************************************************************************

        .text
        .global	_maxvec
	
_maxvec:
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

        MOV *AR0+,AC1
        || SUB #2,T0

        MOV T0,BRC0
        || MOV #0,AR3


        MOV #0,T0
        || RPTBLOCAL end_block-1
        MOV *AR0+,AC0
        || MAR *AR3+
        MAX AC0,AC1
        XCCPART end_block, !CARRY
        || MOV AR3,*AR2
end_block:
        MOV AC1,*AR1
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
        RET

minidx.asm/     1161799745  0     0     0       7653      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;****************************************************************
; Function:    minidx
; Processor:   C55xx
; Description: Description: Returns the index of the minimum element of a vector x. In case
;	of multiple maximum elements, r contains the index of the last maximum
;	element found
; Usage:    short r = minidx (DATA *x, ushort ng, ushort ng_size)
;	Arguments:
;	*x Pointer to input vector of size nx 
;     ng Number of groups forming the x[NX] array
;     ng_size Size of the group  
;	r Index for vector element with maximum value
;
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains ng
;     T1   contains ng_size
;
;
;
; Copyright Texas instruments Inc, 2000
; History:
;  2.10 Li Yuan optimized code for benchmark purpose. 07/11/02
;               also fixed bug to make code works when the first element is min.
;****************************************************************
    .ARMS_off                     ;enable assembler for ARMS=0
    .mmregs                       ;enable mem mapped register names 
    .noremark   5555, 5584, 5573, 5572       
      
; Local variable
;----------------

      
   	.bss	MIN_VALUE, 2
MIN_INDEX	.set	MIN_VALUE + 1
      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
    .asg     AR0, x_ptr           ;linear pointer                    
    .asg     AR1, minv_ptr		  ;linear pointer

    .asg     AR5, trn0_ptr    	  ; linear pointer
    .asg     AR6, trn1_ptr        ; linear pointer
    
    .asg     BRC0, outer_cnt      ;outer loop count

    .text                                                           
    
    .global _minidx    
	
_minidx:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
 

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

    PSH T2
    PSH T3
    PSHBOTH XAR5
    PSHBOTH XAR6
    PSHBOTH XAR7   
	
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	 
	   
    BCLR #C54CM, ST1_55
	BCLR #ARMS, ST2_55
    BCLR #CPL, ST1_55	       ;DP relative addressing
	

    PSH mmap(@DP_L)
    MOV  #0, DP			;set DP=0 for mmreg accesses
	.dp 0       

;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	
    
    ;Note: *AR1+ and *AR1- modifiers are needed in following instructions
    ;to allow parallelism with the blockrepeat instruction (cannot parallelize
    ;with *AR1(#1) = #0).
    AMOV #MIN_VALUE, XAR1	;pointer to .bss base
  

;
; Setup loop counts
;----------------------------------------------------------------
    SUB  #1, T0			;T0 = ng-1
    
    MOV T0, outer_cnt			;outer loop executes ng times
    || MOV *x_ptr, *minv_ptr+ 	;MIN_VALUE = Aaddr[0]    

	MOV T1, T3
    || SUB AC3, AC3			; ac3 = #0 used to initialize TRN0,1

	SFTL T1, #-1
	|| MOV #TRN1_L, trn1_ptr 
	 
	SUB #2, T1

    MOV T1, CSR				;CSR = NG_SIZE/2 - 2
	|| MOV #TRN0_L, trn0_ptr

    MOV T1, AR3		;init position of leading zero 
  	 
  
  	SUB T1, T1
	||MOV #0ffh, AR7

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    MOV T1, AR4			;save base index of the first data
    	
  	MOV #0, *AR1-	;MIN_INDEX = 0
    ||RPTBLOCAL outer_loop


;BENCHMARK KERNEL ******************************************************
;Data values are processed via the outer loop N_GROUP values at a time.
;The outer loop is therefore executed N_INPUT/N_GROUP times.
        


    ;START OF OUTER LOOP *******************

	MOV AC3, dbl(*AR6)		; AC3 = #0 ; init TRN1 = #0
      || MOV dbl(*AR0+), AC1		;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]

	MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
	|| RPT CSR		           ;repeat( #( (N_GROUP/2 - 1) - 1) )


  ;START OF INNER LOOP *******************

	MOV dbl(*AR0+), AC0
	|| MINDIFF AC0, AC1, AC1, AC2  	;AC1_H/L contain max's

  ;END OF INNER LOOP ***************

    MOV *AR1, AC0       			;AC0 = old max value   
    ||SUB #2, AR0 
    
     MOV AC1, T0           ; T0    = odd max value
     || MOV @AC1_H, AC1    ; AC1_L = even max value

  ;test max(odd max value, even max value), Carry bit affected
	MIN T0, AC1		;AC1 = max(odd max value, even max value)
    
  ;test max(old max value, new max value)
	CMP AC0>=AC1, TC1		;TC1 set if max(odd,even) value > old max value
   
  ;assume even max value > odd max value
	MOV T1, T0			;DR0 setup for even max index computation
	|| MOV @TRN0_L << #16, AC0		;AC0_H = TRN0 (setup for even max index)
 
	ADD T3, T1 		;T3 = #N_GROUP		;add N_GROUP to index base
  
     
     
	MOV AR3, AC2     ; AR3  = #(N_GROUP/2 - 2)		;index seed value
	|| XCCPART  label1, !CARRY			;if Carry=0 then odd max value > even max value
    
    ; move at the last place to take advantage of localrepeat 
label1:
    MOV @TRN1_L << #16, AC0		;AC0_H = TRN1 (setup for odd max index)
	|| ADD #1, T0		;DR0 modified for odd max index computation
 

  ;PERFORM IN_LOOP NECESSARY PORTION OF INDEX COMPUTATION **********

;  if TC1=1 or TC2=1, then a new max value is > old max value
    MOV AC3, *AR5     ; AC3 = #0 ; init TRN0 = #0
	||XCCPART label2 , TC1

 
label2:
  	 MOV T0, AR4			;save base index of max value
     || MOV  AR7, @AC0_G  			;AC0_G = 0xff, to isolate leading zero
   
    
    
	XCC label3, TC1

outer_loop:
label3:	EXP AC0, T2			;T2 = position of leading zero in AC0 
    || MOV AC1, *AR1    		;update MIN_VALUE

					;end outer loop


	
	SUB T2, AC2			;subtract lead zero position from index seed
	SFTL AC2, #1			;mult by 2 since 2 values tested per iteration
	ADD AR4,AC2 			;AC2 = index of max value
	 MOV AC2, T0 				; return value
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	BSET #ARMS, ST2_55
      BSET #CPL, ST1_55	       ;SP relative addressing

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

    POP mmap(@DP_L)
	POPBOTH XAR7
      POPBOTH XAR6
      POPBOTH XAR5
      POP T3
      POP T2

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)



    RET        
        
        
        
        
        
        
        
        
        
        
minval.asm/     1161799750  0     0     0       3886      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    maxval
; Processor:   C55xx
; Description: Description: Returns the value of the maximum element of a vector x
; Usage:    short r = maxval (DATA *x, ushort nx)
;	Arguments:
;	*x Pointer to input vector of size nx 
;     nx number of elements in the x[NX] array  
;	r maximum value
;
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains nx
;
;
;
; Copyright Texas instruments Inc, 2000
; History:
;  2.10.04 Li Yuan optimized code for benchmark purpose. 08/03/01
;****************************************************************
    .ARMS_off                     ;enable assembler for ARMS=0
    .mmregs                       ;enable mem mapped register names 
    .noremark   5555, 5584, 5573, 5572       


; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
    .asg     AR0, x_ptr           ;linear pointer                    
    .asg     BRC0, outer_cnt      ;outer loop count
    
    .global _minval

    .text

_minval:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
 
  
	
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	 
	   
    BCLR #C54CM, ST1_55
	BCLR #ARMS, ST2_55
    BCLR #CPL, ST1_55	       ;DP relative addressing
	

    PSH mmap(@DP_L)
    MOV  #0, DP			;set DP=0 for mmreg accesses
	.dp 0    


;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	

; Setup loop counts
;----------------------------------------------------------------  

    SFTL  T0, #-1  			        ;divide by 2 
    SUB  #2, T0

    MOV T0, CSR				        ;CSR = NX/2 - 2
    || MOV dbl(*AR0+), AC1 		    ;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]

	MOV dbl(*AR0+), AC0		        ;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
    || RPT CSR  
	

	MOV dbl(*AR0+), AC0
	|| MINDIFF AC0, AC1, AC1, AC2	;AC1_H/L contain min's

    
	 MOV AC1, T0			        ;T0 = odd min value
	||MOV @AC1_H, AC3 		        ;AC1 = even min value
      
;test max(odd max value, even max value), Carry bit affected
	MIN AC3,T0        		        ;AC1 = min(odd min value, even min value)
				                    ; return value in T0
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

    BSET #ARMS, ST2_55
    BSET #CPL, ST1_55	       ;SP relative addressing

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

    POP mmap(@DP_L)



;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)

    RET        
minvec.asm/     1161799755  0     0     0       1068      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:  MINVEC
; Processor:   C55xx
; Description: minimum Value and Index of the minimum element of a vector
; Useage:	void minvec (DATA *x, ushort nx, DATA *val, DATA *idx)
; Copyright Texas instruments Inc, 2000
;********************************************************************************

        .text
        .global	_minvec
	
_minvec:
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

        MOV *AR0+,AC1
        || SUB #2,T0

        MOV T0,BRC0
        || MOV #0,AR3


        MOV #0,T0
        || RPTBLOCAL end_block-1
        MOV *AR0+,AC0
        || MAR *AR3+
        MIN AC0,AC1
        XCCPART end_block, !CARRY
        || MOV AR3,*AR2
end_block:
        MOV AC1,*AR1
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
        RET

mmul.asm/       1161799760  0     0     0       5045      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	mmul
;  Description: matrix multiply implementation
;  Usage:   short mmul(	DATA *x1,	XAR0
;			short row1,	T0
;			short col1,	T1
;			DATA *x2,	XAR1
;			short row2,	XAR2
;			short col2,	XAR3
;			DATA *r);	XAR4
;
;  Copyright Texas instruments Inc, 2000
; History
; 2.10.1 - clear C54CM bit at the begining. Li Yuan 08/08/01
;                
;****************************************************************
	.mmregs
	.text
	.def _mmul
_mmul:
	PSH	mmap(ST1_55)
	PSH	mmap(ST2_55)				
	PSHBOTH	XAR5	
	PSHBOTH	XAR6				
					;XAR0 = x1
					;T0 = row1
					;T1 = col1
					;XAR1 = x2
					;XAR2 = row2
					;XAR3 = col2
					;XAR4 = r				          

; clear 54CM
	BCLR	C54CM			;clear C54 compatible mode
;---------------------------------------------------					
; Verify that the dimensions of the input matrices are legal, i.e. input1 
; row size = input2 column size; else return input1 as output
;---------------------------------------------------					
	MOV	T0, T2			;T2 = row1
	MOV	T1, T0			;T0 = col1
	SUB	AR2, T0			;T0 = col1 - row2
	BCC	mmulend, T0!=#0		;return value FALSE

; Setup temps
	BSET	FRCT			;fractional mode set
	MOV	AR3, T0			;T0 = col2
					;T1 = col1
					;T2 = row1

; test if usage of Dual-MAC or Single-MAC
	SUB	#3, T1, T3
	BCC	mmul_single_mac, T3<#0
	SUB	#4, T2, T3
	BCC	mmul_single_mac, T3<#0

;---------------------------------------------------					
; Dual-MAC implementation for large matrices
; col1>=3 && row1>=4
;---------------------------------------------------
mmul_dual_mac:
					;---- pointers ----
	MOV	XAR0, XAR3		;XAR0 = &x1(1,1) (reload reg for XAR2, XAR3)
	MOV	XAR0, XAR2		;XAR2 = &x1(1,1)
	AADD	T1, AR3			;XAR3 = &x1(2,1)
	MOV	XAR1, XCDP		;XCDP = &x2(1,1)
	MOV	XAR4, XAR5		;XAR5 = &r(1,1)
	MOV	XAR1, XAR4		;XAR4 = &x2(1,1) (reload reg for XCDP)
	MOV	XAR5, XAR6		;XAR6 = &r(1,1) (reload reg for XAR5)

					;---- loop counters ----
	SUB	#1, T0, T3		;
	MOV	T3, BRC0		;outer loop count: BRC0 = col2-1
	MOV	mmap(T2) << #-1, AC2	;
	SUB	#1, AC2			;
	MOV	mmap(AC2L), BRC1	;mid loop count: BRS1 = (row1>>1)-1
	BTST	#0, mmap(T2), TC1	;if(row1==even) TC0=0 else TC0=1
	SUB	#3, T1, T3		;
	MOV	T3, CSR			;inner loop count: CSR = col1-3

; Perform Matrix Multiply

	RPTB	loop1-1

		;----- if(row1==odd) do first row of x using single MAC, then go to Dual MAC
	BCC	L1, !TC1
	MPYM	*AR2+, *(CDP+T0), AC0
	||RPT	CSR			;||
	MACM	*AR2+, *(CDP+T0), AC0
	MACMR	*AR2+, *(CDP+T0), AC0
	MOV	HI(AC0), *(AR5+T0)	;store to r
	||AADD	T1, AR3			;|| AR3 points to next row of x1
	MOV	AR4, CDP		;CDP points to same column of x2

L1:		;----- do an even number of rows of x using Dual MAC 
	RPTBLOCAL	loop2-1
	MPY	*AR2+, *(CDP+T0), AC0	;first iteration
	::MPY	*AR3+, *(CDP+T0), AC1	;
	||RPT	CSR			;||
	MAC	*AR2+, *(CDP+T0), AC0
	::MAC	*AR3+, *(CDP+T0), AC1
	MACR	*AR2+, *(CDP+T0), AC0	;last iteration
	::MACR	*AR3+, *(CDP+T0), AC1
	MOV	HI(AC0), *(AR5+T0)	;store to r
	||AADD	T1, AR2			;|| AR2 points to next row of x1
	MOV	HI(AC1), *(AR5+T0)	;store to r
	||AADD	T1, AR3			;|| AR3 points to next row of x1
	MOV	AR4, CDP		;CDP points to same column of x2

loop2:

	AMAR	*AR4+			;AR4 points to next column of x2
	||MOV	AR0, AR2		;|| AR2 points to x1(1,1)
	AMAR	*CDP+			;CDP points to next column of x2
	||MOV	AR0, AR3		;||
	AMAR	*AR6+			;AR6 points to next column of r
	AADD	T1, AR3			;AR3 points to x1(2,1)					
	||MOV	AR6, AR5		;|| AR5 points to next column of r

loop1:

	B	mmulret

;---------------------------------------------------					
; Single-MAC implementation for small matrices
; col1<3 || row1<4
;---------------------------------------------------
mmul_single_mac:
					;---- pointers ----
	MOV	XAR0, XAR2		;XAR2 = &x1(1,1)  XAR0 = &x1(1,1) for reload
	MOV	XAR1, XAR3		;XAR3 = &x2(1,1)  XAR1 = &x2(1,1) for reload
	MOV	XAR4, XAR5		;XAR5 = &r(1,1)   XAR4 = &r(1,1) for reload

					;---- loop counters ----
	SUB	#1, T0, T3		;
	MOV	T3, BRC0		;outer loop count: BRC0 = col2-1
	SUB	#1, T2, T3		;
	MOV	T3, BRC1		;mid loop count: BRC1 = row1-1
	SUB	#1, T1, T3		;
	MOV	T3, CSR			;inner loop count: CSR = col1-1

; Perform Matrix Multiply

	RPTBLOCAL	loop3-1

	RPTBLOCAL	loop4-1
	MOV	#0, AC0			;clear AC0
	||RPT	CSR			;
	MACM	*AR2+, *(AR3+T0), AC0
	ROUND	AC0			;round result
	MOV	HI(AC0), *(AR5+T0)	;store result to r
	||MOV	AR1, AR3		;AR3 points back to beginning of same column of x2

loop4:

	AMAR	*AR1+			;AR1 points to next column of x2
	||MOV	AR0, AR2		;AR2 points to x1(1,1)
	AMAR	*AR4+			;AR4 points to next column of r
	||MOV	AR1, AR3		;AR3 points to next column of x2
	MOV	AR4, AR5		;AR5 points to next column of r					

loop3:

mmulret:	
	MOV	#0, T0			;return value TRUE

mmulend:
	POPBOTH	XAR6
	POPBOTH	XAR5
	POP	mmap(ST2_55)
	POP	mmap(ST1_55)

	RET


mtrans.asm/     1161799766  0     0     0       1705      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;****************************************************************
;  Function:	mtrans
;  Description: matrix multiply implementation
;  Usage: short mtrans(	DATA *x1,	AR0
;			short row1,	T0
;			short col1,	T1
;			DATA *r);	AR1
;
;  Copyright Texas instruments Inc, 2000
;****************************************************************
	.mmregs
	.text
	.def _mtrans
_mtrans:
	PSH	mmap(ST1_55)
	PSH	mmap(ST2_55)
					;XAR0 = x1
					;T0 = row1
					;T1 = col1
					;XAR1 = r
	
        MOV     T0,HI(AC0)

        .if  $isdefed("SI_BUGS")
	MPY	T1,AC0,AC1		;AC1 = row1*col1
        MOV	XAR1,XAR2		;XAR2 = r to ensure MDP
        .else
	MPY	T1,AC0,AC1		;AC1 = row1*col1
     || MOV	XAR1,XAR2		;XAR2 = r to ensure MDP
        .endif

	MOV	AR0,mmap(@BSA01)	;BSA01 = x1
	MOV	AR1,mmap(@BSA23)	;BSA23 = r
	MOV	AC1,mmap(@BK03)		;init block size
	MOV	#0,AR0			;AR0 = 0
	MOV	#0,AR2			;AR2 = 0
	BSET	AR0LC
	BSET	AR2LC
	SUB	#1,T1,T2
	MOV	T2,CSR			;inner loop CSR = col-1
	SUB	#1,T0,T2
	MOV	T2,BRC0			;outer loop BRC0 = row-1
	MOV	#0,T2
		
	
	RPTBLOCAL  loop			;for every row of x1
    	RPT	CSR			;  for every col of x1
	MOV	*AR0+,*(AR2+T0)
loop:   AMAR	*AR2+			;  next col of r	

	MOV	#0,T0			;return value TRUE
   	POP	mmap(ST2_55)
	POP	mmap(ST1_55)

	return


mul32.asm/      1161799771  0     0     0       3535      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    mul32
; Processor:   C55xx
; Description: Implements a vector add using a single-MAC 
;              approach.  This routine is C-callable.
;
; Usage: ushort oflag = add (DATA *x,
;                             DATA *y,
;                             DATA *r,
;                             ushort nx,
;                             ushort scale)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

        .mmregs

					; register usage
					; ar0: addr. idx
* 	.asg	cdp, ar_x  ; used for mul32dual
	.asg	ar0, ar_x  ; used for mul32
	.asg	ar1, ar_y
	.asg	ar2, ar_z
	.asg	ar5, ar_zero

      .asg     T0, oflag            ;returned value

;*****************************************************************************
	.ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

      .def	_mul32
	.text

_mul32

      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)
	MOV 	#0, ar_zero 		; for zeroing   	
	MOV		#0,	T3                              	



;
; Configure the status registers as needed.
;----------------------------------------------------------------

      AND #01FFh,mmap(ST0_55)       ;clear all ACOVx,TC1, TC2, C
      OR #4140h,mmap(ST1_55)        ;set CPL, SXMD, FRCT
      AND #0F9DFh,mmap(ST1_55)       ;clear M40, SATD, 54CM 
      AND #07A00h,mmap(ST2_55)       ;clear ARMS, RDM, CDPLC, AR[0-7]LC
      AND #0FFDDh,mmap(ST3_55)       ;clear SATA, SMUL
  ; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; y pointer - - passed in its destination register, need do nothing

; r/z pointer - passed in its destination register, need do nothing

    MOV mmap(T0),a      ;RPTB count
    SUB 	#1, AC0
    MOV		AC0, mmap(BRC0)              

 	MOV #2,T0           ; for indexing
 	MOV #3,T1           ; for indexing

;
; 	mpy	*ar_x+,a		; a = 0 and XH adjustment
	MPYM 	*ar_x+, T3, AC0  

_start:
	; long data are stored in XH[0],XL[0], XH[1],XL[1], XH[2],XL[2], ... 
    rptblocal	eloop-1 		;					
  	
*	macsu	*ar_x-,*ar_y+,a 	; a  = XL*YH	(1)
    MPYM	uns(*ar_x-), *ar_y+, AC0 

*	macsu	*ar_y-,*ar_x,a		; a += XH*YL	(1)
    MACM	*ar_x, uns(*ar_y-), AC0 
 	
*	ld	a,-16,a 		; a >>= 16				
*	mac	*ar_x+0%,*ar_y+0%,a	; a += XH*YH		(1)
    MACM 	*(ar_x+T1), *(ar_y+T0), AC0 >> #16
    
*	st	a,*ar_z+ || ld *ar_zero,t;				(1)
*	stl	a,*ar_z+		;						
    MOV	AC0, dbl(*ar_z+)
;									 	Total loop cycles = 4 

eloop

; Return
;--------
_end:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

	MOV	#0, oflag		;clear oflag

	XCCPART	check1, overflow(AC0)	;clears ACOV0
	||MOV	#1, oflag		;overflow occurred

check1:

      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
	RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

neg.asm/        1161799781  0     0     0       5301      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    NEG
; Processor:   C55xx
; Description: Implements 2's complement of an input vector.
;              This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;	             x(i) = - x(i); 
;
; Usage: ushort oflag =  neg (DATA *x,
;                              DATA *r,
;                               ushort nx)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

	.ARMS_off		;enable assembler for ARMS=0
	.CPL_on			;enable assembler for CPL=1
	.mmregs			;enable mem mapped register names

; ---------------------------------------------------------------
; Stack Frame Setup
; ---------------------------------------------------------------

RET_ADDR_SZ	.set 1		;return address
REG_SAVE_SZ	.set 0		;save-on-entry registers saved
FRAME_SZ	.set 0		;local variables
ARG_BLK_SZ	.set 0		;argument block

PARAM_OFFSET	.set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ---------------------------------------------------------------
; Register usage and definitions
; ---------------------------------------------------------------
	.asg	AR0, x_ptr	;linear pointer for first input vector
	.asg	AR1, r_ptr	;linear pointer for result vector

	.asg	BRC0, outer_cnt	;outer loop count
	.asg	T0, oflag	;returned value

ST2mask	.set	0000000000010010b	;circular/linear pointers


	.def _neg
	.text

_neg:

     PSH	mmap(ST3_55)

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
; SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all AC0Vx, TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; ---------------------------------------------------------------
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------
	
	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers
	
; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#1, T0			;T0=nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = - X(i);
; ---------------------------------------------------------------

	RPTBLOCAL	outerloop	;start outer loop	
	MOV	*x_ptr+<<#16, AC0	;high AC0=input vector
	NEG	AC0
	MOV	HI(AC0), *r_ptr+
outerloop:

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	MOV	#0, oflag		;clear oflag

	XCCPART	OvrFlow, overflow(AC0)	;clears AC0V0
	||MOV 	#1, oflag		;overflow occured
OvrFlow:

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[0-7]LC

	BSET	ARMS			;set ARMS
	BCLR	FRCT			;clear FRCT

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

     POP	mmap(ST3_55)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------

	RET				;return to calling function

;----------------------------------------------------------------
;End of file


neg32.asm/      1161799776  0     0     0       5538      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    NEG32 
; Processor:   C55xx
; Description: Implements a 32-bit 2'complement of an input
;              vector.  This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;	              r(i) =  - x(i); 
;
; Usage: ushort oflag = neg32 (LDATA *x,
;                              LDATA *r,
;                              ushort nx)
;
; Copyright Texas instruments Inc, 2000
;
; Note:
; 1. Corrected loop lable
;           ------Li Yuan 10/31/2000
; 2. Corrected SATD bit setting from clear to set.
;           ------Li Yuan 01/19/2001
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, r_ptr           	;linear pointer for result vector

	.asg     BRC0, outer_cnt      	;outer loop count
	.asg     T0, oflag           	;returned value

ST2mask	.set  0000000000010010b 	;circular/linear pointers


	.def _neg32
	.text

_neg32:


     PSH	mmap(ST3_55)

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx, TC1, TC2, C

	OR	#04340h, mmap(ST1_55)	;set CPL. SXMD, FRCT, SATD

	AND	#0FBDFh, mmap(ST1_55)	;clear M40, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND 	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

; ---------------------------------------------------------------
; Setup loop counts
; --------------------------------------------------------------

	SUB	#1, T0			;T0 = nx - 1
	MOV	T0, outer_cnt		;outer loop executes nx times

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = - X(i);
; ---------------------------------------------------------------

	RPTBLOCAL   outerloop - 1 		;start the outer loop
	MOV40	    dbl(*AR0+), AC0	;AC0=32-bit value (input vector)
	NEG	AC0			;negate AC0
	MOV	AC0, dbl(*AR1+)		;storing 32-bit ACC to mem
outerloop:				;end of outer loop

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	MOV	#0, oflag		;cler oflag

	XCCPART	OvrFlow, overflow(AC0)	;clears AC0V0
	||MOV	#1, oflag		;overflow occured

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[0-7]LC

	BSET	ARMS			;set ARMS
	BCLR	FRCT			;clear FRCT

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

     POP	mmap(ST3_55)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------
      RET				;return to calling function

;----------------------------------------------------------------
;End of file


power.asm/      1161799785  0     0     0       6051      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    POWER
; Processor:   C55xx
; Description: Implements a vector power using a single-MAC 
;              approach.  This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;                r(i) += x(i) * x(i); 
;
; Usage: ushort oflag = add (DATA *x,
;                             LDATA *r,
;                             ushort nx,
;
; Copyright Texas instruments Inc, 2000
;
; History:
; - Corrected return register from AR2 to AR1.
;               ---- Li Yuan    01/17/01
;
; - Return overflow value is in T0 instead of AC0. 
;   Output vector is pointed by AR3 and returned.
;      Zhengting He - 10/25/2006
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
; REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
REG_SAVE_SZ       .set 2            ;save-on-entry registers saved CHANGED BY ZHENGTING
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, r_ptr           	;linear pointer for result vector
;	.asg     AR2, r_ptr           	;linear pointer for result vector NEW

ST2mask	.set  0000000000010010b 	;circular/linear pointers


        .def _power
	.text

_power:

     PSH	mmap(ST3_55)

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
	AADD #-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP 
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function
	MOV	XAR3, dbl(*SP(#0))	; PSHM    XAR3

; ZHENGTING ADDED THESE 2 LINES SINCE AR3 NEEDS TO BE USED TO 
; RETURN RESULT. SAVE XAR3 NOW AND RESTORE XAR3 LATER 

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)		;clear all ACOVx, TC1, TC2, C
	
	OR	#04140h, mmap(ST1_55)		;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)		;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)		;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)		;clear SATA, SMUL

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------

	OR	#ST2mask, mmap(ST2_55)		;config circ/linear pointers

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#2, T0				;T0 = nx - 1
	MOV	T0, CSR				;outer loop executes nx times
	SQRM	*x_ptr+, AC0			;zero out the ACC and the first mpy

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) * X(i);
; ---------------------------------------------------------------

	||RPT	CSR

; ----------------------------------------------------
; AC0 = m40(rnd(AC1 + uns(*x_ptr+)) * uns(*y_ptr+))))
; ----------------------------------------------------

	SQAM	*x_ptr+, AC0			;vector MAC of two inputs
	MOV AR1, AR3
	MOV AC0, dbl(*AR3)  ; ZHENGTING ADDED SINCE AR1 CANNOT BE USED HERE

; ADDED CODE TO CHECK THE OVERFLOW
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	MOV #0, T0
	
    .if  $isdefed("SI_BUGS")
	XCC dummy1, overflow(AC0)
	.else
	XCCPART dummy1, overflow(AC0)
	.endif
dummy1:  MOV #1, T0 		; 


; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)		;clear CDPLC and AR[0-7]LC

	BSET	ARMS				;set ARMS
	BCLR	FRCT				;clear FRCT

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function
; ZHENGTING ADDED
	MOV	dbl(*SP(#0)), XAR3	; POPM    AR3	
      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
	AADD #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ +1), SP

    POP	mmap(ST3_55)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------
      RET					;return to calling function

;----------------------------------------------------------------
;End of file


q15tofl.asm/    1161799790  0     0     0       3075      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
;  Function:	q15tofl
;  Description: converts Q15 to IEEE floating point
;
;  Copyright Texas instruments Inc, 2000
;****************************************************************

        .ARMS_off                     ;enable assembler for ARMS=0
        .CPL_on                       ;enable assembler for CPL=1
	.mmregs


;----------------------------------------------------------------
; Function definition:
;----------------------------------------------------------------

	.global	_q15tofl

_q15tofl:


;----------------------------------------------------------------
; Prologue: establish local frame, reset sign extension mode
;----------------------------------------------------------------

	AADD	#-7, SP
	BCLR	SATD
	BCLR	SXMD	

;----------------------------------------------------------------
; Process function arguments
;----------------------------------------------------------------

;	MOV	AR0, AR2
;	MOV	AR1, AR3
	||MOV	T0, AC1
	SUB	#1, AC1
	MOV	AC1, mmap(BRC0)

;----------------------------------------------------------------
; Store function constants
;----------------------------------------------------------------

	MOV	#127, *SP(#4)
	MOV	#32768, *SP(#5)
	MOV	#1, *SP(#6)

	MOV	#16383, *SP(#0)
	MOV	#65535, *SP(#1)
	
	BSET	SXMD	
	MOV	*AR0+ << #16, AC0

;----------------------------------------------------------------
; Convert each element of vector A, to Q15 format
; Pre-Load first vector element
;----------------------------------------------------------------
	
	||RPTB	end_loop

loop_start:
	BCC 	zero, AC0 == #0
	CMP	*(#(9))== #32767, TC2
	AND	#32768 << #16, AC0, AC1
	BCC	not_q_one, !TC2 
	MOV	#0 << #16, AC0
not_q_one:
	ABS	AC0

;----------------------------------------------------------------
; Shift right by one, since exp and norm never count shift into
; upper most bit (bit 31)
;----------------------------------------------------------------

	SFTSC	AC0, #-1
	EXP	AC0, T3
	MOV	HI(AC1 << #0), *SP(#2)
	SFTS	AC0, T3
	MOV	mmap(T3), AC1
	NEG	AC1
	ADD	*SP(#4), AC1
	MOV	AC1 << #0, *SP(#3)

;----------------------------------------------------------------
; Remove upper most bit as this becomes an implicit 1
; 2^exp * (1.f) where f is mantissa
;----------------------------------------------------------------

	MOV40	dbl(*SP(#0)), AC1
	AND	AC1, AC0
;	SFTSC	AC0, #-7
	MOV	*SP(#3) << #7, AC1
	OR	*SP(#2), AC1
	SFTSC	AC0, #-7
	MOV	*(#(11)) << #16, AC1
	OR	AC1, AC0

zero:
store_result:
	MOV	AC0, dbl(*AR1+)
	MOV	*AR0+ << #16, AC0

end_loop:

;----------------------------------------------------------------
; Return to calling program.
;----------------------------------------------------------------

Epilogue:
	
	MOV	#0, T0
	
	XCCPART	check, overflow(AC0)
	||MOV	#1, T0

	AADD	#7, SP
check:

	BSET	SXMD	

	RET	




rand16.asm/     1161799794  0     0     0       3102      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Filename:	rand16.asm
; Processor:   C55xx
; Description: Generates 16 bit random numbers
;
; Useage: ushort oflag= rand16(DATA *r, ushort nr)
;                                                              
; Copyright Texas instruments Inc, 2000
;**************************************************************** 		
;
; Use memory mapped register mnemonics
;-----------------------------------------------------------------------------
			.mmregs

;-----------------------------------------------------------------------------
; Define constants used in the random number generation algorithm
;-----------------------------------------------------------------------------
                                    
RNDMULT		.set	31821					; Multiplier value
RNDINC		.set	13849					; Increment value     
			
;-----------------------------------------------------------------------------
; Initialize Random Number Generator -	Load the SEED value
;-----------------------------------------------------------------------------
        	.ref	rndseed                 ; Global variable initialized in
        									; randinit()
			.def	_rand16
			.text

_rand16: 
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)
			AND		#0F9DFh,mmap(@ST1_55) 	; Clear M40, SATD and C54CM
		

			BCLR	ACOV0,ST0_55          	; Clear AC0 overflow flag 
		
			BCLR	SMUL,ST3_55			  	; Clear SMUL bit  

                                    		
			BSET	SXMD,ST1_55			  	; Set SXMD    
		
			BCLR	AR0LC,ST2_55		 	; Set AR0 in linear mode	
								  
  		
			  	   
			SUB		#1,T0                	; Set up count to 'nr-1'	
			
	   
		    MOV		T0,BRC0		    	 	; Store number of vector
										  	; elements in repeat cntr  
	    ||  MOV		#RNDMULT,T1			  	; Initialize register with
										 	; constant	    	     						               		      			
	   										  
		    MOV		#RNDINC,AC1		      	; Initialize register with
										  	; constant  
	        
    		

			MACM	*abs16(#rndseed),T1,AC1,AC0	
										                     
	        MOV		#0,T0                 	; Clear flag for returning overflow 
	        							  	; status              									  		 
	        RPTBLOCAL loop_end       
	        
	        MOV		AC0, *AR0		      	; Store random number in array
loop_end:    	
			MACM    T3=*AR0+,T1,AC1,AC0	  	; Generate new random number
	        
	        MOV		T3,*abs16(#rndseed)  	; Store final result as random seed 
	        
	        XCC	    set_flag, overflow(AC0) ; Test AC0 overflow flag
	
set_flag:	MOV		#1,T0                 	; If overflow, set return flag		

      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
			RET                    
;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
    

rand16i.asm/    1161799799  0     0     0       1701      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Filename:	rand16init.asm
; Processor:   C55xx
; Description: Initializes seed for 16 bit random number generation routine
; Useage: void rand16init(void)
;                                                              
; Copyright Texas instruments Inc, 2000
;****************************************************************
;-----------------------------------------------------------------------------
; Use memory mapped register mnemonics
;-----------------------------------------------------------------------------

			.mmregs

;-----------------------------------------------------------------------------
; Reserve space in DATA memory for seed 
;-----------------------------------------------------------------------------
	 		.bss rndseed,1 
 			.def rndseed
		
;-----------------------------------------------------------------------------
; Define constants used in the random number generation algorithm
;-----------------------------------------------------------------------------

RNDSEED 	.set  1     			; seed value (i.e. rndnum(1) = 21845)

;-----------------------------------------------------------------------------
; Initialize Random Number Generator -	Load the SEED value
;-----------------------------------------------------------------------------

			.def	_rand16init
			.text

_rand16init:

		MOV		#RNDSEED, *(rndseed)

		RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

	

recip16.asm/    1161799805  0     0     0       6700      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    recip16
; Processor:   C55xx
; Description: Calculates reciprocal of Q15 number. C-callable.
;
; Useage: void recip16 (DATA *x, DATA *z, DATA *zexp, ushort nx)
;
;
; History:
;         07/07/2003 - fixed bug in range test 
; Copyright Texas instruments Inc, 2000
;****************************************************************
;  Description:
;
;     This routine returns the fractional and exponential portion
;  of the reciprocal of a Q15 number. Since the reciprocal is always
;  greater than 1, it returns an exponent such that:
;          
;               z[i] * zexp[i] = reciprocal
;
;----------------------------------------------------------------
;  Algorithm:
;
;	     +--------------------------+
;	     |	Ym = 2*Ym - Ym^2*Xnorm 	| 		 
;	     +--------------------------+
;
;	If we start with an initial estimate of Ym, then equation
;	will converge to a solution very rapidly (typically
;	3 iterations for 16-bit resolution).
;
;	The initial estimate can either be obtained from a look up 
;	table, or from choosing a mid-point, or simply from linear 
;	interpolation. The method chosen for this problem is the
;	latter. This is simply accomplished by taking the complement
;	of the least significant bits of the Xnorm value.
;
; Copyright Texas instruments Inc, 2000
;----------------------------------------------------------------
; Revision History:
; 1.01  A. Jaffe  1/25/99 - Updated register usage using previous work 
; by Alex Tessarolo and Jeff Axelrod.
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, z_ptr           ;linear pointer
      .asg     AR2, zexp_ptr        ;linear pointer
      .asg     T0, norm_ptr	    ;temp linear pointer
      .asg     AR3, ye_ptr	    ;table linear pointer
      	     
      
      .asg     BRC0, outer_cnt      ;outer loop count

     

ST2mask  .set  0000000000000000b    ;circular/linear pointers


      .global _recip16
      
      .text
_recip16:

        PSH	mmap(ST3_55)
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all ACOVx, TC1, TC2, C
	
	OR	#04100h, mmap(ST1_55)	;set CPL, SXMD

	AND #0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; z pointer - passed in its destination register, need do nothing
      
; zexp  pointer - passed in its destination register, need do nothing



; Set circular/linear ARx behavior

	OR	#ST2mask, mmap(ST2_55)	;configure circ/linear pointers

;
; Setup loop counts
;----------------------------------------------------------------

	MOV	#1, BRC1		;repeat inner loop 2x

	SUB	#1, T0			;T0=n-1
	MOV	T0, outer_cnt		;outer loop executes n times

;
; Start of outer loop
;----------------------------------------------------------------

	RPTB	loop1			;start the outer loop
	MOV	*x_ptr+ <<#16, AC1	;load first input value
	MANT	AC1, AC0	;calculate normalization for 1st vlaue
	::NEXP	AC1, T1
	NEG	T1		;exponent value for offset pointer
	ADD	#1, T1, ye_ptr		;offset pointer to exponent
	MOV	HI(AC0), norm_ptr	;store xnorm
	||SFTS	AC0 ,#-1	;shift right by 1 for 1st approximation
	XOR	#1FFFh << #16, AC0	;estimate the first Ym value
	MOV	HI(AC0), *z_ptr		;store first Ym

; First two iterations		Calculate Ym = 2*Ym - Ym^2*X

	||RPTBLOCAL	loop2		;start of inner loop	
	MOV	*z_ptr << #15, AC0
	||MOV	*z_ptr, T1
	MPYM	*z_ptr, norm_ptr, AC1
	MOV	HI(AC1 << #1), *z_ptr
	MPYM	*z_ptr, T1, AC1
	SUB	AC1 << #1, AC0
	MOV	HI(AC0 << #2), *z_ptr
loop2:					;end of inner loop	

; final iteration - same as previous loop without final command
; Calculate Ym = 2*Ym - Ym^2*X

	MOV	*z_ptr << #15, AC0
	||MOV	*z_ptr, T1
	MPYM	*z_ptr, norm_ptr, AC1
	MOV	HI(AC1 << #1), *z_ptr
	MPYM	*z_ptr, T1, AC1
	SUB	AC1 << #1, AC0

;-------------------------------------------------------------------------
; Check if value is in range 8000h <= Ym <= 7fffh, Adjust sign of result
;-------------------------------------------------------------------------
	BSET SATD
	SFTS    AC0, #3 
	BCLR SATD
	
	MOV	#1, AC2
	MOV	ye_ptr, T1
	MOV	HI(AC0), *z_ptr+
	SFTL	AC2, T1, AC1			;calculate exponent value
	MOV	AC1, *zexp_ptr+			;store exponent
loop1:						;end of outer loop

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)		;clear CDPLC and AR[0-7]LC

	BSET	ARMS				;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

       POP	mmap(ST3_55)

;
; Return to calling function
;----------------------------------------------------------------

	RET				;return to calling function
	;End of file
sine.asm/       1161799810  0     0     0       3543      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    sine
; Processor:   C55x
; Description: Sine vector generation using polynomial evaluation.
;              C-callable
; History:	   07/07/2003 - d. elam fixed bug in q4.12 -> q1.15 conversion
; Copyright Texas instruments Inc, 1999
;****************************************************************

	 .CPL_on
 	.mmregs
	.asg	ar0, ar_x			;input vector
	.asg	ar1, ar_r			;output vector	
	.asg	ar5, ar_coeff		;pointer to coefficient table
	.asg	ar6, ar_coefftable	

;****************************************************************
	.def	_sine
	.text

_sine

      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  

; Set status registers and get arguments 
; --------------------------------------

	BSET	CPL	      ;set CPL
	BSET	FRCT		;set FRCT
	BSET	ACOV0		;set OVM
	BSET	SXMD		;set SXMD
	BSET 	SATD
	
	BCLR 	M40			;reset M40

	PSH   T2,T3
	PSHBOTH	XAR5		
	PSHBOTH	XAR6

	SUB	#1, T0, T2	;no: of inputes(AR2) - 1
	MOV	T2, BRC0	;block repeat counter set to inputs -1
    nop
	AMOV	#coeffs, XAR6	;pointer to coefficient table
	MOV XAR6, XAR5
	RPTB	loop-1

; If angle in 2nd and 4th quadrant then negate the result before removing
; sign bit
; -----------------------------------------------------------------------

	BTST	#14, *ar_x, TC1		;TC1=bit 14 of input

	MOV	*ar_x, AC0		;1st input(sign extended) in accumulator
	
	||MOV	ar_coefftable, ar_coeff	;initialize ar_coeff to beginning of table

        XCC     check1, TC1             ;if bit 14 is 1, negate and it in AC0
	NEG	AC0			;AC0 = -x
check1:
	AND 	#7FFFh, AC0		;remove sign bit from -x

; Start polynomial evaluation
; ---------------------------

	MOV	AC0, T3			;T3 = x
	||MOV	*ar_coeff+ <<#16, AC0	;AC0(high bits) = c5
	MOV	*ar_coeff+ <<#16, AC3	;AC3(high bits) = c4

	||BTST	#15, *ar_x+, TC1

	MOV	*ar_coeff+ <<#16, AC3
	||MACR AC0, T3, AC3, AC0

	MOV	*ar_coeff+ <<#16, AC3
	||MACR AC0, T3, AC3, AC0

	MOV	*ar_coeff+ <<#16, AC3
	||MACR AC0, T3, AC3, AC0

	MOV	*ar_coeff+ <<#16, AC3
	||MACR AC0, T3, AC3, AC0

	MACR AC0, T3, AC3, AC0

;changing the result from q4.12 to q1.15 format
; ---------------------------------------------		
        SFTS    AC0, #3  
			

; If angle in 3rd and 4th quadrant (negative angle), negate the result
; ---------------------------------------------------------------------

        XCC     check2, TC1
	NEG	AC0	
check2:
	MOV	HI(AC0), *ar_r+

loop:

; Return overflow flag
; --------------------

    .if  $isdefed("SI_BUGS")
	MOV	#0, T0	
	XCC  check3, overflow(AC0)	;clears ACOV0
	.else
	MOV	#0, T0	
	||XCCPART  check3, overflow(AC0)	;clears ACOV0
	.endif
	MOV	#1, T0				;overflow occured

; POP registers off stack and restore c environment
;--------------------------------------------------
check3:
	POPBOTH	XAR6
	POPBOTH	XAR5
	POP         T2,T3

	POP	mmap(ST2_55)
	POP	mmap(ST1_55)
      POP	mmap(ST0_55)
      
	
	RET

; Coefficient table for polynomial evaluation

	.data				;hex values in q4.12 format
coeffs:
	.word	0x1CCE			;1.800293	(coeff for x^5 = c5)
	.word	0x08B7			;0.5446778 	(coeff for x^4 = c4)
	.word	0xAACC			;-5.325196	(coeff for x^3 = c3)
	.word	0x0053			;0.02026367	(coeff for x^2 = c2)
	.word	0x3240			;3.140625	(coeff for x^1 = c1)
	.word	0x0000			;0		(coeff for x^0 = 0)

sqrtv.asm/      1161799815  0     0     0       4760      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Note: a symbol "SI_BUGS" is used to make a work around for silicon
; 5510 version1.0. If you are going to use the code on 5510 version1.0
; silicon, you have to put switch -d"SI_BUGS" when you compile the code.
;***************************************************************
; Function :	sqrtv
; Processor:	C55x
; Description:   Square root of a 16-bit number
;		C-callable
; Copyright Texas instruments Inc, 2000
; History:
;		- Li Yuan 01/30/2002
; 		  fixed the bug where NX should be stored in register T0 instead of AR2.
; 		  fixed code to work in large block memory by correct XAR loading.
;       
;****************************************************************

	.CPL_on
	.mmregs 
	.def	_sqrt_16
_sqrt_16:


; Set Number Of Iterations of Sqrt Algorithm (N=5)
;------------------------------------------------
	MOV	#4, BRC1	;inner loop counter set to no: of iterations-1
		

; assign registers and set status bits
;-------------------------------------
	.asg AR4, AR_TBL
	.asg XAR4, XAR_TBL
	.asg AR0, AR_X		;input vector
	.asg AR1, AR_R		;output vector
	.asg AR5, AR_HEX5E00
	.asg BRC0, AR_N		;outer block repeat counter


	.asg 0, SP_ONE
	.asg 1, SP_XNORM
	
	PSHBOTH	XAR5
	PSHBOTH	XAR6
	PSH        T2, T3

	AADD	#-2, SP

; N=N-1
;------
				
;	SUB	#1, AR2, T2	;no: of inputs-1
	SUB	#1, T0, T2	;no: of inputs-1
	MOV	T2, AR_N	;Block repeat counter set to no: of inputs-1
	
; Initialize constants
;---------------------
	  				 	
	MOV	#05E00h, AR_HEX5E00
;	MOV	#SqrtTable, AR6   	;initialize square root lookup table
	AMOV	#SqrtTable, XAR6   	;initialize square root lookup table
      
	RPTB	loop1-1 		
	MOV	#01h, *sp(SP_ONE) 	; value to round the input

; Get next input value in array, x
; and round input value by adding 0x8000
;----------------------------------------------------------------

	MOV	*AR_X+ << #16, AC0	;load the input to AC0, shift left by 16 bits
	ADD	*sp(SP_ONE)<<#15, AC0	;round the input 
	 
; Normalize input value
;----------------------
	
	MANT	AC0, AC0
	::NEXP	AC0, T3		;normalize the input

	NEG	T3		;since the previous instruction gives the 
	;NOP			;negative of the exponent, negate it
	

; Use lookup table to find SQRT of exponent
; lookup table index == exponent
;------------------------------------------
;	||MOV	AR6, AC1			;AC1 points to sqrt table
	MOV	XAR6, AC1			;AC1 points to sqrt table
	ADD	T3, AC1   			;add	the exponent 				
	MOV	AC1, XAR_TBL      		;AR_TBL=exp+SqrtTable

	MOV	AR_HEX5E00, *AR_R    		; Initial value for Ynorm
;	||MOV	AR_HEX5E00, *AR_R    		; Initial value for Ynorm
	MOV	HI(AC0), *sp(SP_XNORM)   


; Load normalized estimate of square root
; Ynorm(new) = Ynorm(old) - (Ynorm(old)^2 - Xnorm)/2
;---------------------------------------------------
        
	RPTBLOCAL	loop2-1			; do 5 iterations
	
	MOV	*sp(SP_XNORM) << #15, AC0   
	SQSM	T3 = *AR_R, AC0 
	    
	ADD	*AR_R <<#16, AC0         
	MOV	HI(AC0), *AR_R         
	   
loop2:					;inner loop ends here

; Multiply sqrt(Ynorm) * sqrt(normalized_exponent)
; And round the result
;-------------------------------------------------

	MPYM	*AR_R, *AR_TBL, AC0  
	ADD	*sp(SP_ONE)<< #15, AC0   
	MOV	HI(AC0<<#1), *AR_R+        	; Store result in AR_R

loop1: 					;outer loop ends here
	
;Return overflow flag
;---------------------
    .if  $isdefed("SI_BUGS")
	MOV	#0, T0
	XCC	check1, overflow(AC0)
    .else
	MOV	#0, T0
	||XCCPART	check1, overflow(AC0)
	.endif
	MOV	#1, T0
check1:					

; Pop off registers and restore c environment
;--------------------------------------------

	AADD	#2, SP
      POP        T2, T3
	POPBOTH	XAR6
	POPBOTH	XAR5
	
	
;Return to calling function
;---------------------------	
	RET
	

; Square root lookup table
;-------------------------------------------------
; Ytable = 1/sqrt(2^n) values:
;
   	.data
	.def SqrtTable
SqrtTable:			
	.word	7FFFh		; 1/sqrt(2^0)  = 0.99997 
	.word	5A82h		; 1/sqrt(2^1)  = 0.70711 
	.word	4000h		; 1/sqrt(2^2)  = 0.50000 
	.word	2D41h		; 1/sqrt(2^3)  = 0.35355 
	.word	2000h		; 1/sqrt(2^4)  = 0.25000 
	.word	16A1h		; 1/sqrt(2^5)  = 0.17678
	.word	1000h		; 1/sqrt(2^6)  = 0.12500 
	.word	0B50h		; 1/sqrt(2^7)  = 0.08839
	.word	0800h		; 1/sqrt(2^8)  = 0.06250 
	.word	05A8h		; 1/sqrt(2^9)  = 0.04419 
	.word	0400h		; 1/sqrt(2^10) = 0.03125 
	.word	02D4h		; 1/sqrt(2^11) = 0.02210 
	.word	0200h		; 1/sqrt(2^12) = 0.01563 
	.word	016Ah		; 1/sqrt(2^13) = 0.01105 
	.word	0100h		; 1/sqrt(2^14) = 0.00781 
	.word	0000h	

sub.asm/        1161799820  0     0     0       5714      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function:    SUB
; Processor:   C55xx
; Description: Implements a vector sub using a single-MAC 
;              approach.  This routine is C-callable.
;
; Algorithm:   for(i=0; i<nx; i++)
;	             r(i) = x(i) - y(i); 
;
; Usage: ushort oflag = add (DATA *x,
;                             DATA *y,
;                             DATA *r,
;                             ushort nx,
;                             ushort scale)
;
; Copyright Texas instruments Inc, 2000
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, y_ptr           	;linear pointer for second input vector
	.asg     AR2, r_ptr           	;linear pointer for result vector

	.asg     BRC0, outer_cnt      	;outer loop count
	.asg     T0, oflag           	;returned value

ST2mask	.set  0000000000010010b ;circular/linear pointers


	.def _sub
	.text
_sub:

     PSH	mmap(ST3_55)

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

	AND	#001FFh, mmap(ST0_55)	;clear all AC0Vx, TC1, TC2, C

	OR	#04140h, mmap(ST1_55)	;set CPL, SXMD, FRCT

	AND	#0F9DFh, mmap(ST1_55)	;clear M40, SATD, 54CM

	AND	#07A00h, mmap(ST2_55)	;clear ARMS, RDM, CDPLC, AR[0-7]LC

	AND	#0FFDDh, mmap(ST3_55)	;clear SATA, SMUL

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------

	OR	#ST2mask, mmap(ST2_55)	;config circ/linear pointers

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#1, T0			;T0=nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) + Y(i);
; ---------------------------------------------------------------

	RPTBLOCAL	loop		;start the outer loop
	SUB	*AR0+, *AR1+, AC0	;vector add of two inputs

; ---------------------------------------------------------------
; To implement scaling:
; if(scale = #1) then AC0=AC0/2;
; otherwise *r_ptr+ = AC0
; ---------------------------------------------------------------

	XCC	loop, T1!=#0		;testing for scaling
      ||SFTA	AC0, -1			;if scale=1, AC0=AC0/2
loop:	MOV	HI(AC0), *AR2+		;end of outer loop

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	MOV	#0, oflag		;clear oflag
	XCC	check, overflow(AC0)
      ||MOV	#1, oflag		;overflow occured

check:

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

	AND	#0FE00h, mmap(ST2_55)	;clear CDPLC and AR[7-0]LC

	BSET	ARMS			;set ARMS
	BCLR	FRCT			;clear FRCT

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

     POP	mmap(ST3_55)

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)



; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------

      RET		 
		
;----------------------------------------------------------------
;End of file 
twiddle.asm/    1161799852  0     0     0       24910     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************

	.def twiddle

	.sect ".data:twiddle" 

twiddle:
        .word    32767		; cos(0)
        .word    0000		; sin(0)
        .word    0000		; cos(PI/2) 		
        .word    32767		; sin(PI/2)
        .word    23170		
        .word    23170		
        .word    -23170		
        .word    23170
        .word    30274
        .word    12540
        .word    -12540
        .word    30274
        .word    12540
        .word    30274
        .word    -30274
        .word    12540
        .word    32138
        .word    6393
        .word    -6393
        .word    32138
        .word    18205
        .word    27246
        .word    -27246
        .word    18205
        .word    27246
        .word    18205
        .word    -18205
        .word    27246
        .word    6393
        .word    32138
        .word    -32138
        .word    6393
        .word    32610
        .word    3212
        .word    -3212
        .word    32610
        .word    20788
        .word    25330
        .word    -25330
        .word    20788
        .word    28899
        .word    15447
        .word    -15447
        .word    28899
        .word    9512
        .word    31357
        .word    -31357
        .word    9512
        .word    31357
        .word    9512
        .word    -9512
        .word    31357
        .word    15447
        .word    28899
        .word    -28899
        .word    15447
        .word    25330
        .word    20788
        .word    -20788
        .word    25330
        .word    3212
        .word    32610
        .word    -32610
        .word    3212
        .word    32729
        .word    1608
        .word    -1608
        .word    32729
        .word    22006
        .word    24279
        .word    -24279
        .word    22006
        .word    29622
        .word    14010
        .word    -14010
        .word    29622
        .word    11039
        .word    30853
        .word    -30853
        .word    11039
        .word    31786
        .word    7962
        .word    -7962
        .word    31786
        .word    16846
        .word    28106
        .word    -28106
        .word    16846
        .word    26320
        .word    19520
        .word    -19520
        .word    26320
        .word    4808
        .word    32413
        .word    -32413
        .word    4808
        .word    32413
        .word    4808
        .word    -4808
        .word    32413
        .word    19520
        .word    26320
        .word    -26320
        .word    19520
        .word    28106
        .word    16846
        .word    -16846
        .word    28106
        .word    7962
        .word    31786
        .word    -31786
        .word    7962
        .word    30853
        .word    11039
        .word    -11039
        .word    30853
        .word    14010
        .word    29622
        .word    -29622
        .word    14010
        .word    24279
        .word    22006
        .word    -22006
        .word    24279
        .word    1608
        .word    32729
        .word    -32729
        .word    1608
        .word    32758
        .word    804
        .word    -804
        .word    32758
        .word    22595
        .word    23732
        .word    -23732
        .word    22595
        .word    29957
        .word    13279
        .word    -13279
        .word    29957
        .word    11793
        .word    30572
        .word    -30572
        .word    11793
        .word    31972
        .word    7180
        .word    -7180
        .word    31972
        .word    17531
        .word    27684
        .word    -27684
        .word    17531
        .word    26791
        .word    18868
        .word    -18868
        .word    26791
        .word    5602
        .word    32286
        .word    -32286
        .word    5602
        .word    32522
        .word    4011
        .word    -4011
        .word    32522
        .word    20160
        .word    25833
        .word    -25833
        .word    20160
        .word    28511
        .word    16151
        .word    -16151
        .word    28511
        .word    8740
        .word    31581
        .word    -31581
        .word    8740
        .word    31114
        .word    10279
        .word    -10279
        .word    31114
        .word    14733
        .word    29269
        .word    -29269
        .word    14733
        .word    24812
        .word    21403
        .word    -21403
        .word    24812
        .word    2411
        .word    32679
        .word    -32679
        .word    2411
        .word    32679
        .word    2411
        .word    -2411
        .word    32679
        .word    21403
        .word    24812
        .word    -24812
        .word    21403
        .word    29269
        .word    14733
        .word    -14733
        .word    29269
        .word    10279
        .word    31114
        .word    -31114
        .word    10279
        .word    31581
        .word    8740
        .word    -8740
        .word    31581
        .word    16151
        .word    28511
        .word    -28511
        .word    16151
        .word    25833
        .word    20160
        .word    -20160
        .word    25833
        .word    4011
        .word    32522
        .word    -32522
        .word    4011
        .word    32286
        .word    5602
        .word    -5602
        .word    32286
        .word    18868
        .word    26791
        .word    -26791
        .word    18868
        .word    27684
        .word    17531
        .word    -17531
        .word    27684
        .word    7180
        .word    31972
        .word    -31972
        .word    7180
        .word    30572
        .word    11793
        .word    -11793
        .word    30572
        .word    13279
        .word    29957
        .word    -29957
        .word    13279
        .word    23732
        .word    22595
        .word    -22595
        .word    23732
        .word    804
        .word    32758
        .word    -32758
        .word    804
        .word    32766
        .word    402
        .word    -402
        .word    32766
        .word    22884
        .word    23453
        .word    -23453
        .word    22884
        .word    30118
        .word    12910
        .word    -12910
        .word    30118
        .word    12167
        .word    30425
        .word    -30425
        .word    12167
        .word    32058
        .word    6787
        .word    -6787
        .word    32058
        .word    17869
        .word    27467
        .word    -27467
        .word    17869
        .word    27020
        .word    18538
        .word    -18538
        .word    27020
        .word    5998
        .word    32214
        .word    -32214
        .word    5998
        .word    32568
        .word    3612
        .word    -3612
        .word    32568
        .word    20475
        .word    25583
        .word    -25583
        .word    20475
        .word    28707
        .word    15800
        .word    -15800
        .word    28707
        .word    9127
        .word    31471
        .word    -31471
        .word    9127
        .word    31238
        .word    9896
        .word    -9896
        .word    31238
        .word    15091
        .word    29086
        .word    -29086
        .word    15091
        .word    25073
        .word    21097
        .word    -21097
        .word    25073
        .word    2811
        .word    32647
        .word    -32647
        .word    2811
        .word    32706
        .word    2009
        .word    -2009
        .word    32706
        .word    21706
        .word    24548
        .word    -24548
        .word    21706
        .word    29448
        .word    14373
        .word    -14373
        .word    29448
        .word    10660
        .word    30986
        .word    -30986
        .word    10660
        .word    31686
        .word    8351
        .word    -8351
        .word    31686
        .word    16500
        .word    28311
        .word    -28311
        .word    16500
        .word    26078
        .word    19841
        .word    -19841
        .word    26078
        .word    4410
        .word    32470
        .word    -32470
        .word    4410
        .word    32352
        .word    5205
        .word    -5205
        .word    32352
        .word    19195
        .word    26557
        .word    -26557
        .word    19195
        .word    27897
        .word    17190
        .word    -17190
        .word    27897
        .word    7571
        .word    31881
        .word    -31881
        .word    7571
        .word    30715
        .word    11417
        .word    -11417
        .word    30715
        .word    13646
        .word    29792
        .word    -29792
        .word    13646
        .word    24008
        .word    22302
        .word    -22302
        .word    24008
        .word    1206
        .word    32746
        .word    -32746
        .word    1206
        .word    32746
        .word    1206
        .word    -1206
        .word    32746
        .word    22302
        .word    24008
        .word    -24008
        .word    22302
        .word    29792
        .word    13646
        .word    -13646
        .word    29792
        .word    11417
        .word    30715
        .word    -30715
        .word    11417
        .word    31881
        .word    7571
        .word    -7571
        .word    31881
        .word    17190
        .word    27897
        .word    -27897
        .word    17190
        .word    26557
        .word    19195
        .word    -19195
        .word    26557
        .word    5205
        .word    32352
        .word    -32352
        .word    5205
        .word    32470
        .word    4410
        .word    -4410
        .word    32470
        .word    19841
        .word    26078
        .word    -26078
        .word    19841
        .word    28311
        .word    16500
        .word    -16500
        .word    28311
        .word    8351
        .word    31686
        .word    -31686
        .word    8351
        .word    30986
        .word    10660
        .word    -10660
        .word    30986
        .word    14373
        .word    29448
        .word    -29448
        .word    14373
        .word    24548
        .word    21706
        .word    -21706
        .word    24548
        .word    2009
        .word    32706
        .word    -32706
        .word    2009
        .word    32647
        .word    2811
        .word    -2811
        .word    32647
        .word    21097
        .word    25073
        .word    -25073
        .word    21097
        .word    29086
        .word    15091
        .word    -15091
        .word    29086
        .word    9896
        .word    31238
        .word    -31238
        .word    9896
        .word    31471
        .word    9127
        .word    -9127
        .word    31471
        .word    15800
        .word    28707
        .word    -28707
        .word    15800
        .word    25583
        .word    20475
        .word    -20475
        .word    25583
        .word    3612
        .word    32568
        .word    -32568
        .word    3612
        .word    32214
        .word    5998
        .word    -5998
        .word    32214
        .word    18538
        .word    27020
        .word    -27020
        .word    18538
        .word    27467
        .word    17869
        .word    -17869
        .word    27467
        .word    6787
        .word    32058
        .word    -32058
        .word    6787
        .word    30425
        .word    12167
        .word    -12167
        .word    30425
        .word    12910
        .word    30118
        .word    -30118
        .word    12910
        .word    23453
        .word    22884
        .word    -22884
        .word    23453
        .word    402
        .word    32766
        .word    -32766
        .word    402
        .word    32767
        .word    201
        .word    -201
        .word    32767
        .word    23028
        .word    23312
        .word    -23312
        .word    23028
        .word    30196
        .word    12725
        .word    -12725
        .word    30196
        .word    12354
        .word    30350
        .word    -30350
        .word    12354
        .word    32099
        .word    6590
        .word    -6590
        .word    32099
        .word    18037
        .word    27357
        .word    -27357
        .word    18037
        .word    27133
        .word    18372
        .word    -18372
        .word    27133
        .word    6195
        .word    32177
        .word    -32177
        .word    6195
        .word    32590
        .word    3412
        .word    -3412
        .word    32590
        .word    20632
        .word    25457
        .word    -25457
        .word    20632
        .word    28803
        .word    15624
        .word    -15624
        .word    28803
        .word    9319
        .word    31415
        .word    -31415
        .word    9319
        .word    31298
        .word    9704
        .word    -9704
        .word    31298
        .word    15269
        .word    28993
        .word    -28993
        .word    15269
        .word    25202
        .word    20943
        .word    -20943
        .word    25202
        .word    3012
        .word    32629
        .word    -32629
        .word    3012
        .word    32718
        .word    1809
        .word    -1809
        .word    32718
        .word    21856
        .word    24414
        .word    -24414
        .word    21856
        .word    29535
        .word    14192
        .word    -14192
        .word    29535
        .word    10850
        .word    30920
        .word    -30920
        .word    10850
        .word    31737
        .word    8157
        .word    -8157
        .word    31737
        .word    16673
        .word    28209
        .word    -28209
        .word    16673
        .word    26199
        .word    19681
        .word    -19681
        .word    26199
        .word    4609
        .word    32442
        .word    -32442
        .word    4609
        .word    32383
        .word    5007
        .word    -5007
        .word    32383
        .word    19358
        .word    26439
        .word    -26439
        .word    19358
        .word    28002
        .word    17018
        .word    -17018
        .word    28002
        .word    7767
        .word    31834
        .word    -31834
        .word    7767
        .word    30784
        .word    11228
        .word    -11228
        .word    30784
        .word    13828
        .word    29707
        .word    -29707
        .word    13828
        .word    24144
        .word    22154
        .word    -22154
        .word    24144
        .word    1407
        .word    32738
        .word    -32738
        .word    1407
        .word    32753
        .word    1005
        .word    -1005
        .word    32753
        .word    22449
        .word    23870
        .word    -23870
        .word    22449
        .word    29875
        .word    13463
        .word    -13463
        .word    29875
        .word    11605
        .word    30644
        .word    -30644
        .word    11605
        .word    31927
        .word    7376
        .word    -7376
        .word    31927
        .word    17361
        .word    27791
        .word    -27791
        .word    17361
        .word    26674
        .word    19032
        .word    -19032
        .word    26674
        .word    5404
        .word    32319
        .word    -32319
        .word    5404
        .word    32496
        .word    4211
        .word    -4211
        .word    32496
        .word    20001
        .word    25956
        .word    -25956
        .word    20001
        .word    28411
        .word    16326
        .word    -16326
        .word    28411
        .word    8546
        .word    31634
        .word    -31634
        .word    8546
        .word    31050
        .word    10469
        .word    -10469
        .word    31050
        .word    14553
        .word    29359
        .word    -29359
        .word    14553
        .word    24680
        .word    21555
        .word    -21555
        .word    24680
        .word    2210
        .word    32693
        .word    -32693
        .word    2210
        .word    32664
        .word    2611
        .word    -2611
        .word    32664
        .word    21251
        .word    24943
        .word    -24943
        .word    21251
        .word    29178
        .word    14912
        .word    -14912
        .word    29178
        .word    10088
        .word    31177
        .word    -31177
        .word    10088
        .word    31527
        .word    8933
        .word    -8933
        .word    31527
        .word    15976
        .word    28610
        .word    -28610
        .word    15976
        .word    25708
        .word    20318
        .word    -20318
        .word    25708
        .word    3812
        .word    32546
        .word    -32546
        .word    3812
        .word    32251
        .word    5800
        .word    -5800
        .word    32251
        .word    18703
        .word    26906
        .word    -26906
        .word    18703
        .word    27576
        .word    17700
        .word    -17700
        .word    27576
        .word    6983
        .word    32015
        .word    -32015
        .word    6983
        .word    30499
        .word    11980
        .word    -11980
        .word    30499
        .word    13095
        .word    30038
        .word    -30038
        .word    13095
        .word    23593
        .word    22740
        .word    -22740
        .word    23593
        .word    603
        .word    32762
        .word    -32762
        .word    603
        .word    32762
        .word    603
        .word    -603
        .word    32762
        .word    22740
        .word    23593
        .word    -23593
        .word    22740
        .word    30038
        .word    13095
        .word    -13095
        .word    30038
        .word    11980
        .word    30499
        .word    -30499
        .word    11980
        .word    32015
        .word    6983
        .word    -6983
        .word    32015
        .word    17700
        .word    27576
        .word    -27576
        .word    17700
        .word    26906
        .word    18703
        .word    -18703
        .word    26906
        .word    5800
        .word    32251
        .word    -32251
        .word    5800
        .word    32546
        .word    3812
        .word    -3812
        .word    32546
        .word    20318
        .word    25708
        .word    -25708
        .word    20318
        .word    28610
        .word    15976
        .word    -15976
        .word    28610
        .word    8933
        .word    31527
        .word    -31527
        .word    8933
        .word    31177
        .word    10088
        .word    -10088
        .word    31177
        .word    14912
        .word    29178
        .word    -29178
        .word    14912
        .word    24943
        .word    21251
        .word    -21251
        .word    24943
        .word    2611
        .word    32664
        .word    -32664
        .word    2611
        .word    32693
        .word    2210
        .word    -2210
        .word    32693
        .word    21555
        .word    24680
        .word    -24680
        .word    21555
        .word    29359
        .word    14553
        .word    -14553
        .word    29359
        .word    10469
        .word    31050
        .word    -31050
        .word    10469
        .word    31634
        .word    8546
        .word    -8546
        .word    31634
        .word    16326
        .word    28411
        .word    -28411
        .word    16326
        .word    25956
        .word    20001
        .word    -20001
        .word    25956
        .word    4211
        .word    32496
        .word    -32496
        .word    4211
        .word    32319
        .word    5404
        .word    -5404
        .word    32319
        .word    19032
        .word    26674
        .word    -26674
        .word    19032
        .word    27791
        .word    17361
        .word    -17361
        .word    27791
        .word    7376
        .word    31927
        .word    -31927
        .word    7376
        .word    30644
        .word    11605
        .word    -11605
        .word    30644
        .word    13463
        .word    29875
        .word    -29875
        .word    13463
        .word    23870
        .word    22449
        .word    -22449
        .word    23870
        .word    1005
        .word    32753
        .word    -32753
        .word    1005
        .word    32738
        .word    1407
        .word    -1407
        .word    32738
        .word    22154
        .word    24144
        .word    -24144
        .word    22154
        .word    29707
        .word    13828
        .word    -13828
        .word    29707
        .word    11228
        .word    30784
        .word    -30784
        .word    11228
        .word    31834
        .word    7767
        .word    -7767
        .word    31834
        .word    17018
        .word    28002
        .word    -28002
        .word    17018
        .word    26439
        .word    19358
        .word    -19358
        .word    26439
        .word    5007
        .word    32383
        .word    -32383
        .word    5007
        .word    32442
        .word    4609
        .word    -4609
        .word    32442
        .word    19681
        .word    26199
        .word    -26199
        .word    19681
        .word    28209
        .word    16673
        .word    -16673
        .word    28209
        .word    8157
        .word    31737
        .word    -31737
        .word    8157
        .word    30920
        .word    10850
        .word    -10850
        .word    30920
        .word    14192
        .word    29535
        .word    -29535
        .word    14192
        .word    24414
        .word    21856
        .word    -21856
        .word    24414
        .word    1809
        .word    32718
        .word    -32718
        .word    1809
        .word    32629
        .word    3012
        .word    -3012
        .word    32629
        .word    20943
        .word    25202
        .word    -25202
        .word    20943
        .word    28993
        .word    15269
        .word    -15269
        .word    28993
        .word    9704
        .word    31298
        .word    -31298
        .word    9704
        .word    31415
        .word    9319
        .word    -9319
        .word    31415
        .word    15624
        .word    28803
        .word    -28803
        .word    15624
        .word    25457
        .word    20632
        .word    -20632
        .word    25457
        .word    3412
        .word    32590
        .word    -32590
        .word    3412
        .word    32177
        .word    6195
        .word    -6195
        .word    32177
        .word    18372
        .word    27133
        .word    -27133
        .word    18372
        .word    27357
        .word    18037
        .word    -18037
        .word    27357
        .word    6590
        .word    32099
        .word    -32099
        .word    6590
        .word    30350
        .word    12354
        .word    -12354
        .word    30350
        .word    12725
        .word    30196
        .word    -30196
        .word    12725
        .word    23312
        .word    23028
        .word    -23028
        .word    23312
        .word    201
        .word    32767
        .word    -32767
        .word    201
twiddle32.asm/  1161799831  0     0     0       78439     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************

	.def twiddle32

	.sect ".data:twiddle32" 


twiddle32:

 .long 0x7fffffff  ; [0]; 1.000000
 .long 0x00000000  ; [0]; 0.000000
 .long 0x00000000  ; [512]; 0.000000
 .long 0x7fffffff  ; [512]; 1.000000
 .long 0x5a827999  ; [256]; 0.707107
 .long 0x5a827999  ; [256]; 0.707107
 .long 0xa57d8668  ; [768]; -0.707107
 .long 0x5a827999  ; [768]; 0.707107
 .long 0x7641af3c  ; [128]; 0.923880
 .long 0x30fbc54d  ; [128]; 0.382683
 .long 0xcf043ab4  ; [640]; -0.382683
 .long 0x7641af3c  ; [640]; 0.923880
 .long 0x30fbc54d  ; [384]; 0.382683
 .long 0x7641af3c  ; [384]; 0.923880
 .long 0x89be50c5  ; [896]; -0.923880
 .long 0x30fbc54d  ; [896]; 0.382683
 .long 0x7d8a5f3f  ; [64]; 0.980785
 .long 0x18f8b83c  ; [64]; 0.195090
 .long 0xe70747c5  ; [576]; -0.195090
 .long 0x7d8a5f3f  ; [576]; 0.980785
 .long 0x471cece6  ; [320]; 0.555570
 .long 0x6a6d98a3  ; [320]; 0.831470
 .long 0x9592675e  ; [832]; -0.831470
 .long 0x471cece6  ; [832]; 0.555570
 .long 0x6a6d98a3  ; [192]; 0.831470
 .long 0x471cece6  ; [192]; 0.555570
 .long 0xb8e3131b  ; [704]; -0.555570
 .long 0x6a6d98a3  ; [704]; 0.831470
 .long 0x18f8b83c  ; [448]; 0.195090
 .long 0x7d8a5f3f  ; [448]; 0.980785
 .long 0x8275a0c2  ; [960]; -0.980785
 .long 0x18f8b83c  ; [960]; 0.195090
 .long 0x7f62368e  ; [32]; 0.995185
 .long 0x0c8bd35e  ; [32]; 0.098017
 .long 0xf3742ca3  ; [544]; -0.098017
 .long 0x7f62368e  ; [544]; 0.995185
 .long 0x5133cc94  ; [288]; 0.634393
 .long 0x62f201ac  ; [288]; 0.773010
 .long 0x9d0dfe55  ; [800]; -0.773010
 .long 0x5133cc94  ; [800]; 0.634393
 .long 0x70e2cbc5  ; [160]; 0.881921
 .long 0x3c56ba70  ; [160]; 0.471397
 .long 0xc3a94591  ; [672]; -0.471397
 .long 0x70e2cbc5  ; [672]; 0.881921
 .long 0x25280c5d  ; [416]; 0.290285
 .long 0x7a7d055a  ; [416]; 0.956940
 .long 0x8582faa7  ; [928]; -0.956940
 .long 0x25280c5d  ; [928]; 0.290285
 .long 0x7a7d055a  ; [96]; 0.956940
 .long 0x25280c5d  ; [96]; 0.290285
 .long 0xdad7f3a4  ; [608]; -0.290285
 .long 0x7a7d055a  ; [608]; 0.956940
 .long 0x3c56ba70  ; [352]; 0.471397
 .long 0x70e2cbc5  ; [352]; 0.881921
 .long 0x8f1d343c  ; [864]; -0.881921
 .long 0x3c56ba70  ; [864]; 0.471397
 .long 0x62f201ac  ; [224]; 0.773010
 .long 0x5133cc94  ; [224]; 0.634393
 .long 0xaecc336d  ; [736]; -0.634393
 .long 0x62f201ac  ; [736]; 0.773010
 .long 0x0c8bd35e  ; [480]; 0.098017
 .long 0x7f62368e  ; [480]; 0.995185
 .long 0x809dc973  ; [992]; -0.995185
 .long 0x0c8bd35e  ; [992]; 0.098017
 .long 0x7fd8878d  ; [16]; 0.998795
 .long 0x0647d97c  ; [16]; 0.049068
 .long 0xf9b82685  ; [528]; -0.049068
 .long 0x7fd8878d  ; [528]; 0.998795
 .long 0x55f5a4d2  ; [272]; 0.671559
 .long 0x5ed77c89  ; [272]; 0.740951
 .long 0xa1288378  ; [784]; -0.740951
 .long 0x55f5a4d2  ; [784]; 0.671559
 .long 0x73b5ebd0  ; [144]; 0.903989
 .long 0x36ba2013  ; [144]; 0.427555
 .long 0xc945dfee  ; [656]; -0.427555
 .long 0x73b5ebd0  ; [656]; 0.903989
 .long 0x2b1f34eb  ; [400]; 0.336890
 .long 0x78848413  ; [400]; 0.941544
 .long 0x877b7bee  ; [912]; -0.941544
 .long 0x2b1f34eb  ; [912]; 0.336890
 .long 0x7c29fbed  ; [80]; 0.970031
 .long 0x1f19f97b  ; [80]; 0.242980
 .long 0xe0e60686  ; [592]; -0.242980
 .long 0x7c29fbed  ; [592]; 0.970031
 .long 0x41ce1e64  ; [336]; 0.514103
 .long 0x6dca0d14  ; [336]; 0.857729
 .long 0x9235f2ed  ; [848]; -0.857729
 .long 0x41ce1e64  ; [848]; 0.514103
 .long 0x66cf811f  ; [208]; 0.803208
 .long 0x4c3fdff3  ; [208]; 0.595699
 .long 0xb3c0200e  ; [720]; -0.595699
 .long 0x66cf811f  ; [720]; 0.803208
 .long 0x12c8106e  ; [464]; 0.146730
 .long 0x7e9d55fb  ; [464]; 0.989177
 .long 0x8162aa06  ; [976]; -0.989177
 .long 0x12c8106e  ; [976]; 0.146730
 .long 0x7e9d55fb  ; [48]; 0.989177
 .long 0x12c8106e  ; [48]; 0.146730
 .long 0xed37ef93  ; [560]; -0.146730
 .long 0x7e9d55fb  ; [560]; 0.989177
 .long 0x4c3fdff3  ; [304]; 0.595699
 .long 0x66cf811f  ; [304]; 0.803208
 .long 0x99307ee2  ; [816]; -0.803208
 .long 0x4c3fdff3  ; [816]; 0.595699
 .long 0x6dca0d14  ; [176]; 0.857729
 .long 0x41ce1e64  ; [176]; 0.514103
 .long 0xbe31e19d  ; [688]; -0.514103
 .long 0x6dca0d14  ; [688]; 0.857729
 .long 0x1f19f97b  ; [432]; 0.242980
 .long 0x7c29fbed  ; [432]; 0.970031
 .long 0x83d60414  ; [944]; -0.970031
 .long 0x1f19f97b  ; [944]; 0.242980
 .long 0x78848413  ; [112]; 0.941544
 .long 0x2b1f34eb  ; [112]; 0.336890
 .long 0xd4e0cb16  ; [624]; -0.336890
 .long 0x78848413  ; [624]; 0.941544
 .long 0x36ba2013  ; [368]; 0.427555
 .long 0x73b5ebd0  ; [368]; 0.903989
 .long 0x8c4a1431  ; [880]; -0.903989
 .long 0x36ba2013  ; [880]; 0.427555
 .long 0x5ed77c89  ; [240]; 0.740951
 .long 0x55f5a4d2  ; [240]; 0.671559
 .long 0xaa0a5b2f  ; [752]; -0.671559
 .long 0x5ed77c89  ; [752]; 0.740951
 .long 0x0647d97c  ; [496]; 0.049068
 .long 0x7fd8878d  ; [496]; 0.998795
 .long 0x80277874  ; [1008]; -0.998795
 .long 0x0647d97c  ; [1008]; 0.049068
 .long 0x7ff62181  ; [8]; 0.999699
 .long 0x03242abf  ; [8]; 0.024541
 .long 0xfcdbd542  ; [520]; -0.024541
 .long 0x7ff62181  ; [520]; 0.999699
 .long 0x5842dd54  ; [264]; 0.689541
 .long 0x5cb420df  ; [264]; 0.724247
 .long 0xa34bdf22  ; [776]; -0.724247
 .long 0x5842dd54  ; [776]; 0.689541
 .long 0x7504d344  ; [136]; 0.914210
 .long 0x33def287  ; [136]; 0.405241
 .long 0xcc210d7a  ; [648]; -0.405241
 .long 0x7504d344  ; [648]; 0.914210
 .long 0x2e110a62  ; [392]; 0.359895
 .long 0x776c4eda  ; [392]; 0.932993
 .long 0x8893b127  ; [904]; -0.932993
 .long 0x2e110a62  ; [904]; 0.359895
 .long 0x7ce3ceb1  ; [72]; 0.975702
 .long 0x1c0b826a  ; [72]; 0.219101
 .long 0xe3f47d97  ; [584]; -0.219101
 .long 0x7ce3ceb1  ; [584]; 0.975702
 .long 0x447acd50  ; [328]; 0.534998
 .long 0x6c24295f  ; [328]; 0.844854
 .long 0x93dbd6a2  ; [840]; -0.844854
 .long 0x447acd50  ; [840]; 0.534998
 .long 0x68a69e80  ; [200]; 0.817585
 .long 0x49b41533  ; [200]; 0.575808
 .long 0xb64beace  ; [712]; -0.575808
 .long 0x68a69e80  ; [712]; 0.817585
 .long 0x15e21444  ; [456]; 0.170962
 .long 0x7e1d93e9  ; [456]; 0.985278
 .long 0x81e26c18  ; [968]; -0.985278
 .long 0x15e21444  ; [968]; 0.170962
 .long 0x7f0991c3  ; [40]; 0.992480
 .long 0x0fab272b  ; [40]; 0.122411
 .long 0xf054d8d6  ; [552]; -0.122411
 .long 0x7f0991c3  ; [552]; 0.992480
 .long 0x4ebfe8a4  ; [296]; 0.615232
 .long 0x64e88925  ; [296]; 0.788346
 .long 0x9b1776dc  ; [808]; -0.788346
 .long 0x4ebfe8a4  ; [808]; 0.615232
 .long 0x6f5f02b1  ; [168]; 0.870087
 .long 0x3f1749b7  ; [168]; 0.492898
 .long 0xc0e8b64a  ; [680]; -0.492898
 .long 0x6f5f02b1  ; [680]; 0.870087
 .long 0x2223a4c5  ; [424]; 0.266713
 .long 0x7b5d039d  ; [424]; 0.963776
 .long 0x84a2fc64  ; [936]; -0.963776
 .long 0x2223a4c5  ; [936]; 0.266713
 .long 0x798a23b0  ; [104]; 0.949528
 .long 0x2826b928  ; [104]; 0.313682
 .long 0xd7d946d9  ; [616]; -0.313682
 .long 0x798a23b0  ; [616]; 0.949528
 .long 0x398cdd32  ; [360]; 0.449611
 .long 0x72552c84  ; [360]; 0.893224
 .long 0x8daad37d  ; [872]; -0.893224
 .long 0x398cdd32  ; [872]; 0.449611
 .long 0x60ec382f  ; [232]; 0.757209
 .long 0x539b2aef  ; [232]; 0.653173
 .long 0xac64d512  ; [744]; -0.653173
 .long 0x60ec382f  ; [744]; 0.757209
 .long 0x096a9049  ; [488]; 0.073565
 .long 0x7fa736b3  ; [488]; 0.997290
 .long 0x8058c94e  ; [1000]; -0.997290
 .long 0x096a9049  ; [1000]; 0.073565
 .long 0x7fa736b3  ; [24]; 0.997290
 .long 0x096a9049  ; [24]; 0.073565
 .long 0xf6956fb8  ; [536]; -0.073565
 .long 0x7fa736b3  ; [536]; 0.997290
 .long 0x539b2aef  ; [280]; 0.653173
 .long 0x60ec382f  ; [280]; 0.757209
 .long 0x9f13c7d2  ; [792]; -0.757209
 .long 0x539b2aef  ; [792]; 0.653173
 .long 0x72552c84  ; [152]; 0.893224
 .long 0x398cdd32  ; [152]; 0.449611
 .long 0xc67322cf  ; [664]; -0.449611
 .long 0x72552c84  ; [664]; 0.893224
 .long 0x2826b928  ; [408]; 0.313682
 .long 0x798a23b0  ; [408]; 0.949528
 .long 0x8675dc51  ; [920]; -0.949528
 .long 0x2826b928  ; [920]; 0.313682
 .long 0x7b5d039d  ; [88]; 0.963776
 .long 0x2223a4c5  ; [88]; 0.266713
 .long 0xdddc5b3c  ; [600]; -0.266713
 .long 0x7b5d039d  ; [600]; 0.963776
 .long 0x3f1749b7  ; [344]; 0.492898
 .long 0x6f5f02b1  ; [344]; 0.870087
 .long 0x90a0fd50  ; [856]; -0.870087
 .long 0x3f1749b7  ; [856]; 0.492898
 .long 0x64e88925  ; [216]; 0.788346
 .long 0x4ebfe8a4  ; [216]; 0.615232
 .long 0xb140175d  ; [728]; -0.615232
 .long 0x64e88925  ; [728]; 0.788346
 .long 0x0fab272b  ; [472]; 0.122411
 .long 0x7f0991c3  ; [472]; 0.992480
 .long 0x80f66e3e  ; [984]; -0.992480
 .long 0x0fab272b  ; [984]; 0.122411
 .long 0x7e1d93e9  ; [56]; 0.985278
 .long 0x15e21444  ; [56]; 0.170962
 .long 0xea1debbd  ; [568]; -0.170962
 .long 0x7e1d93e9  ; [568]; 0.985278
 .long 0x49b41533  ; [312]; 0.575808
 .long 0x68a69e80  ; [312]; 0.817585
 .long 0x97596181  ; [824]; -0.817585
 .long 0x49b41533  ; [824]; 0.575808
 .long 0x6c24295f  ; [184]; 0.844854
 .long 0x447acd50  ; [184]; 0.534998
 .long 0xbb8532b1  ; [696]; -0.534998
 .long 0x6c24295f  ; [696]; 0.844854
 .long 0x1c0b826a  ; [440]; 0.219101
 .long 0x7ce3ceb1  ; [440]; 0.975702
 .long 0x831c3150  ; [952]; -0.975702
 .long 0x1c0b826a  ; [952]; 0.219101
 .long 0x776c4eda  ; [120]; 0.932993
 .long 0x2e110a62  ; [120]; 0.359895
 .long 0xd1eef59f  ; [632]; -0.359895
 .long 0x776c4eda  ; [632]; 0.932993
 .long 0x33def287  ; [376]; 0.405241
 .long 0x7504d344  ; [376]; 0.914210
 .long 0x8afb2cbd  ; [888]; -0.914210
 .long 0x33def287  ; [888]; 0.405241
 .long 0x5cb420df  ; [248]; 0.724247
 .long 0x5842dd54  ; [248]; 0.689541
 .long 0xa7bd22ad  ; [760]; -0.689541
 .long 0x5cb420df  ; [760]; 0.724247
 .long 0x03242abf  ; [504]; 0.024541
 .long 0x7ff62181  ; [504]; 0.999699
 .long 0x8009de80  ; [1016]; -0.999699
 .long 0x03242abf  ; [1016]; 0.024541
 .long 0x7ffd8859  ; [4]; 0.999925
 .long 0x01921d20  ; [4]; 0.012272
 .long 0xfe6de2e1  ; [516]; -0.012272
 .long 0x7ffd8859  ; [516]; 0.999925
 .long 0x59646497  ; [260]; 0.698376
 .long 0x5b9d1153  ; [260]; 0.715731
 .long 0xa462eeae  ; [772]; -0.715731
 .long 0x59646497  ; [772]; 0.698376
 .long 0x75a585ce  ; [132]; 0.919114
 .long 0x326e54c7  ; [132]; 0.393992
 .long 0xcd91ab3a  ; [644]; -0.393992
 .long 0x75a585ce  ; [644]; 0.919114
 .long 0x2f875262  ; [388]; 0.371317
 .long 0x76d94988  ; [388]; 0.928506
 .long 0x8926b679  ; [900]; -0.928506
 .long 0x2f875262  ; [900]; 0.371317
 .long 0x7d3980eb  ; [68]; 0.978317
 .long 0x1a82a025  ; [68]; 0.207111
 .long 0xe57d5fdc  ; [580]; -0.207111
 .long 0x7d3980eb  ; [580]; 0.978317
 .long 0x45cd358f  ; [324]; 0.545325
 .long 0x6b4af278  ; [324]; 0.838225
 .long 0x94b50d89  ; [836]; -0.838225
 .long 0x45cd358f  ; [836]; 0.545325
 .long 0x698c246b  ; [196]; 0.824589
 .long 0x4869e664  ; [196]; 0.565732
 .long 0xb796199d  ; [708]; -0.565732
 .long 0x698c246b  ; [708]; 0.824589
 .long 0x176dd9de  ; [452]; 0.183040
 .long 0x7dd6668e  ; [452]; 0.983105
 .long 0x82299973  ; [964]; -0.983105
 .long 0x176dd9de  ; [964]; 0.183040
 .long 0x7f3857f5  ; [36]; 0.993907
 .long 0x0e1bc2e4  ; [36]; 0.110222
 .long 0xf1e43d1d  ; [548]; -0.110222
 .long 0x7f3857f5  ; [548]; 0.993907
 .long 0x4ffb654c  ; [292]; 0.624859
 .long 0x63ef328f  ; [292]; 0.780737
 .long 0x9c10cd72  ; [804]; -0.780737
 .long 0x4ffb654c  ; [804]; 0.624859
 .long 0x70231099  ; [164]; 0.876070
 .long 0x3db832a5  ; [164]; 0.482184
 .long 0xc247cd5c  ; [676]; -0.482184
 .long 0x70231099  ; [676]; 0.876070
 .long 0x23a6887e  ; [420]; 0.278520
 .long 0x7aef6323  ; [420]; 0.960431
 .long 0x85109cde  ; [932]; -0.960431
 .long 0x23a6887e  ; [932]; 0.278520
 .long 0x7a05eeac  ; [100]; 0.953306
 .long 0x26a82185  ; [100]; 0.302006
 .long 0xd957de7c  ; [612]; -0.302006
 .long 0x7a05eeac  ; [612]; 0.953306
 .long 0x3af2eeb7  ; [356]; 0.460539
 .long 0x719e2cd1  ; [356]; 0.887640
 .long 0x8e61d330  ; [868]; -0.887640
 .long 0x3af2eeb7  ; [868]; 0.460539
 .long 0x61f1003e  ; [228]; 0.765167
 .long 0x5269126e  ; [228]; 0.643832
 .long 0xad96ed93  ; [740]; -0.643832
 .long 0x61f1003e  ; [740]; 0.765167
 .long 0x0afb6805  ; [484]; 0.085797
 .long 0x7f872bf2  ; [484]; 0.996313
 .long 0x8078d40f  ; [996]; -0.996313
 .long 0x0afb6805  ; [996]; 0.085797
 .long 0x7fc25595  ; [20]; 0.998118
 .long 0x07d95b9e  ; [20]; 0.061321
 .long 0xf826a463  ; [532]; -0.061321
 .long 0x7fc25595  ; [532]; 0.998118
 .long 0x54ca0a4a  ; [276]; 0.662416
 .long 0x5fe3b38d  ; [276]; 0.749136
 .long 0xa01c4c74  ; [788]; -0.749136
 .long 0x54ca0a4a  ; [788]; 0.662416
 .long 0x7307c3cf  ; [148]; 0.898674
 .long 0x382493b0  ; [148]; 0.438616
 .long 0xc7db6c51  ; [660]; -0.438616
 .long 0x7307c3cf  ; [660]; 0.898674
 .long 0x29a3c485  ; [404]; 0.325310
 .long 0x7909a92c  ; [404]; 0.945607
 .long 0x86f656d5  ; [916]; -0.945607
 .long 0x29a3c485  ; [916]; 0.325310
 .long 0x7bc5e28f  ; [84]; 0.966976
 .long 0x209f701c  ; [84]; 0.254866
 .long 0xdf608fe5  ; [596]; -0.254866
 .long 0x7bc5e28f  ; [596]; 0.966976
 .long 0x4073f21d  ; [340]; 0.503538
 .long 0x6e96a99c  ; [340]; 0.863973
 .long 0x91695665  ; [852]; -0.863973
 .long 0x4073f21d  ; [852]; 0.503538
 .long 0x65ddfbd2  ; [212]; 0.795837
 .long 0x4d8162c3  ; [212]; 0.605511
 .long 0xb27e9d3e  ; [724]; -0.605511
 .long 0x65ddfbd2  ; [724]; 0.795837
 .long 0x1139f0cf  ; [468]; 0.134581
 .long 0x7ed5e5c5  ; [468]; 0.990903
 .long 0x812a1a3c  ; [980]; -0.990903
 .long 0x1139f0cf  ; [980]; 0.134581
 .long 0x7e5fe492  ; [52]; 0.987301
 .long 0x145576b1  ; [52]; 0.158858
 .long 0xebaa8950  ; [564]; -0.158858
 .long 0x7e5fe492  ; [564]; 0.987301
 .long 0x4afb6c97  ; [308]; 0.585798
 .long 0x67bd0fbc  ; [308]; 0.810457
 .long 0x9842f045  ; [820]; -0.810457
 .long 0x4afb6c97  ; [820]; 0.585798
 .long 0x6cf934fb  ; [180]; 0.851355
 .long 0x4325c135  ; [180]; 0.524590
 .long 0xbcda3ecc  ; [692]; -0.524590
 .long 0x6cf934fb  ; [692]; 0.851355
 .long 0x1d934fe5  ; [436]; 0.231058
 .long 0x7c894bdd  ; [436]; 0.972940
 .long 0x8376b424  ; [948]; -0.972940
 .long 0x1d934fe5  ; [948]; 0.231058
 .long 0x77fab988  ; [116]; 0.937339
 .long 0x2c98fbba  ; [116]; 0.348419
 .long 0xd3670447  ; [628]; -0.348419
 .long 0x77fab988  ; [628]; 0.937339
 .long 0x354d9056  ; [372]; 0.416430
 .long 0x745f9dd0  ; [372]; 0.909168
 .long 0x8ba06231  ; [884]; -0.909168
 .long 0x354d9056  ; [884]; 0.416430
 .long 0x5dc79d7b  ; [244]; 0.732654
 .long 0x571deef9  ; [244]; 0.680601
 .long 0xa8e21108  ; [756]; -0.680601
 .long 0x5dc79d7b  ; [756]; 0.732654
 .long 0x04b6195d  ; [500]; 0.036807
 .long 0x7fe9cbbf  ; [500]; 0.999322
 .long 0x80163442  ; [1012]; -0.999322
 .long 0x04b6195d  ; [1012]; 0.036807
 .long 0x7fe9cbbf  ; [12]; 0.999322
 .long 0x04b6195d  ; [12]; 0.036807
 .long 0xfb49e6a4  ; [524]; -0.036807
 .long 0x7fe9cbbf  ; [524]; 0.999322
 .long 0x571deef9  ; [268]; 0.680601
 .long 0x5dc79d7b  ; [268]; 0.732654
 .long 0xa2386286  ; [780]; -0.732654
 .long 0x571deef9  ; [780]; 0.680601
 .long 0x745f9dd0  ; [140]; 0.909168
 .long 0x354d9056  ; [140]; 0.416430
 .long 0xcab26fab  ; [652]; -0.416430
 .long 0x745f9dd0  ; [652]; 0.909168
 .long 0x2c98fbba  ; [396]; 0.348419
 .long 0x77fab988  ; [396]; 0.937339
 .long 0x88054679  ; [908]; -0.937339
 .long 0x2c98fbba  ; [908]; 0.348419
 .long 0x7c894bdd  ; [76]; 0.972940
 .long 0x1d934fe5  ; [76]; 0.231058
 .long 0xe26cb01c  ; [588]; -0.231058
 .long 0x7c894bdd  ; [588]; 0.972940
 .long 0x4325c135  ; [332]; 0.524590
 .long 0x6cf934fb  ; [332]; 0.851355
 .long 0x9306cb06  ; [844]; -0.851355
 .long 0x4325c135  ; [844]; 0.524590
 .long 0x67bd0fbc  ; [204]; 0.810457
 .long 0x4afb6c97  ; [204]; 0.585798
 .long 0xb504936a  ; [716]; -0.585798
 .long 0x67bd0fbc  ; [716]; 0.810457
 .long 0x145576b1  ; [460]; 0.158858
 .long 0x7e5fe492  ; [460]; 0.987301
 .long 0x81a01b6f  ; [972]; -0.987301
 .long 0x145576b1  ; [972]; 0.158858
 .long 0x7ed5e5c5  ; [44]; 0.990903
 .long 0x1139f0cf  ; [44]; 0.134581
 .long 0xeec60f32  ; [556]; -0.134581
 .long 0x7ed5e5c5  ; [556]; 0.990903
 .long 0x4d8162c3  ; [300]; 0.605511
 .long 0x65ddfbd2  ; [300]; 0.795837
 .long 0x9a22042f  ; [812]; -0.795837
 .long 0x4d8162c3  ; [812]; 0.605511
 .long 0x6e96a99c  ; [172]; 0.863973
 .long 0x4073f21d  ; [172]; 0.503538
 .long 0xbf8c0de4  ; [684]; -0.503538
 .long 0x6e96a99c  ; [684]; 0.863973
 .long 0x209f701c  ; [428]; 0.254866
 .long 0x7bc5e28f  ; [428]; 0.966976
 .long 0x843a1d72  ; [940]; -0.966976
 .long 0x209f701c  ; [940]; 0.254866
 .long 0x7909a92c  ; [108]; 0.945607
 .long 0x29a3c485  ; [108]; 0.325310
 .long 0xd65c3b7c  ; [620]; -0.325310
 .long 0x7909a92c  ; [620]; 0.945607
 .long 0x382493b0  ; [364]; 0.438616
 .long 0x7307c3cf  ; [364]; 0.898674
 .long 0x8cf83c32  ; [876]; -0.898674
 .long 0x382493b0  ; [876]; 0.438616
 .long 0x5fe3b38d  ; [236]; 0.749136
 .long 0x54ca0a4a  ; [236]; 0.662416
 .long 0xab35f5b7  ; [748]; -0.662416
 .long 0x5fe3b38d  ; [748]; 0.749136
 .long 0x07d95b9e  ; [492]; 0.061321
 .long 0x7fc25595  ; [492]; 0.998118
 .long 0x803daa6c  ; [1004]; -0.998118
 .long 0x07d95b9e  ; [1004]; 0.061321
 .long 0x7f872bf2  ; [28]; 0.996313
 .long 0x0afb6805  ; [28]; 0.085797
 .long 0xf50497fc  ; [540]; -0.085797
 .long 0x7f872bf2  ; [540]; 0.996313
 .long 0x5269126e  ; [284]; 0.643832
 .long 0x61f1003e  ; [284]; 0.765167
 .long 0x9e0effc3  ; [796]; -0.765167
 .long 0x5269126e  ; [796]; 0.643832
 .long 0x719e2cd1  ; [156]; 0.887640
 .long 0x3af2eeb7  ; [156]; 0.460539
 .long 0xc50d114a  ; [668]; -0.460539
 .long 0x719e2cd1  ; [668]; 0.887640
 .long 0x26a82185  ; [412]; 0.302006
 .long 0x7a05eeac  ; [412]; 0.953306
 .long 0x85fa1155  ; [924]; -0.953306
 .long 0x26a82185  ; [924]; 0.302006
 .long 0x7aef6323  ; [92]; 0.960431
 .long 0x23a6887e  ; [92]; 0.278520
 .long 0xdc597783  ; [604]; -0.278520
 .long 0x7aef6323  ; [604]; 0.960431
 .long 0x3db832a5  ; [348]; 0.482184
 .long 0x70231099  ; [348]; 0.876070
 .long 0x8fdcef68  ; [860]; -0.876070
 .long 0x3db832a5  ; [860]; 0.482184
 .long 0x63ef328f  ; [220]; 0.780737
 .long 0x4ffb654c  ; [220]; 0.624859
 .long 0xb0049ab5  ; [732]; -0.624859
 .long 0x63ef328f  ; [732]; 0.780737
 .long 0x0e1bc2e4  ; [476]; 0.110222
 .long 0x7f3857f5  ; [476]; 0.993907
 .long 0x80c7a80c  ; [988]; -0.993907
 .long 0x0e1bc2e4  ; [988]; 0.110222
 .long 0x7dd6668e  ; [60]; 0.983105
 .long 0x176dd9de  ; [60]; 0.183040
 .long 0xe8922623  ; [572]; -0.183040
 .long 0x7dd6668e  ; [572]; 0.983105
 .long 0x4869e664  ; [316]; 0.565732
 .long 0x698c246b  ; [316]; 0.824589
 .long 0x9673db96  ; [828]; -0.824589
 .long 0x4869e664  ; [828]; 0.565732
 .long 0x6b4af278  ; [188]; 0.838225
 .long 0x45cd358f  ; [188]; 0.545325
 .long 0xba32ca72  ; [700]; -0.545325
 .long 0x6b4af278  ; [700]; 0.838225
 .long 0x1a82a025  ; [444]; 0.207111
 .long 0x7d3980eb  ; [444]; 0.978317
 .long 0x82c67f16  ; [956]; -0.978317
 .long 0x1a82a025  ; [956]; 0.207111
 .long 0x76d94988  ; [124]; 0.928506
 .long 0x2f875262  ; [124]; 0.371317
 .long 0xd078ad9f  ; [636]; -0.371317
 .long 0x76d94988  ; [636]; 0.928506
 .long 0x326e54c7  ; [380]; 0.393992
 .long 0x75a585ce  ; [380]; 0.919114
 .long 0x8a5a7a33  ; [892]; -0.919114
 .long 0x326e54c7  ; [892]; 0.393992
 .long 0x5b9d1153  ; [252]; 0.715731
 .long 0x59646497  ; [252]; 0.698376
 .long 0xa69b9b6a  ; [764]; -0.698376
 .long 0x5b9d1153  ; [764]; 0.715731
 .long 0x01921d20  ; [508]; 0.012272
 .long 0x7ffd8859  ; [508]; 0.999925
 .long 0x800277a8  ; [1020]; -0.999925
 .long 0x01921d20  ; [1020]; 0.012272
 .long 0x7fff6215  ; [2]; 0.999981
 .long 0x00c90f88  ; [2]; 0.006136
 .long 0xff36f079  ; [514]; -0.006136
 .long 0x7fff6215  ; [514]; 0.999981
 .long 0x59f3de12  ; [258]; 0.702755
 .long 0x5b1035ce  ; [258]; 0.711432
 .long 0xa4efca33  ; [770]; -0.711432
 .long 0x59f3de12  ; [770]; 0.702755
 .long 0x75f42c0a  ; [130]; 0.921514
 .long 0x31b54a5d  ; [130]; 0.388345
 .long 0xce4ab5a4  ; [642]; -0.388345
 .long 0x75f42c0a  ; [642]; 0.921514
 .long 0x3041c760  ; [386]; 0.377007
 .long 0x768e0ea5  ; [386]; 0.926210
 .long 0x8971f15c  ; [898]; -0.926210
 .long 0x3041c760  ; [898]; 0.377007
 .long 0x7d628ac5  ; [66]; 0.979570
 .long 0x19bdcbf3  ; [66]; 0.201105
 .long 0xe642340e  ; [578]; -0.201105
 .long 0x7d628ac5  ; [578]; 0.979570
 .long 0x46756827  ; [322]; 0.550458
 .long 0x6adcc964  ; [322]; 0.834863
 .long 0x9523369d  ; [834]; -0.834863
 .long 0x46756827  ; [834]; 0.550458
 .long 0x69fd614a  ; [194]; 0.828045
 .long 0x47c3c22e  ; [194]; 0.560662
 .long 0xb83c3dd3  ; [706]; -0.560662
 .long 0x69fd614a  ; [706]; 0.828045
 .long 0x183366e8  ; [450]; 0.189069
 .long 0x7db0fdf7  ; [450]; 0.981964
 .long 0x824f020a  ; [962]; -0.981964
 .long 0x183366e8  ; [962]; 0.189069
 .long 0x7f4de450  ; [34]; 0.994565
 .long 0x0d53db92  ; [34]; 0.104122
 .long 0xf2ac246f  ; [546]; -0.104122
 .long 0x7f4de450  ; [546]; 0.994565
 .long 0x5097fc5e  ; [290]; 0.629638
 .long 0x637114cc  ; [290]; 0.776888
 .long 0x9c8eeb35  ; [802]; -0.776888
 .long 0x5097fc5e  ; [802]; 0.629638
 .long 0x708378fe  ; [162]; 0.879012
 .long 0x3d07c1d5  ; [162]; 0.476799
 .long 0xc2f83e2c  ; [674]; -0.476799
 .long 0x708378fe  ; [674]; 0.879012
 .long 0x24677757  ; [418]; 0.284408
 .long 0x7ab6cba3  ; [418]; 0.958703
 .long 0x8549345e  ; [930]; -0.958703
 .long 0x24677757  ; [930]; 0.284408
 .long 0x7a4210d8  ; [98]; 0.955141
 .long 0x25e845b6  ; [98]; 0.296151
 .long 0xda17ba4b  ; [610]; -0.296151
 .long 0x7a4210d8  ; [610]; 0.955141
 .long 0x3ba51e29  ; [354]; 0.465976
 .long 0x71410804  ; [354]; 0.884797
 .long 0x8ebef7fd  ; [866]; -0.884797
 .long 0x3ba51e29  ; [866]; 0.465976
 .long 0x6271fa68  ; [226]; 0.769103
 .long 0x51ced46e  ; [226]; 0.639124
 .long 0xae312b93  ; [738]; -0.639124
 .long 0x6271fa68  ; [738]; 0.769103
 .long 0x0bc3ac35  ; [482]; 0.091909
 .long 0x7f754e7f  ; [482]; 0.995767
 .long 0x808ab182  ; [994]; -0.995767
 .long 0x0bc3ac35  ; [994]; 0.091909
 .long 0x7fce0c3d  ; [18]; 0.998476
 .long 0x0710a345  ; [18]; 0.055195
 .long 0xf8ef5cbc  ; [530]; -0.055195
 .long 0x7fce0c3d  ; [530]; 0.998476
 .long 0x556040e2  ; [274]; 0.667000
 .long 0x5f5e0db2  ; [274]; 0.745058
 .long 0xa0a1f24f  ; [786]; -0.745058
 .long 0x556040e2  ; [786]; 0.667000
 .long 0x735f6625  ; [146]; 0.901349
 .long 0x376f9e46  ; [146]; 0.433094
 .long 0xc89061bb  ; [658]; -0.433094
 .long 0x735f6625  ; [658]; 0.901349
 .long 0x2a61b101  ; [402]; 0.331106
 .long 0x78c7aba1  ; [402]; 0.943593
 .long 0x87385460  ; [914]; -0.943593
 .long 0x2a61b101  ; [914]; 0.331106
 .long 0x7bf8882f  ; [82]; 0.968522
 .long 0x1fdcdc1b  ; [82]; 0.248928
 .long 0xe02323e6  ; [594]; -0.248928
 .long 0x7bf8882f  ; [594]; 0.968522
 .long 0x4121589a  ; [338]; 0.508830
 .long 0x6e30e349  ; [338]; 0.860867
 .long 0x91cf1cb8  ; [850]; -0.860867
 .long 0x4121589a  ; [850]; 0.508830
 .long 0x66573cbb  ; [210]; 0.799537
 .long 0x4ce10034  ; [210]; 0.600616
 .long 0xb31effcd  ; [722]; -0.600616
 .long 0x66573cbb  ; [722]; 0.799537
 .long 0x120116d5  ; [466]; 0.140658
 .long 0x7eba3a38  ; [466]; 0.990058
 .long 0x8145c5c9  ; [978]; -0.990058
 .long 0x120116d5  ; [978]; 0.140658
 .long 0x7e7f3956  ; [50]; 0.988258
 .long 0x138edbb1  ; [50]; 0.152797
 .long 0xec712450  ; [562]; -0.152797
 .long 0x7e7f3956  ; [562]; 0.988258
 .long 0x4b9e038f  ; [306]; 0.590760
 .long 0x6746c7d7  ; [306]; 0.806848
 .long 0x98b9382a  ; [818]; -0.806848
 .long 0x4b9e038f  ; [818]; 0.590760
 .long 0x6d6227f9  ; [178]; 0.854558
 .long 0x427a41d0  ; [178]; 0.519356
 .long 0xbd85be31  ; [690]; -0.519356
 .long 0x6d6227f9  ; [690]; 0.854558
 .long 0x1e56ca1e  ; [434]; 0.237024
 .long 0x7c5a3d4f  ; [434]; 0.971504
 .long 0x83a5c2b2  ; [946]; -0.971504
 .long 0x1e56ca1e  ; [946]; 0.237024
 .long 0x78403328  ; [114]; 0.939459
 .long 0x2bdc4e6f  ; [114]; 0.342661
 .long 0xd423b192  ; [626]; -0.342661
 .long 0x78403328  ; [626]; 0.939459
 .long 0x36041ad9  ; [370]; 0.422000
 .long 0x740b53fa  ; [370]; 0.906596
 .long 0x8bf4ac07  ; [882]; -0.906596
 .long 0x36041ad9  ; [882]; 0.422000
 .long 0x5e50015d  ; [242]; 0.736817
 .long 0x568a34a9  ; [242]; 0.676093
 .long 0xa975cb58  ; [754]; -0.676093
 .long 0x5e50015d  ; [754]; 0.736817
 .long 0x057f0035  ; [498]; 0.042938
 .long 0x7fe1c76a  ; [498]; 0.999078
 .long 0x801e3897  ; [1010]; -0.999078
 .long 0x057f0035  ; [1010]; 0.042938
 .long 0x7ff09477  ; [10]; 0.999529
 .long 0x03ed26e6  ; [10]; 0.030675
 .long 0xfc12d91b  ; [522]; -0.030675
 .long 0x7ff09477  ; [522]; 0.999529
 .long 0x57b0d255  ; [266]; 0.685084
 .long 0x5d3e5236  ; [266]; 0.728464
 .long 0xa2c1adcb  ; [778]; -0.728464
 .long 0x57b0d255  ; [778]; 0.685084
 .long 0x74b2c883  ; [138]; 0.911706
 .long 0x3496824f  ; [138]; 0.410843
 .long 0xcb697db2  ; [650]; -0.410843
 .long 0x74b2c883  ; [650]; 0.911706
 .long 0x2d553afb  ; [394]; 0.354164
 .long 0x77b417df  ; [394]; 0.935184
 .long 0x884be822  ; [906]; -0.935184
 .long 0x2d553afb  ; [906]; 0.354164
 .long 0x7cb72723  ; [74]; 0.974339
 .long 0x1ccf8cb3  ; [74]; 0.225084
 .long 0xe330734e  ; [586]; -0.225084
 .long 0x7cb72723  ; [586]; 0.974339
 .long 0x43d09aec  ; [330]; 0.529804
 .long 0x6c8f351b  ; [330]; 0.848120
 .long 0x9370cae6  ; [842]; -0.848120
 .long 0x43d09aec  ; [842]; 0.529804
 .long 0x683257aa  ; [202]; 0.814036
 .long 0x4a581c9d  ; [202]; 0.580814
 .long 0xb5a7e364  ; [714]; -0.580814
 .long 0x683257aa  ; [714]; 0.814036
 .long 0x151bdf85  ; [458]; 0.164913
 .long 0x7e3f57fe  ; [458]; 0.986308
 .long 0x81c0a803  ; [970]; -0.986308
 .long 0x151bdf85  ; [970]; 0.164913
 .long 0x7ef0585f  ; [42]; 0.991710
 .long 0x1072a048  ; [42]; 0.128498
 .long 0xef8d5fb9  ; [554]; -0.128498
 .long 0x7ef0585f  ; [554]; 0.991710
 .long 0x4e210617  ; [298]; 0.610383
 .long 0x6563bf91  ; [298]; 0.792107
 .long 0x9a9c4070  ; [810]; -0.792107
 .long 0x4e210617  ; [810]; 0.610383
 .long 0x6efb5f11  ; [170]; 0.867046
 .long 0x3fc5ec97  ; [170]; 0.498228
 .long 0xc03a136a  ; [682]; -0.498228
 .long 0x6efb5f11  ; [682]; 0.867046
 .long 0x2161b39f  ; [426]; 0.260794
 .long 0x7b920b88  ; [426]; 0.965394
 .long 0x846df479  ; [938]; -0.965394
 .long 0x2161b39f  ; [938]; 0.260794
 .long 0x794a7c11  ; [106]; 0.947586
 .long 0x28e5714a  ; [106]; 0.319502
 .long 0xd71a8eb7  ; [618]; -0.319502
 .long 0x794a7c11  ; [618]; 0.947586
 .long 0x38d8fe93  ; [362]; 0.444122
 .long 0x72af05a6  ; [362]; 0.895966
 .long 0x8d50fa5b  ; [874]; -0.895966
 .long 0x38d8fe93  ; [874]; 0.444122
 .long 0x60686cce  ; [234]; 0.753187
 .long 0x5433027d  ; [234]; 0.657807
 .long 0xabccfd84  ; [746]; -0.657807
 .long 0x60686cce  ; [746]; 0.753187
 .long 0x08a2009a  ; [490]; 0.067444
 .long 0x7fb563b2  ; [490]; 0.997723
 .long 0x804a9c4f  ; [1002]; -0.997723
 .long 0x08a2009a  ; [1002]; 0.067444
 .long 0x7f97cebc  ; [26]; 0.996820
 .long 0x0a3308bc  ; [26]; 0.079682
 .long 0xf5ccf745  ; [538]; -0.079682
 .long 0x7f97cebc  ; [538]; 0.996820
 .long 0x53028517  ; [282]; 0.648514
 .long 0x616f146b  ; [282]; 0.761202
 .long 0x9e90eb96  ; [794]; -0.761202
 .long 0x53028517  ; [794]; 0.648514
 .long 0x71fa3948  ; [154]; 0.890449
 .long 0x3a402dd1  ; [154]; 0.455084
 .long 0xc5bfd230  ; [666]; -0.455084
 .long 0x71fa3948  ; [666]; 0.890449
 .long 0x27679df4  ; [410]; 0.307850
 .long 0x79c89f6d  ; [410]; 0.951435
 .long 0x86376094  ; [922]; -0.951435
 .long 0x27679df4  ; [922]; 0.307850
 .long 0x7b26cb4e  ; [90]; 0.962121
 .long 0x22e541af  ; [90]; 0.272621
 .long 0xdd1abe52  ; [602]; -0.272621
 .long 0x7b26cb4e  ; [602]; 0.962121
 .long 0x3e680b2c  ; [346]; 0.487550
 .long 0x6fc19384  ; [346]; 0.873095
 .long 0x903e6c7d  ; [858]; -0.873095
 .long 0x3e680b2c  ; [858]; 0.487550
 .long 0x646c59bf  ; [218]; 0.784557
 .long 0x4f5e08e2  ; [218]; 0.620057
 .long 0xb0a1f71f  ; [730]; -0.620057
 .long 0x646c59bf  ; [730]; 0.784557
 .long 0x0ee38766  ; [474]; 0.116319
 .long 0x7f2191b3  ; [474]; 0.993212
 .long 0x80de6e4e  ; [986]; -0.993212
 .long 0x0ee38766  ; [986]; 0.116319
 .long 0x7dfa98a7  ; [58]; 0.984210
 .long 0x16a81305  ; [58]; 0.177004
 .long 0xe957ecfc  ; [570]; -0.177004
 .long 0x7dfa98a7  ; [570]; 0.984210
 .long 0x490f57ee  ; [314]; 0.570781
 .long 0x6919e31f  ; [314]; 0.821103
 .long 0x96e61ce2  ; [826]; -0.821103
 .long 0x490f57ee  ; [826]; 0.570781
 .long 0x6bb812d0  ; [186]; 0.841555
 .long 0x452456bc  ; [186]; 0.540171
 .long 0xbadba945  ; [698]; -0.540171
 .long 0x6bb812d0  ; [698]; 0.841555
 .long 0x1b4732ef  ; [442]; 0.213110
 .long 0x7d0f4217  ; [442]; 0.977028
 .long 0x82f0bdea  ; [954]; -0.977028
 .long 0x1b4732ef  ; [954]; 0.213110
 .long 0x77235f2c  ; [122]; 0.930767
 .long 0x2ecc681e  ; [122]; 0.365613
 .long 0xd13397e3  ; [634]; -0.365613
 .long 0x77235f2c  ; [634]; 0.930767
 .long 0x3326e2c2  ; [378]; 0.399624
 .long 0x7555bd4b  ; [378]; 0.916679
 .long 0x8aaa42b6  ; [890]; -0.916679
 .long 0x3326e2c2  ; [890]; 0.399624
 .long 0x5c290acc  ; [250]; 0.720003
 .long 0x58d40e8c  ; [250]; 0.693971
 .long 0xa72bf175  ; [762]; -0.693971
 .long 0x5c290acc  ; [762]; 0.720003
 .long 0x025b26d7  ; [506]; 0.018407
 .long 0x7ffa72d0  ; [506]; 0.999831
 .long 0x80058d31  ; [1018]; -0.999831
 .long 0x025b26d7  ; [1018]; 0.018407
 .long 0x7ffa72d0  ; [6]; 0.999831
 .long 0x025b26d7  ; [6]; 0.018407
 .long 0xfda4d92a  ; [518]; -0.018407
 .long 0x7ffa72d0  ; [518]; 0.999831
 .long 0x58d40e8c  ; [262]; 0.693971
 .long 0x5c290acc  ; [262]; 0.720003
 .long 0xa3d6f535  ; [774]; -0.720003
 .long 0x58d40e8c  ; [774]; 0.693971
 .long 0x7555bd4b  ; [134]; 0.916679
 .long 0x3326e2c2  ; [134]; 0.399624
 .long 0xccd91d3f  ; [646]; -0.399624
 .long 0x7555bd4b  ; [646]; 0.916679
 .long 0x2ecc681e  ; [390]; 0.365613
 .long 0x77235f2c  ; [390]; 0.930767
 .long 0x88dca0d5  ; [902]; -0.930767
 .long 0x2ecc681e  ; [902]; 0.365613
 .long 0x7d0f4217  ; [70]; 0.977028
 .long 0x1b4732ef  ; [70]; 0.213110
 .long 0xe4b8cd12  ; [582]; -0.213110
 .long 0x7d0f4217  ; [582]; 0.977028
 .long 0x452456bc  ; [326]; 0.540171
 .long 0x6bb812d0  ; [326]; 0.841555
 .long 0x9447ed31  ; [838]; -0.841555
 .long 0x452456bc  ; [838]; 0.540171
 .long 0x6919e31f  ; [198]; 0.821103
 .long 0x490f57ee  ; [198]; 0.570781
 .long 0xb6f0a813  ; [710]; -0.570781
 .long 0x6919e31f  ; [710]; 0.821103
 .long 0x16a81305  ; [454]; 0.177004
 .long 0x7dfa98a7  ; [454]; 0.984210
 .long 0x8205675a  ; [966]; -0.984210
 .long 0x16a81305  ; [966]; 0.177004
 .long 0x7f2191b3  ; [38]; 0.993212
 .long 0x0ee38766  ; [38]; 0.116319
 .long 0xf11c789b  ; [550]; -0.116319
 .long 0x7f2191b3  ; [550]; 0.993212
 .long 0x4f5e08e2  ; [294]; 0.620057
 .long 0x646c59bf  ; [294]; 0.784557
 .long 0x9b93a642  ; [806]; -0.784557
 .long 0x4f5e08e2  ; [806]; 0.620057
 .long 0x6fc19384  ; [166]; 0.873095
 .long 0x3e680b2c  ; [166]; 0.487550
 .long 0xc197f4d5  ; [678]; -0.487550
 .long 0x6fc19384  ; [678]; 0.873095
 .long 0x22e541af  ; [422]; 0.272621
 .long 0x7b26cb4e  ; [422]; 0.962121
 .long 0x84d934b3  ; [934]; -0.962121
 .long 0x22e541af  ; [934]; 0.272621
 .long 0x79c89f6d  ; [102]; 0.951435
 .long 0x27679df4  ; [102]; 0.307850
 .long 0xd898620d  ; [614]; -0.307850
 .long 0x79c89f6d  ; [614]; 0.951435
 .long 0x3a402dd1  ; [358]; 0.455084
 .long 0x71fa3948  ; [358]; 0.890449
 .long 0x8e05c6b9  ; [870]; -0.890449
 .long 0x3a402dd1  ; [870]; 0.455084
 .long 0x616f146b  ; [230]; 0.761202
 .long 0x53028517  ; [230]; 0.648514
 .long 0xacfd7aea  ; [742]; -0.648514
 .long 0x616f146b  ; [742]; 0.761202
 .long 0x0a3308bc  ; [486]; 0.079682
 .long 0x7f97cebc  ; [486]; 0.996820
 .long 0x80683145  ; [998]; -0.996820
 .long 0x0a3308bc  ; [998]; 0.079682
 .long 0x7fb563b2  ; [22]; 0.997723
 .long 0x08a2009a  ; [22]; 0.067444
 .long 0xf75dff67  ; [534]; -0.067444
 .long 0x7fb563b2  ; [534]; 0.997723
 .long 0x5433027d  ; [278]; 0.657807
 .long 0x60686cce  ; [278]; 0.753187
 .long 0x9f979333  ; [790]; -0.753187
 .long 0x5433027d  ; [790]; 0.657807
 .long 0x72af05a6  ; [150]; 0.895966
 .long 0x38d8fe93  ; [150]; 0.444122
 .long 0xc727016e  ; [662]; -0.444122
 .long 0x72af05a6  ; [662]; 0.895966
 .long 0x28e5714a  ; [406]; 0.319502
 .long 0x794a7c11  ; [406]; 0.947586
 .long 0x86b583f0  ; [918]; -0.947586
 .long 0x28e5714a  ; [918]; 0.319502
 .long 0x7b920b88  ; [86]; 0.965394
 .long 0x2161b39f  ; [86]; 0.260794
 .long 0xde9e4c62  ; [598]; -0.260794
 .long 0x7b920b88  ; [598]; 0.965394
 .long 0x3fc5ec97  ; [342]; 0.498228
 .long 0x6efb5f11  ; [342]; 0.867046
 .long 0x9104a0f0  ; [854]; -0.867046
 .long 0x3fc5ec97  ; [854]; 0.498228
 .long 0x6563bf91  ; [214]; 0.792107
 .long 0x4e210617  ; [214]; 0.610383
 .long 0xb1def9ea  ; [726]; -0.610383
 .long 0x6563bf91  ; [726]; 0.792107
 .long 0x1072a048  ; [470]; 0.128498
 .long 0x7ef0585f  ; [470]; 0.991710
 .long 0x810fa7a2  ; [982]; -0.991710
 .long 0x1072a048  ; [982]; 0.128498
 .long 0x7e3f57fe  ; [54]; 0.986308
 .long 0x151bdf85  ; [54]; 0.164913
 .long 0xeae4207c  ; [566]; -0.164913
 .long 0x7e3f57fe  ; [566]; 0.986308
 .long 0x4a581c9d  ; [310]; 0.580814
 .long 0x683257aa  ; [310]; 0.814036
 .long 0x97cda857  ; [822]; -0.814036
 .long 0x4a581c9d  ; [822]; 0.580814
 .long 0x6c8f351b  ; [182]; 0.848120
 .long 0x43d09aec  ; [182]; 0.529804
 .long 0xbc2f6515  ; [694]; -0.529804
 .long 0x6c8f351b  ; [694]; 0.848120
 .long 0x1ccf8cb3  ; [438]; 0.225084
 .long 0x7cb72723  ; [438]; 0.974339
 .long 0x8348d8de  ; [950]; -0.974339
 .long 0x1ccf8cb3  ; [950]; 0.225084
 .long 0x77b417df  ; [118]; 0.935184
 .long 0x2d553afb  ; [118]; 0.354164
 .long 0xd2aac506  ; [630]; -0.354164
 .long 0x77b417df  ; [630]; 0.935184
 .long 0x3496824f  ; [374]; 0.410843
 .long 0x74b2c883  ; [374]; 0.911706
 .long 0x8b4d377e  ; [886]; -0.911706
 .long 0x3496824f  ; [886]; 0.410843
 .long 0x5d3e5236  ; [246]; 0.728464
 .long 0x57b0d255  ; [246]; 0.685084
 .long 0xa84f2dac  ; [758]; -0.685084
 .long 0x5d3e5236  ; [758]; 0.728464
 .long 0x03ed26e6  ; [502]; 0.030675
 .long 0x7ff09477  ; [502]; 0.999529
 .long 0x800f6b8a  ; [1014]; -0.999529
 .long 0x03ed26e6  ; [1014]; 0.030675
 .long 0x7fe1c76a  ; [14]; 0.999078
 .long 0x057f0035  ; [14]; 0.042938
 .long 0xfa80ffcc  ; [526]; -0.042938
 .long 0x7fe1c76a  ; [526]; 0.999078
 .long 0x568a34a9  ; [270]; 0.676093
 .long 0x5e50015d  ; [270]; 0.736817
 .long 0xa1affea4  ; [782]; -0.736817
 .long 0x568a34a9  ; [782]; 0.676093
 .long 0x740b53fa  ; [142]; 0.906596
 .long 0x36041ad9  ; [142]; 0.422000
 .long 0xc9fbe528  ; [654]; -0.422000
 .long 0x740b53fa  ; [654]; 0.906596
 .long 0x2bdc4e6f  ; [398]; 0.342661
 .long 0x78403328  ; [398]; 0.939459
 .long 0x87bfccd9  ; [910]; -0.939459
 .long 0x2bdc4e6f  ; [910]; 0.342661
 .long 0x7c5a3d4f  ; [78]; 0.971504
 .long 0x1e56ca1e  ; [78]; 0.237024
 .long 0xe1a935e3  ; [590]; -0.237024
 .long 0x7c5a3d4f  ; [590]; 0.971504
 .long 0x427a41d0  ; [334]; 0.519356
 .long 0x6d6227f9  ; [334]; 0.854558
 .long 0x929dd808  ; [846]; -0.854558
 .long 0x427a41d0  ; [846]; 0.519356
 .long 0x6746c7d7  ; [206]; 0.806848
 .long 0x4b9e038f  ; [206]; 0.590760
 .long 0xb461fc72  ; [718]; -0.590760
 .long 0x6746c7d7  ; [718]; 0.806848
 .long 0x138edbb1  ; [462]; 0.152797
 .long 0x7e7f3956  ; [462]; 0.988258
 .long 0x8180c6ab  ; [974]; -0.988258
 .long 0x138edbb1  ; [974]; 0.152797
 .long 0x7eba3a38  ; [46]; 0.990058
 .long 0x120116d5  ; [46]; 0.140658
 .long 0xedfee92c  ; [558]; -0.140658
 .long 0x7eba3a38  ; [558]; 0.990058
 .long 0x4ce10034  ; [302]; 0.600616
 .long 0x66573cbb  ; [302]; 0.799537
 .long 0x99a8c346  ; [814]; -0.799537
 .long 0x4ce10034  ; [814]; 0.600616
 .long 0x6e30e349  ; [174]; 0.860867
 .long 0x4121589a  ; [174]; 0.508830
 .long 0xbedea767  ; [686]; -0.508830
 .long 0x6e30e349  ; [686]; 0.860867
 .long 0x1fdcdc1b  ; [430]; 0.248928
 .long 0x7bf8882f  ; [430]; 0.968522
 .long 0x840777d2  ; [942]; -0.968522
 .long 0x1fdcdc1b  ; [942]; 0.248928
 .long 0x78c7aba1  ; [110]; 0.943593
 .long 0x2a61b101  ; [110]; 0.331106
 .long 0xd59e4f00  ; [622]; -0.331106
 .long 0x78c7aba1  ; [622]; 0.943593
 .long 0x376f9e46  ; [366]; 0.433094
 .long 0x735f6625  ; [366]; 0.901349
 .long 0x8ca099dc  ; [878]; -0.901349
 .long 0x376f9e46  ; [878]; 0.433094
 .long 0x5f5e0db2  ; [238]; 0.745058
 .long 0x556040e2  ; [238]; 0.667000
 .long 0xaa9fbf1f  ; [750]; -0.667000
 .long 0x5f5e0db2  ; [750]; 0.745058
 .long 0x0710a345  ; [494]; 0.055195
 .long 0x7fce0c3d  ; [494]; 0.998476
 .long 0x8031f3c4  ; [1006]; -0.998476
 .long 0x0710a345  ; [1006]; 0.055195
 .long 0x7f754e7f  ; [30]; 0.995767
 .long 0x0bc3ac35  ; [30]; 0.091909
 .long 0xf43c53cc  ; [542]; -0.091909
 .long 0x7f754e7f  ; [542]; 0.995767
 .long 0x51ced46e  ; [286]; 0.639124
 .long 0x6271fa68  ; [286]; 0.769103
 .long 0x9d8e0599  ; [798]; -0.769103
 .long 0x51ced46e  ; [798]; 0.639124
 .long 0x71410804  ; [158]; 0.884797
 .long 0x3ba51e29  ; [158]; 0.465976
 .long 0xc45ae1d8  ; [670]; -0.465976
 .long 0x71410804  ; [670]; 0.884797
 .long 0x25e845b6  ; [414]; 0.296151
 .long 0x7a4210d8  ; [414]; 0.955141
 .long 0x85bdef29  ; [926]; -0.955141
 .long 0x25e845b6  ; [926]; 0.296151
 .long 0x7ab6cba3  ; [94]; 0.958703
 .long 0x24677757  ; [94]; 0.284408
 .long 0xdb9888aa  ; [606]; -0.284408
 .long 0x7ab6cba3  ; [606]; 0.958703
 .long 0x3d07c1d5  ; [350]; 0.476799
 .long 0x708378fe  ; [350]; 0.879012
 .long 0x8f7c8703  ; [862]; -0.879012
 .long 0x3d07c1d5  ; [862]; 0.476799
 .long 0x637114cc  ; [222]; 0.776888
 .long 0x5097fc5e  ; [222]; 0.629638
 .long 0xaf6803a3  ; [734]; -0.629638
 .long 0x637114cc  ; [734]; 0.776888
 .long 0x0d53db92  ; [478]; 0.104122
 .long 0x7f4de450  ; [478]; 0.994565
 .long 0x80b21bb1  ; [990]; -0.994565
 .long 0x0d53db92  ; [990]; 0.104122
 .long 0x7db0fdf7  ; [62]; 0.981964
 .long 0x183366e8  ; [62]; 0.189069
 .long 0xe7cc9919  ; [574]; -0.189069
 .long 0x7db0fdf7  ; [574]; 0.981964
 .long 0x47c3c22e  ; [318]; 0.560662
 .long 0x69fd614a  ; [318]; 0.828045
 .long 0x96029eb7  ; [830]; -0.828045
 .long 0x47c3c22e  ; [830]; 0.560662
 .long 0x6adcc964  ; [190]; 0.834863
 .long 0x46756827  ; [190]; 0.550458
 .long 0xb98a97da  ; [702]; -0.550458
 .long 0x6adcc964  ; [702]; 0.834863
 .long 0x19bdcbf3  ; [446]; 0.201105
 .long 0x7d628ac5  ; [446]; 0.979570
 .long 0x829d753c  ; [958]; -0.979570
 .long 0x19bdcbf3  ; [958]; 0.201105
 .long 0x768e0ea5  ; [126]; 0.926210
 .long 0x3041c760  ; [126]; 0.377007
 .long 0xcfbe38a1  ; [638]; -0.377007
 .long 0x768e0ea5  ; [638]; 0.926210
 .long 0x31b54a5d  ; [382]; 0.388345
 .long 0x75f42c0a  ; [382]; 0.921514
 .long 0x8a0bd3f7  ; [894]; -0.921514
 .long 0x31b54a5d  ; [894]; 0.388345
 .long 0x5b1035ce  ; [254]; 0.711432
 .long 0x59f3de12  ; [254]; 0.702755
 .long 0xa60c21ef  ; [766]; -0.702755
 .long 0x5b1035ce  ; [766]; 0.711432
 .long 0x00c90f88  ; [510]; 0.006136
 .long 0x7fff6215  ; [510]; 0.999981
 .long 0x80009dec  ; [1022]; -0.999981
 .long 0x00c90f88  ; [1022]; 0.006136
 .long 0x7fffd885  ; [1]; 0.999995
 .long 0x006487e3  ; [1]; 0.003068
 .long 0xff9b781e  ; [513]; -0.003068
 .long 0x7fffd885  ; [513]; 0.999995
 .long 0x5a3b47aa  ; [257]; 0.704934
 .long 0x5ac973b4  ; [257]; 0.709273
 .long 0xa5368c4d  ; [769]; -0.709273
 .long 0x5a3b47aa  ; [769]; 0.704934
 .long 0x761b1210  ; [129]; 0.922701
 .long 0x3158970d  ; [129]; 0.385516
 .long 0xcea768f4  ; [641]; -0.385516
 .long 0x761b1210  ; [641]; 0.922701
 .long 0x309ed556  ; [385]; 0.379847
 .long 0x76680375  ; [385]; 0.925049
 .long 0x8997fc8c  ; [897]; -0.925049
 .long 0x309ed556  ; [897]; 0.379847
 .long 0x7d769bb4  ; [65]; 0.980182
 .long 0x195b49ea  ; [65]; 0.198098
 .long 0xe6a4b617  ; [577]; -0.198098
 .long 0x7d769bb4  ; [577]; 0.980182
 .long 0x46c9405c  ; [321]; 0.553017
 .long 0x6aa551e8  ; [321]; 0.833170
 .long 0x955aae19  ; [833]; -0.833170
 .long 0x46c9405c  ; [833]; 0.553017
 .long 0x6a359db8  ; [193]; 0.829761
 .long 0x47706d93  ; [193]; 0.558119
 .long 0xb88f926e  ; [705]; -0.558119
 .long 0x6a359db8  ; [705]; 0.829761
 .long 0x18961728  ; [449]; 0.192080
 .long 0x7d9dd559  ; [449]; 0.981379
 .long 0x82622aa8  ; [961]; -0.981379
 .long 0x18961728  ; [961]; 0.192080
 .long 0x7f5834b6  ; [33]; 0.994879
 .long 0x0cefdb75  ; [33]; 0.101070
 .long 0xf310248c  ; [545]; -0.101070
 .long 0x7f5834b6  ; [545]; 0.994879
 .long 0x50e5fd6c  ; [289]; 0.632019
 .long 0x6331a9d4  ; [289]; 0.774953
 .long 0x9cce562d  ; [801]; -0.774953
 .long 0x50e5fd6c  ; [801]; 0.632019
 .long 0x70b34524  ; [161]; 0.880471
 .long 0x3caf50da  ; [161]; 0.474100
 .long 0xc350af27  ; [673]; -0.474100
 .long 0x70b34524  ; [673]; 0.880471
 .long 0x24c7cd32  ; [417]; 0.287347
 .long 0x7a9a0e4f  ; [417]; 0.957826
 .long 0x8565f1b2  ; [929]; -0.957826
 .long 0x24c7cd32  ; [929]; 0.287347
 .long 0x7a5fb0d7  ; [97]; 0.956045
 .long 0x2588349d  ; [97]; 0.293219
 .long 0xda77cb64  ; [609]; -0.293219
 .long 0x7a5fb0d7  ; [609]; 0.956045
 .long 0x3bfdfecd  ; [353]; 0.468689
 .long 0x71120cc4  ; [353]; 0.883363
 .long 0x8eedf33d  ; [865]; -0.883363
 .long 0x3bfdfecd  ; [865]; 0.468689
 .long 0x62b21c7b  ; [225]; 0.771061
 .long 0x518169a4  ; [225]; 0.636762
 .long 0xae7e965d  ; [737]; -0.636762
 .long 0x62b21c7b  ; [737]; 0.771061
 .long 0x0c27c389  ; [481]; 0.094963
 .long 0x7f6be9d3  ; [481]; 0.995481
 .long 0x8094162e  ; [993]; -0.995481
 .long 0x0c27c389  ; [993]; 0.094963
 .long 0x7fd37152  ; [17]; 0.998640
 .long 0x06ac406f  ; [17]; 0.052132
 .long 0xf953bf92  ; [529]; -0.052132
 .long 0x7fd37152  ; [529]; 0.998640
 .long 0x55ab0d46  ; [273]; 0.669283
 .long 0x5f1ae273  ; [273]; 0.743008
 .long 0xa0e51d8e  ; [785]; -0.743008
 .long 0x55ab0d46  ; [785]; 0.669283
 .long 0x738acc9d  ; [145]; 0.902673
 .long 0x3714f02a  ; [145]; 0.430326
 .long 0xc8eb0fd7  ; [657]; -0.430326
 .long 0x738acc9d  ; [657]; 0.902673
 .long 0x2ac08026  ; [401]; 0.334000
 .long 0x78a63d10  ; [401]; 0.942573
 .long 0x8759c2f1  ; [913]; -0.942573
 .long 0x2ac08026  ; [913]; 0.334000
 .long 0x7c116852  ; [81]; 0.969281
 .long 0x1f7b7480  ; [81]; 0.245955
 .long 0xe0848b81  ; [593]; -0.245955
 .long 0x7c116852  ; [593]; 0.969281
 .long 0x4177cfb0  ; [337]; 0.511469
 .long 0x6dfd9a1b  ; [337]; 0.859302
 .long 0x920265e6  ; [849]; -0.859302
 .long 0x4177cfb0  ; [849]; 0.511469
 .long 0x66937e90  ; [209]; 0.801376
 .long 0x4c9087b1  ; [209]; 0.598161
 .long 0xb36f7850  ; [721]; -0.598161
 .long 0x66937e90  ; [721]; 0.801376
 .long 0x1264994e  ; [465]; 0.143695
 .long 0x7eabef2b  ; [465]; 0.989622
 .long 0x815410d6  ; [977]; -0.989622
 .long 0x1264994e  ; [977]; 0.143695
 .long 0x7e8e6eb1  ; [49]; 0.988722
 .long 0x132b7bf9  ; [49]; 0.149765
 .long 0xecd48408  ; [561]; -0.149765
 .long 0x7e8e6eb1  ; [561]; 0.988722
 .long 0x4bef092c  ; [305]; 0.593232
 .long 0x670b4443  ; [305]; 0.805031
 .long 0x98f4bbbe  ; [817]; -0.805031
 .long 0x4bef092c  ; [817]; 0.593232
 .long 0x6d963c53  ; [177]; 0.856147
 .long 0x42244480  ; [177]; 0.516732
 .long 0xbddbbb81  ; [689]; -0.516732
 .long 0x6d963c53  ; [689]; 0.856147
 .long 0x1eb86b46  ; [433]; 0.240003
 .long 0x7c4242f1  ; [433]; 0.970772
 .long 0x83bdbd10  ; [945]; -0.970772
 .long 0x1eb86b46  ; [945]; 0.240003
 .long 0x786280bf  ; [113]; 0.940506
 .long 0x2b7dcf17  ; [113]; 0.339777
 .long 0xd48230ea  ; [625]; -0.339777
 .long 0x786280bf  ; [625]; 0.940506
 .long 0x365f2e3b  ; [369]; 0.424780
 .long 0x73e0c3a2  ; [369]; 0.905297
 .long 0x8c1f3c5f  ; [881]; -0.905297
 .long 0x365f2e3b  ; [881]; 0.424780
 .long 0x5e93dc1e  ; [241]; 0.738887
 .long 0x56400757  ; [241]; 0.673829
 .long 0xa9bff8aa  ; [753]; -0.673829
 .long 0x5e93dc1e  ; [753]; 0.738887
 .long 0x05e36ea9  ; [497]; 0.046003
 .long 0x7fdd4eeb  ; [497]; 0.998941
 .long 0x8022b116  ; [1009]; -0.998941
 .long 0x05e36ea9  ; [1009]; 0.046003
 .long 0x7ff38273  ; [9]; 0.999619
 .long 0x0388a9ea  ; [9]; 0.027608
 .long 0xfc775617  ; [521]; -0.027608
 .long 0x7ff38273  ; [521]; 0.999619
 .long 0x57f9f2f7  ; [265]; 0.687315
 .long 0x5cf95637  ; [265]; 0.726359
 .long 0xa306a9ca  ; [777]; -0.726359
 .long 0x57f9f2f7  ; [777]; 0.687315
 .long 0x74dbf1ee  ; [137]; 0.912962
 .long 0x343aca87  ; [137]; 0.408044
 .long 0xcbc5357a  ; [649]; -0.408044
 .long 0x74dbf1ee  ; [649]; 0.912962
 .long 0x2db330c7  ; [393]; 0.357031
 .long 0x7790583d  ; [393]; 0.934093
 .long 0x886fa7c4  ; [905]; -0.934093
 .long 0x2db330c7  ; [905]; 0.357031
 .long 0x7ccda168  ; [73]; 0.975025
 .long 0x1c6d9053  ; [73]; 0.222094
 .long 0xe3926fae  ; [585]; -0.222094
 .long 0x7ccda168  ; [585]; 0.975025
 .long 0x4425c923  ; [329]; 0.532403
 .long 0x6c59d0a8  ; [329]; 0.846491
 .long 0x93a62f59  ; [841]; -0.846491
 .long 0x4425c923  ; [841]; 0.532403
 .long 0x686c9b4a  ; [201]; 0.815814
 .long 0x4a062fbd  ; [201]; 0.578314
 .long 0xb5f9d044  ; [713]; -0.578314
 .long 0x686c9b4a  ; [713]; 0.815814
 .long 0x157f0086  ; [457]; 0.167938
 .long 0x7e2e9cde  ; [457]; 0.985798
 .long 0x81d16323  ; [969]; -0.985798
 .long 0x157f0086  ; [969]; 0.167938
 .long 0x7efd1c3b  ; [41]; 0.992099
 .long 0x100ee8ad  ; [41]; 0.125455
 .long 0xeff11754  ; [553]; -0.125455
 .long 0x7efd1c3b  ; [553]; 0.992099
 .long 0x4e708f8f  ; [297]; 0.612810
 .long 0x6526438e  ; [297]; 0.790230
 .long 0x9ad9bc73  ; [809]; -0.790230
 .long 0x4e708f8f  ; [809]; 0.612810
 .long 0x6f2d532b  ; [169]; 0.868571
 .long 0x3f6eaeb8  ; [169]; 0.495565
 .long 0xc0915149  ; [681]; -0.495565
 .long 0x6f2d532b  ; [681]; 0.868571
 .long 0x21c2b69c  ; [425]; 0.263755
 .long 0x7b77ada7  ; [425]; 0.964590
 .long 0x8488525a  ; [937]; -0.964590
 .long 0x21c2b69c  ; [937]; 0.263755
 .long 0x796a7553  ; [105]; 0.948561
 .long 0x288621b9  ; [105]; 0.316593
 .long 0xd779de48  ; [617]; -0.316593
 .long 0x796a7553  ; [617]; 0.948561
 .long 0x3932ff87  ; [361]; 0.446869
 .long 0x72823c66  ; [361]; 0.894599
 .long 0x8d7dc39b  ; [873]; -0.894599
 .long 0x3932ff87  ; [873]; 0.446869
 .long 0x60aa704f  ; [233]; 0.755201
 .long 0x53e73097  ; [233]; 0.655493
 .long 0xac18cf6a  ; [745]; -0.655493
 .long 0x60aa704f  ; [745]; 0.755201
 .long 0x09064b3a  ; [489]; 0.070505
 .long 0x7fae7494  ; [489]; 0.997511
 .long 0x80518b6d  ; [1001]; -0.997511
 .long 0x09064b3a  ; [1001]; 0.070505
 .long 0x7f9faa14  ; [25]; 0.997060
 .long 0x09cecf89  ; [25]; 0.076624
 .long 0xf6313078  ; [537]; -0.076624
 .long 0x7f9faa14  ; [537]; 0.997060
 .long 0x534ef1b5  ; [281]; 0.650847
 .long 0x612dc446  ; [281]; 0.759209
 .long 0x9ed23bbb  ; [793]; -0.759209
 .long 0x534ef1b5  ; [793]; 0.650847
 .long 0x7227d61b  ; [153]; 0.891841
 .long 0x39e6975d  ; [153]; 0.452350
 .long 0xc61968a4  ; [665]; -0.452350
 .long 0x7227d61b  ; [665]; 0.891841
 .long 0x27c737d3  ; [409]; 0.310767
 .long 0x79a98715  ; [409]; 0.950486
 .long 0x865678ec  ; [921]; -0.950486
 .long 0x27c737d3  ; [921]; 0.310767
 .long 0x7b420d79  ; [89]; 0.962953
 .long 0x22847ddf  ; [89]; 0.269668
 .long 0xdd7b8222  ; [601]; -0.269668
 .long 0x7b420d79  ; [601]; 0.962953
 .long 0x3ebfbdcc  ; [345]; 0.490226
 .long 0x6f906d83  ; [345]; 0.871595
 .long 0x906f927e  ; [857]; -0.871595
 .long 0x3ebfbdcc  ; [857]; 0.490226
 .long 0x64aa907e  ; [217]; 0.786455
 .long 0x4f0f1125  ; [217]; 0.617647
 .long 0xb0f0eedc  ; [729]; -0.617647
 .long 0x64aa907e  ; [729]; 0.786455
 .long 0x0f475bff  ; [473]; 0.119365
 .long 0x7f15b8ed  ; [473]; 0.992850
 .long 0x80ea4714  ; [985]; -0.992850
 .long 0x0f475bff  ; [985]; 0.119365
 .long 0x7e0c3d28  ; [57]; 0.984749
 .long 0x16451a83  ; [57]; 0.173984
 .long 0xe9bae57e  ; [569]; -0.173984
 .long 0x7e0c3d28  ; [569]; 0.984749
 .long 0x4961cd32  ; [313]; 0.573297
 .long 0x68e06129  ; [313]; 0.819348
 .long 0x971f9ed8  ; [825]; -0.819348
 .long 0x4961cd32  ; [825]; 0.573297
 .long 0x6bee3f62  ; [185]; 0.843208
 .long 0x44cfa73f  ; [185]; 0.537587
 .long 0xbb3058c2  ; [697]; -0.537587
 .long 0x6bee3f62  ; [697]; 0.843208
 .long 0x1ba96335  ; [441]; 0.216107
 .long 0x7cf9aeef  ; [441]; 0.976370
 .long 0x83065112  ; [953]; -0.976370
 .long 0x1ba96335  ; [953]; 0.216107
 .long 0x7747fbcd  ; [121]; 0.931884
 .long 0x2e6ec792  ; [121]; 0.362756
 .long 0xd191386f  ; [633]; -0.362756
 .long 0x7747fbcd  ; [633]; 0.931884
 .long 0x3382fa88  ; [377]; 0.402435
 .long 0x752d6c6b  ; [377]; 0.915449
 .long 0x8ad29396  ; [889]; -0.915449
 .long 0x3382fa88  ; [889]; 0.402435
 .long 0x5c6eb258  ; [249]; 0.722128
 .long 0x588b913f  ; [249]; 0.691759
 .long 0xa7746ec2  ; [761]; -0.691759
 .long 0x5c6eb258  ; [761]; 0.722128
 .long 0x02bfa9a4  ; [505]; 0.021474
 .long 0x7ff871a1  ; [505]; 0.999769
 .long 0x80078e60  ; [1017]; -0.999769
 .long 0x02bfa9a4  ; [1017]; 0.021474
 .long 0x7ffc250e  ; [5]; 0.999882
 .long 0x01f6a297  ; [5]; 0.015339
 .long 0xfe095d6a  ; [517]; -0.015339
 .long 0x7ffc250e  ; [517]; 0.999882
 .long 0x591c550d  ; [261]; 0.696177
 .long 0x5be32a66  ; [261]; 0.717870
 .long 0xa41cd59b  ; [773]; -0.717870
 .long 0x591c550d  ; [773]; 0.696177
 .long 0x757dc5c9  ; [133]; 0.917901
 .long 0x32caab6f  ; [133]; 0.396810
 .long 0xcd355492  ; [645]; -0.396810
 .long 0x757dc5c9  ; [645]; 0.917901
 .long 0x2f29ebcc  ; [389]; 0.368467
 .long 0x76fe790d  ; [389]; 0.929641
 .long 0x890186f4  ; [901]; -0.929641
 .long 0x2f29ebcc  ; [901]; 0.368467
 .long 0x7d24881a  ; [69]; 0.977677
 .long 0x1ae4f1d6  ; [69]; 0.210112
 .long 0xe51b0e2b  ; [581]; -0.210112
 .long 0x7d24881a  ; [581]; 0.977677
 .long 0x4578db93  ; [325]; 0.542751
 .long 0x6b81a3cc  ; [325]; 0.839894
 .long 0x947e5c35  ; [837]; -0.839894
 .long 0x4578db93  ; [837]; 0.542751
 .long 0x69532441  ; [197]; 0.822850
 .long 0x48bcb598  ; [197]; 0.568259
 .long 0xb7434a69  ; [709]; -0.568259
 .long 0x69532441  ; [709]; 0.822850
 .long 0x170afd8d  ; [453]; 0.180023
 .long 0x7de8a66f  ; [453]; 0.983662
 .long 0x82175992  ; [965]; -0.983662
 .long 0x170afd8d  ; [965]; 0.180023
 .long 0x7f2d1c0d  ; [37]; 0.993564
 .long 0x0e7fa99d  ; [37]; 0.113271
 .long 0xf1805664  ; [549]; -0.113271
 .long 0x7f2d1c0d  ; [549]; 0.993564
 .long 0x4faccfaa  ; [293]; 0.622461
 .long 0x642de50d  ; [293]; 0.782651
 .long 0x9bd21af4  ; [805]; -0.782651
 .long 0x4faccfaa  ; [805]; 0.622461
 .long 0x6ff27496  ; [165]; 0.874587
 .long 0x3e10320d  ; [165]; 0.484869
 .long 0xc1efcdf4  ; [677]; -0.484869
 .long 0x6ff27496  ; [677]; 0.874587
 .long 0x2345eff8  ; [421]; 0.275572
 .long 0x7b0b3d2b  ; [421]; 0.961280
 .long 0x84f4c2d6  ; [933]; -0.961280
 .long 0x2345eff8  ; [933]; 0.275572
 .long 0x79e76ca6  ; [101]; 0.952375
 .long 0x2707ebc6  ; [101]; 0.304929
 .long 0xd8f8143b  ; [613]; -0.304929
 .long 0x79e76ca6  ; [613]; 0.952375
 .long 0x3a99a057  ; [357]; 0.457813
 .long 0x71cc5626  ; [357]; 0.889048
 .long 0x8e33a9db  ; [869]; -0.889048
 .long 0x3a99a057  ; [869]; 0.457813
 .long 0x61b02876  ; [229]; 0.763188
 .long 0x52b5e545  ; [229]; 0.646176
 .long 0xad4a1abc  ; [741]; -0.646176
 .long 0x61b02876  ; [741]; 0.763188
 .long 0x0a973ba5  ; [485]; 0.082740
 .long 0x7f8fa4af  ; [485]; 0.996571
 .long 0x80705b52  ; [997]; -0.996571
 .long 0x0a973ba5  ; [997]; 0.082740
 .long 0x7fbc0409  ; [21]; 0.997925
 .long 0x083db0a7  ; [21]; 0.064383
 .long 0xf7c24f5a  ; [533]; -0.064383
 .long 0x7fbc0409  ; [533]; 0.997925
 .long 0x547ea073  ; [277]; 0.660114
 .long 0x60262dd5  ; [277]; 0.751165
 .long 0x9fd9d22c  ; [789]; -0.751165
 .long 0x547ea073  ; [789]; 0.660114
 .long 0x72db8827  ; [149]; 0.897325
 .long 0x387eda8e  ; [149]; 0.441371
 .long 0xc7812573  ; [661]; -0.441371
 .long 0x72db8827  ; [661]; 0.897325
 .long 0x2944a7a2  ; [405]; 0.322408
 .long 0x792a37fd  ; [405]; 0.946601
 .long 0x86d5c804  ; [917]; -0.946601
 .long 0x2944a7a2  ; [917]; 0.322408
 .long 0x7bac1d30  ; [85]; 0.966190
 .long 0x21009c0c  ; [85]; 0.257831
 .long 0xdeff63f5  ; [597]; -0.257831
 .long 0x7bac1d30  ; [597]; 0.966190
 .long 0x401d0320  ; [341]; 0.500885
 .long 0x6ec92682  ; [341]; 0.865514
 .long 0x9136d97f  ; [853]; -0.865514
 .long 0x401d0320  ; [853]; 0.500885
 .long 0x65a0fd0a  ; [213]; 0.793975
 .long 0x4dd14c6d  ; [213]; 0.607950
 .long 0xb22eb394  ; [725]; -0.607950
 .long 0x65a0fd0a  ; [725]; 0.793975
 .long 0x10d64dbd  ; [469]; 0.131540
 .long 0x7ee34635  ; [469]; 0.991311
 .long 0x811cb9cc  ; [981]; -0.991311
 .long 0x10d64dbd  ; [981]; 0.131540
 .long 0x7e4fc53d  ; [53]; 0.986809
 .long 0x14b8b17f  ; [53]; 0.161886
 .long 0xeb474e82  ; [565]; -0.161886
 .long 0x7e4fc53d  ; [565]; 0.986809
 .long 0x4aa9dba1  ; [309]; 0.583309
 .long 0x67f7d3c4  ; [309]; 0.812251
 .long 0x98082c3d  ; [821]; -0.812251
 .long 0x4aa9dba1  ; [821]; 0.583309
 .long 0x6cc45697  ; [181]; 0.849742
 .long 0x437b42e1  ; [181]; 0.527199
 .long 0xbc84bd20  ; [693]; -0.527199
 .long 0x6cc45697  ; [693]; 0.849742
 .long 0x1d31774d  ; [437]; 0.228072
 .long 0x7ca05ff0  ; [437]; 0.973644
 .long 0x835fa011  ; [949]; -0.973644
 .long 0x1d31774d  ; [949]; 0.228072
 .long 0x77d78da9  ; [117]; 0.936266
 .long 0x2cf72939  ; [117]; 0.351293
 .long 0xd308d6c8  ; [629]; -0.351293
 .long 0x77d78da9  ; [629]; 0.936266
 .long 0x34f219a7  ; [373]; 0.413638
 .long 0x7489571b  ; [373]; 0.910441
 .long 0x8b76a8e6  ; [885]; -0.910441
 .long 0x34f219a7  ; [885]; 0.413638
 .long 0x5d8314b0  ; [245]; 0.730563
 .long 0x57677b9c  ; [245]; 0.682846
 .long 0xa8988465  ; [757]; -0.682846
 .long 0x5d8314b0  ; [757]; 0.730563
 .long 0x0451a177  ; [501]; 0.033741
 .long 0x7fed5790  ; [501]; 0.999431
 .long 0x8012a871  ; [1013]; -0.999431
 .long 0x0451a177  ; [1013]; 0.033741
 .long 0x7fe5f107  ; [13]; 0.999205
 .long 0x051a8e5c  ; [13]; 0.039873
 .long 0xfae571a5  ; [525]; -0.039873
 .long 0x7fe5f107  ; [525]; 0.999205
 .long 0x56d42c99  ; [269]; 0.678350
 .long 0x5e0bec6e  ; [269]; 0.734739
 .long 0xa1f41393  ; [781]; -0.734739
 .long 0x56d42c99  ; [781]; 0.678350
 .long 0x74359cbc  ; [141]; 0.907886
 .long 0x35a8e624  ; [141]; 0.419217
 .long 0xca5719dd  ; [653]; -0.419217
 .long 0x74359cbc  ; [653]; 0.907886
 .long 0x2c3ab2b9  ; [397]; 0.345541
 .long 0x781d9b64  ; [397]; 0.938404
 .long 0x87e2649d  ; [909]; -0.938404
 .long 0x2c3ab2b9  ; [909]; 0.345541
 .long 0x7c71eaf8  ; [77]; 0.972226
 .long 0x1df5163f  ; [77]; 0.234042
 .long 0xe20ae9c2  ; [589]; -0.234042
 .long 0x7c71eaf8  ; [589]; 0.972226
 .long 0x42d0161e  ; [333]; 0.521975
 .long 0x6d2dd027  ; [333]; 0.852961
 .long 0x92d22fda  ; [845]; -0.852961
 .long 0x42d0161e  ; [845]; 0.521975
 .long 0x67820bb6  ; [205]; 0.808656
 .long 0x4b4ccf4d  ; [205]; 0.588282
 .long 0xb4b330b4  ; [717]; -0.588282
 .long 0x67820bb6  ; [717]; 0.808656
 .long 0x13f22f58  ; [461]; 0.155828
 .long 0x7e6fb5f3  ; [461]; 0.987784
 .long 0x81904a0e  ; [973]; -0.987784
 .long 0x13f22f58  ; [973]; 0.155828
 .long 0x7ec83719  ; [45]; 0.990485
 .long 0x119d8941  ; [45]; 0.137620
 .long 0xee6276c0  ; [557]; -0.137620
 .long 0x7ec83719  ; [557]; 0.990485
 .long 0x4d31494a  ; [301]; 0.603067
 .long 0x661abbc4  ; [301]; 0.797691
 .long 0x99e5443d  ; [813]; -0.797691
 .long 0x4d31494a  ; [813]; 0.603067
 .long 0x6e63e87f  ; [173]; 0.862424
 .long 0x40cab957  ; [173]; 0.506187
 .long 0xbf3546aa  ; [685]; -0.506187
 .long 0x6e63e87f  ; [685]; 0.862424
 .long 0x203e300d  ; [429]; 0.251898
 .long 0x7bdf5b93  ; [429]; 0.967754
 .long 0x8420a46e  ; [941]; -0.967754
 .long 0x203e300d  ; [941]; 0.251898
 .long 0x78e8cfb1  ; [109]; 0.944605
 .long 0x2a02c7b8  ; [109]; 0.328210
 .long 0xd5fd3849  ; [621]; -0.328210
 .long 0x78e8cfb1  ; [621]; 0.944605
 .long 0x37ca2a30  ; [365]; 0.435857
 .long 0x7333b882  ; [365]; 0.900016
 .long 0x8ccc477f  ; [877]; -0.900016
 .long 0x37ca2a30  ; [877]; 0.435857
 .long 0x5fa0fe1e  ; [237]; 0.747101
 .long 0x55153fd4  ; [237]; 0.664711
 .long 0xaaeac02d  ; [749]; -0.664711
 .long 0x5fa0fe1e  ; [749]; 0.747101
 .long 0x077501be  ; [493]; 0.058258
 .long 0x7fc85853  ; [493]; 0.998302
 .long 0x8037a7ae  ; [1005]; -0.998302
 .long 0x077501be  ; [1005]; 0.058258
 .long 0x7f7e648b  ; [29]; 0.996045
 .long 0x0b5f8d9f  ; [29]; 0.088854
 .long 0xf4a07262  ; [541]; -0.088854
 .long 0x7f7e648b  ; [541]; 0.996045
 .long 0x521c0cc1  ; [285]; 0.641481
 .long 0x62319b9c  ; [285]; 0.767139
 .long 0x9dce6465  ; [797]; -0.767139
 .long 0x521c0cc1  ; [797]; 0.641481
 .long 0x716fbd67  ; [157]; 0.886223
 .long 0x3b4c18b9  ; [157]; 0.463260
 .long 0xc4b3e748  ; [669]; -0.463260
 .long 0x716fbd67  ; [669]; 0.886223
 .long 0x26483f6c  ; [413]; 0.299080
 .long 0x7a24256e  ; [413]; 0.954228
 .long 0x85dbda93  ; [925]; -0.954228
 .long 0x26483f6c  ; [925]; 0.299080
 .long 0x7ad33d44  ; [93]; 0.959572
 .long 0x24070b07  ; [93]; 0.281465
 .long 0xdbf8f4fa  ; [605]; -0.281465
 .long 0x7ad33d44  ; [605]; 0.959572
 .long 0x3d600d2b  ; [349]; 0.479494
 .long 0x70536770  ; [349]; 0.877545
 .long 0x8fac9891  ; [861]; -0.877545
 .long 0x3d600d2b  ; [861]; 0.479494
 .long 0x63b0426c  ; [221]; 0.778817
 .long 0x5049c998  ; [221]; 0.627252
 .long 0xafb63669  ; [733]; -0.627252
 .long 0x63b0426c  ; [733]; 0.778817
 .long 0x0db7d376  ; [477]; 0.107172
 .long 0x7f434562  ; [477]; 0.994240
 .long 0x80bcba9f  ; [989]; -0.994240
 .long 0x0db7d376  ; [989]; 0.107172
 .long 0x7dc3d90c  ; [61]; 0.982539
 .long 0x17d0a7bc  ; [61]; 0.186055
 .long 0xe82f5845  ; [573]; -0.186055
 .long 0x7dc3d90c  ; [573]; 0.982539
 .long 0x4816ea85  ; [317]; 0.563199
 .long 0x69c4e37a  ; [317]; 0.826321
 .long 0x963b1c87  ; [829]; -0.826321
 .long 0x4816ea85  ; [829]; 0.563199
 .long 0x6b13fef4  ; [189]; 0.836548
 .long 0x4621647c  ; [189]; 0.547894
 .long 0xb9de9b85  ; [701]; -0.547894
 .long 0x6b13fef4  ; [701]; 0.836548
 .long 0x1a203e1b  ; [445]; 0.204109
 .long 0x7d4e2c7e  ; [445]; 0.978948
 .long 0x82b1d383  ; [957]; -0.978948
 .long 0x1a203e1b  ; [957]; 0.204109
 .long 0x76b3d0b3  ; [125]; 0.927363
 .long 0x2fe49ba7  ; [125]; 0.374164
 .long 0xd01b645a  ; [637]; -0.374164
 .long 0x76b3d0b3  ; [637]; 0.927363
 .long 0x3211df03  ; [381]; 0.391170
 .long 0x75ccfd41  ; [381]; 0.920318
 .long 0x8a3302c0  ; [893]; -0.920318
 .long 0x3211df03  ; [893]; 0.391170
 .long 0x5b56bfbc  ; [253]; 0.713585
 .long 0x59ac3cfd  ; [253]; 0.700569
 .long 0xa653c304  ; [765]; -0.700569
 .long 0x5b56bfbc  ; [765]; 0.713585
 .long 0x012d96b1  ; [509]; 0.009204
 .long 0x7ffe9cb1  ; [509]; 0.999958
 .long 0x80016350  ; [1021]; -0.999958
 .long 0x012d96b1  ; [1021]; 0.009204
 .long 0x7ffe9cb1  ; [3]; 0.999958
 .long 0x012d96b1  ; [3]; 0.009204
 .long 0xfed26950  ; [515]; -0.009204
 .long 0x7ffe9cb1  ; [515]; 0.999958
 .long 0x59ac3cfd  ; [259]; 0.700569
 .long 0x5b56bfbc  ; [259]; 0.713585
 .long 0xa4a94045  ; [771]; -0.713585
 .long 0x59ac3cfd  ; [771]; 0.700569
 .long 0x75ccfd41  ; [131]; 0.920318
 .long 0x3211df03  ; [131]; 0.391170
 .long 0xcdee20fe  ; [643]; -0.391170
 .long 0x75ccfd41  ; [643]; 0.920318
 .long 0x2fe49ba7  ; [387]; 0.374164
 .long 0x76b3d0b3  ; [387]; 0.927363
 .long 0x894c2f4e  ; [899]; -0.927363
 .long 0x2fe49ba7  ; [899]; 0.374164
 .long 0x7d4e2c7e  ; [67]; 0.978948
 .long 0x1a203e1b  ; [67]; 0.204109
 .long 0xe5dfc1e6  ; [579]; -0.204109
 .long 0x7d4e2c7e  ; [579]; 0.978948
 .long 0x4621647c  ; [323]; 0.547894
 .long 0x6b13fef4  ; [323]; 0.836548
 .long 0x94ec010d  ; [835]; -0.836548
 .long 0x4621647c  ; [835]; 0.547894
 .long 0x69c4e37a  ; [195]; 0.826321
 .long 0x4816ea85  ; [195]; 0.563199
 .long 0xb7e9157c  ; [707]; -0.563199
 .long 0x69c4e37a  ; [707]; 0.826321
 .long 0x17d0a7bc  ; [451]; 0.186055
 .long 0x7dc3d90c  ; [451]; 0.982539
 .long 0x823c26f5  ; [963]; -0.982539
 .long 0x17d0a7bc  ; [963]; 0.186055
 .long 0x7f434562  ; [35]; 0.994240
 .long 0x0db7d376  ; [35]; 0.107172
 .long 0xf2482c8b  ; [547]; -0.107172
 .long 0x7f434562  ; [547]; 0.994240
 .long 0x5049c998  ; [291]; 0.627252
 .long 0x63b0426c  ; [291]; 0.778817
 .long 0x9c4fbd95  ; [803]; -0.778817
 .long 0x5049c998  ; [803]; 0.627252
 .long 0x70536770  ; [163]; 0.877545
 .long 0x3d600d2b  ; [163]; 0.479494
 .long 0xc29ff2d6  ; [675]; -0.479494
 .long 0x70536770  ; [675]; 0.877545
 .long 0x24070b07  ; [419]; 0.281465
 .long 0x7ad33d44  ; [419]; 0.959572
 .long 0x852cc2bd  ; [931]; -0.959572
 .long 0x24070b07  ; [931]; 0.281465
 .long 0x7a24256e  ; [99]; 0.954228
 .long 0x26483f6c  ; [99]; 0.299080
 .long 0xd9b7c095  ; [611]; -0.299080
 .long 0x7a24256e  ; [611]; 0.954228
 .long 0x3b4c18b9  ; [355]; 0.463260
 .long 0x716fbd67  ; [355]; 0.886223
 .long 0x8e90429a  ; [867]; -0.886223
 .long 0x3b4c18b9  ; [867]; 0.463260
 .long 0x62319b9c  ; [227]; 0.767139
 .long 0x521c0cc1  ; [227]; 0.641481
 .long 0xade3f340  ; [739]; -0.641481
 .long 0x62319b9c  ; [739]; 0.767139
 .long 0x0b5f8d9f  ; [483]; 0.088854
 .long 0x7f7e648b  ; [483]; 0.996045
 .long 0x80819b76  ; [995]; -0.996045
 .long 0x0b5f8d9f  ; [995]; 0.088854
 .long 0x7fc85853  ; [19]; 0.998302
 .long 0x077501be  ; [19]; 0.058258
 .long 0xf88afe43  ; [531]; -0.058258
 .long 0x7fc85853  ; [531]; 0.998302
 .long 0x55153fd4  ; [275]; 0.664711
 .long 0x5fa0fe1e  ; [275]; 0.747101
 .long 0xa05f01e3  ; [787]; -0.747101
 .long 0x55153fd4  ; [787]; 0.664711
 .long 0x7333b882  ; [147]; 0.900016
 .long 0x37ca2a30  ; [147]; 0.435857
 .long 0xc835d5d1  ; [659]; -0.435857
 .long 0x7333b882  ; [659]; 0.900016
 .long 0x2a02c7b8  ; [403]; 0.328210
 .long 0x78e8cfb1  ; [403]; 0.944605
 .long 0x87173050  ; [915]; -0.944605
 .long 0x2a02c7b8  ; [915]; 0.328210
 .long 0x7bdf5b93  ; [83]; 0.967754
 .long 0x203e300d  ; [83]; 0.251898
 .long 0xdfc1cff4  ; [595]; -0.251898
 .long 0x7bdf5b93  ; [595]; 0.967754
 .long 0x40cab957  ; [339]; 0.506187
 .long 0x6e63e87f  ; [339]; 0.862424
 .long 0x919c1782  ; [851]; -0.862424
 .long 0x40cab957  ; [851]; 0.506187
 .long 0x661abbc4  ; [211]; 0.797691
 .long 0x4d31494a  ; [211]; 0.603067
 .long 0xb2ceb6b7  ; [723]; -0.603067
 .long 0x661abbc4  ; [723]; 0.797691
 .long 0x119d8941  ; [467]; 0.137620
 .long 0x7ec83719  ; [467]; 0.990485
 .long 0x8137c8e8  ; [979]; -0.990485
 .long 0x119d8941  ; [979]; 0.137620
 .long 0x7e6fb5f3  ; [51]; 0.987784
 .long 0x13f22f58  ; [51]; 0.155828
 .long 0xec0dd0a9  ; [563]; -0.155828
 .long 0x7e6fb5f3  ; [563]; 0.987784
 .long 0x4b4ccf4d  ; [307]; 0.588282
 .long 0x67820bb6  ; [307]; 0.808656
 .long 0x987df44b  ; [819]; -0.808656
 .long 0x4b4ccf4d  ; [819]; 0.588282
 .long 0x6d2dd027  ; [179]; 0.852961
 .long 0x42d0161e  ; [179]; 0.521975
 .long 0xbd2fe9e3  ; [691]; -0.521975
 .long 0x6d2dd027  ; [691]; 0.852961
 .long 0x1df5163f  ; [435]; 0.234042
 .long 0x7c71eaf8  ; [435]; 0.972226
 .long 0x838e1509  ; [947]; -0.972226
 .long 0x1df5163f  ; [947]; 0.234042
 .long 0x781d9b64  ; [115]; 0.938404
 .long 0x2c3ab2b9  ; [115]; 0.345541
 .long 0xd3c54d48  ; [627]; -0.345541
 .long 0x781d9b64  ; [627]; 0.938404
 .long 0x35a8e624  ; [371]; 0.419217
 .long 0x74359cbc  ; [371]; 0.907886
 .long 0x8bca6345  ; [883]; -0.907886
 .long 0x35a8e624  ; [883]; 0.419217
 .long 0x5e0bec6e  ; [243]; 0.734739
 .long 0x56d42c99  ; [243]; 0.678350
 .long 0xa92bd368  ; [755]; -0.678350
 .long 0x5e0bec6e  ; [755]; 0.734739
 .long 0x051a8e5c  ; [499]; 0.039873
 .long 0x7fe5f107  ; [499]; 0.999205
 .long 0x801a0efa  ; [1011]; -0.999205
 .long 0x051a8e5c  ; [1011]; 0.039873
 .long 0x7fed5790  ; [11]; 0.999431
 .long 0x0451a177  ; [11]; 0.033741
 .long 0xfbae5e8a  ; [523]; -0.033741
 .long 0x7fed5790  ; [523]; 0.999431
 .long 0x57677b9c  ; [267]; 0.682846
 .long 0x5d8314b0  ; [267]; 0.730563
 .long 0xa27ceb51  ; [779]; -0.730563
 .long 0x57677b9c  ; [779]; 0.682846
 .long 0x7489571b  ; [139]; 0.910441
 .long 0x34f219a7  ; [139]; 0.413638
 .long 0xcb0de65a  ; [651]; -0.413638
 .long 0x7489571b  ; [651]; 0.910441
 .long 0x2cf72939  ; [395]; 0.351293
 .long 0x77d78da9  ; [395]; 0.936266
 .long 0x88287258  ; [907]; -0.936266
 .long 0x2cf72939  ; [907]; 0.351293
 .long 0x7ca05ff0  ; [75]; 0.973644
 .long 0x1d31774d  ; [75]; 0.228072
 .long 0xe2ce88b4  ; [587]; -0.228072
 .long 0x7ca05ff0  ; [587]; 0.973644
 .long 0x437b42e1  ; [331]; 0.527199
 .long 0x6cc45697  ; [331]; 0.849742
 .long 0x933ba96a  ; [843]; -0.849742
 .long 0x437b42e1  ; [843]; 0.527199
 .long 0x67f7d3c4  ; [203]; 0.812251
 .long 0x4aa9dba1  ; [203]; 0.583309
 .long 0xb5562460  ; [715]; -0.583309
 .long 0x67f7d3c4  ; [715]; 0.812251
 .long 0x14b8b17f  ; [459]; 0.161886
 .long 0x7e4fc53d  ; [459]; 0.986809
 .long 0x81b03ac4  ; [971]; -0.986809
 .long 0x14b8b17f  ; [971]; 0.161886
 .long 0x7ee34635  ; [43]; 0.991311
 .long 0x10d64dbd  ; [43]; 0.131540
 .long 0xef29b244  ; [555]; -0.131540
 .long 0x7ee34635  ; [555]; 0.991311
 .long 0x4dd14c6d  ; [299]; 0.607950
 .long 0x65a0fd0a  ; [299]; 0.793975
 .long 0x9a5f02f7  ; [811]; -0.793975
 .long 0x4dd14c6d  ; [811]; 0.607950
 .long 0x6ec92682  ; [171]; 0.865514
 .long 0x401d0320  ; [171]; 0.500885
 .long 0xbfe2fce1  ; [683]; -0.500885
 .long 0x6ec92682  ; [683]; 0.865514
 .long 0x21009c0c  ; [427]; 0.257831
 .long 0x7bac1d30  ; [427]; 0.966190
 .long 0x8453e2d1  ; [939]; -0.966190
 .long 0x21009c0c  ; [939]; 0.257831
 .long 0x792a37fd  ; [107]; 0.946601
 .long 0x2944a7a2  ; [107]; 0.322408
 .long 0xd6bb585f  ; [619]; -0.322408
 .long 0x792a37fd  ; [619]; 0.946601
 .long 0x387eda8e  ; [363]; 0.441371
 .long 0x72db8827  ; [363]; 0.897325
 .long 0x8d2477da  ; [875]; -0.897325
 .long 0x387eda8e  ; [875]; 0.441371
 .long 0x60262dd5  ; [235]; 0.751165
 .long 0x547ea073  ; [235]; 0.660114
 .long 0xab815f8e  ; [747]; -0.660114
 .long 0x60262dd5  ; [747]; 0.751165
 .long 0x083db0a7  ; [491]; 0.064383
 .long 0x7fbc0409  ; [491]; 0.997925
 .long 0x8043fbf8  ; [1003]; -0.997925
 .long 0x083db0a7  ; [1003]; 0.064383
 .long 0x7f8fa4af  ; [27]; 0.996571
 .long 0x0a973ba5  ; [27]; 0.082740
 .long 0xf568c45c  ; [539]; -0.082740
 .long 0x7f8fa4af  ; [539]; 0.996571
 .long 0x52b5e545  ; [283]; 0.646176
 .long 0x61b02876  ; [283]; 0.763188
 .long 0x9e4fd78b  ; [795]; -0.763188
 .long 0x52b5e545  ; [795]; 0.646176
 .long 0x71cc5626  ; [155]; 0.889048
 .long 0x3a99a057  ; [155]; 0.457813
 .long 0xc5665faa  ; [667]; -0.457813
 .long 0x71cc5626  ; [667]; 0.889048
 .long 0x2707ebc6  ; [411]; 0.304929
 .long 0x79e76ca6  ; [411]; 0.952375
 .long 0x8618935b  ; [923]; -0.952375
 .long 0x2707ebc6  ; [923]; 0.304929
 .long 0x7b0b3d2b  ; [91]; 0.961280
 .long 0x2345eff8  ; [91]; 0.275572
 .long 0xdcba1009  ; [603]; -0.275572
 .long 0x7b0b3d2b  ; [603]; 0.961280
 .long 0x3e10320d  ; [347]; 0.484869
 .long 0x6ff27496  ; [347]; 0.874587
 .long 0x900d8b6b  ; [859]; -0.874587
 .long 0x3e10320d  ; [859]; 0.484869
 .long 0x642de50d  ; [219]; 0.782651
 .long 0x4faccfaa  ; [219]; 0.622461
 .long 0xb0533057  ; [731]; -0.622461
 .long 0x642de50d  ; [731]; 0.782651
 .long 0x0e7fa99d  ; [475]; 0.113271
 .long 0x7f2d1c0d  ; [475]; 0.993564
 .long 0x80d2e3f4  ; [987]; -0.993564
 .long 0x0e7fa99d  ; [987]; 0.113271
 .long 0x7de8a66f  ; [59]; 0.983662
 .long 0x170afd8d  ; [59]; 0.180023
 .long 0xe8f50274  ; [571]; -0.180023
 .long 0x7de8a66f  ; [571]; 0.983662
 .long 0x48bcb598  ; [315]; 0.568259
 .long 0x69532441  ; [315]; 0.822850
 .long 0x96acdbc0  ; [827]; -0.822850
 .long 0x48bcb598  ; [827]; 0.568259
 .long 0x6b81a3cc  ; [187]; 0.839894
 .long 0x4578db93  ; [187]; 0.542751
 .long 0xba87246e  ; [699]; -0.542751
 .long 0x6b81a3cc  ; [699]; 0.839894
 .long 0x1ae4f1d6  ; [443]; 0.210112
 .long 0x7d24881a  ; [443]; 0.977677
 .long 0x82db77e7  ; [955]; -0.977677
 .long 0x1ae4f1d6  ; [955]; 0.210112
 .long 0x76fe790d  ; [123]; 0.929641
 .long 0x2f29ebcc  ; [123]; 0.368467
 .long 0xd0d61435  ; [635]; -0.368467
 .long 0x76fe790d  ; [635]; 0.929641
 .long 0x32caab6f  ; [379]; 0.396810
 .long 0x757dc5c9  ; [379]; 0.917901
 .long 0x8a823a38  ; [891]; -0.917901
 .long 0x32caab6f  ; [891]; 0.396810
 .long 0x5be32a66  ; [251]; 0.717870
 .long 0x591c550d  ; [251]; 0.696177
 .long 0xa6e3aaf4  ; [763]; -0.696177
 .long 0x5be32a66  ; [763]; 0.717870
 .long 0x01f6a297  ; [507]; 0.015339
 .long 0x7ffc250e  ; [507]; 0.999882
 .long 0x8003daf3  ; [1019]; -0.999882
 .long 0x01f6a297  ; [1019]; 0.015339
 .long 0x7ff871a1  ; [7]; 0.999769
 .long 0x02bfa9a4  ; [7]; 0.021474
 .long 0xfd40565d  ; [519]; -0.021474
 .long 0x7ff871a1  ; [519]; 0.999769
 .long 0x588b913f  ; [263]; 0.691759
 .long 0x5c6eb258  ; [263]; 0.722128
 .long 0xa3914da9  ; [775]; -0.722128
 .long 0x588b913f  ; [775]; 0.691759
 .long 0x752d6c6b  ; [135]; 0.915449
 .long 0x3382fa88  ; [135]; 0.402435
 .long 0xcc7d0579  ; [647]; -0.402435
 .long 0x752d6c6b  ; [647]; 0.915449
 .long 0x2e6ec792  ; [391]; 0.362756
 .long 0x7747fbcd  ; [391]; 0.931884
 .long 0x88b80434  ; [903]; -0.931884
 .long 0x2e6ec792  ; [903]; 0.362756
 .long 0x7cf9aeef  ; [71]; 0.976370
 .long 0x1ba96335  ; [71]; 0.216107
 .long 0xe4569ccc  ; [583]; -0.216107
 .long 0x7cf9aeef  ; [583]; 0.976370
 .long 0x44cfa73f  ; [327]; 0.537587
 .long 0x6bee3f62  ; [327]; 0.843208
 .long 0x9411c09f  ; [839]; -0.843208
 .long 0x44cfa73f  ; [839]; 0.537587
 .long 0x68e06129  ; [199]; 0.819348
 .long 0x4961cd32  ; [199]; 0.573297
 .long 0xb69e32cf  ; [711]; -0.573297
 .long 0x68e06129  ; [711]; 0.819348
 .long 0x16451a83  ; [455]; 0.173984
 .long 0x7e0c3d28  ; [455]; 0.984749
 .long 0x81f3c2d9  ; [967]; -0.984749
 .long 0x16451a83  ; [967]; 0.173984
 .long 0x7f15b8ed  ; [39]; 0.992850
 .long 0x0f475bff  ; [39]; 0.119365
 .long 0xf0b8a402  ; [551]; -0.119365
 .long 0x7f15b8ed  ; [551]; 0.992850
 .long 0x4f0f1125  ; [295]; 0.617647
 .long 0x64aa907e  ; [295]; 0.786455
 .long 0x9b556f83  ; [807]; -0.786455
 .long 0x4f0f1125  ; [807]; 0.617647
 .long 0x6f906d83  ; [167]; 0.871595
 .long 0x3ebfbdcc  ; [167]; 0.490226
 .long 0xc1404235  ; [679]; -0.490226
 .long 0x6f906d83  ; [679]; 0.871595
 .long 0x22847ddf  ; [423]; 0.269668
 .long 0x7b420d79  ; [423]; 0.962953
 .long 0x84bdf288  ; [935]; -0.962953
 .long 0x22847ddf  ; [935]; 0.269668
 .long 0x79a98715  ; [103]; 0.950486
 .long 0x27c737d3  ; [103]; 0.310767
 .long 0xd838c82e  ; [615]; -0.310767
 .long 0x79a98715  ; [615]; 0.950486
 .long 0x39e6975d  ; [359]; 0.452350
 .long 0x7227d61b  ; [359]; 0.891841
 .long 0x8dd829e6  ; [871]; -0.891841
 .long 0x39e6975d  ; [871]; 0.452350
 .long 0x612dc446  ; [231]; 0.759209
 .long 0x534ef1b5  ; [231]; 0.650847
 .long 0xacb10e4c  ; [743]; -0.650847
 .long 0x612dc446  ; [743]; 0.759209
 .long 0x09cecf89  ; [487]; 0.076624
 .long 0x7f9faa14  ; [487]; 0.997060
 .long 0x806055ed  ; [999]; -0.997060
 .long 0x09cecf89  ; [999]; 0.076624
 .long 0x7fae7494  ; [23]; 0.997511
 .long 0x09064b3a  ; [23]; 0.070505
 .long 0xf6f9b4c7  ; [535]; -0.070505
 .long 0x7fae7494  ; [535]; 0.997511
 .long 0x53e73097  ; [279]; 0.655493
 .long 0x60aa704f  ; [279]; 0.755201
 .long 0x9f558fb2  ; [791]; -0.755201
 .long 0x53e73097  ; [791]; 0.655493
 .long 0x72823c66  ; [151]; 0.894599
 .long 0x3932ff87  ; [151]; 0.446869
 .long 0xc6cd007a  ; [663]; -0.446869
 .long 0x72823c66  ; [663]; 0.894599
 .long 0x288621b9  ; [407]; 0.316593
 .long 0x796a7553  ; [407]; 0.948561
 .long 0x86958aae  ; [919]; -0.948561
 .long 0x288621b9  ; [919]; 0.316593
 .long 0x7b77ada7  ; [87]; 0.964590
 .long 0x21c2b69c  ; [87]; 0.263755
 .long 0xde3d4965  ; [599]; -0.263755
 .long 0x7b77ada7  ; [599]; 0.964590
 .long 0x3f6eaeb8  ; [343]; 0.495565
 .long 0x6f2d532b  ; [343]; 0.868571
 .long 0x90d2acd6  ; [855]; -0.868571
 .long 0x3f6eaeb8  ; [855]; 0.495565
 .long 0x6526438e  ; [215]; 0.790230
 .long 0x4e708f8f  ; [215]; 0.612810
 .long 0xb18f7072  ; [727]; -0.612810
 .long 0x6526438e  ; [727]; 0.790230
 .long 0x100ee8ad  ; [471]; 0.125455
 .long 0x7efd1c3b  ; [471]; 0.992099
 .long 0x8102e3c6  ; [983]; -0.992099
 .long 0x100ee8ad  ; [983]; 0.125455
 .long 0x7e2e9cde  ; [55]; 0.985798
 .long 0x157f0086  ; [55]; 0.167938
 .long 0xea80ff7b  ; [567]; -0.167938
 .long 0x7e2e9cde  ; [567]; 0.985798
 .long 0x4a062fbd  ; [311]; 0.578314
 .long 0x686c9b4a  ; [311]; 0.815814
 .long 0x979364b7  ; [823]; -0.815814
 .long 0x4a062fbd  ; [823]; 0.578314
 .long 0x6c59d0a8  ; [183]; 0.846491
 .long 0x4425c923  ; [183]; 0.532403
 .long 0xbbda36de  ; [695]; -0.532403
 .long 0x6c59d0a8  ; [695]; 0.846491
 .long 0x1c6d9053  ; [439]; 0.222094
 .long 0x7ccda168  ; [439]; 0.975025
 .long 0x83325e99  ; [951]; -0.975025
 .long 0x1c6d9053  ; [951]; 0.222094
 .long 0x7790583d  ; [119]; 0.934093
 .long 0x2db330c7  ; [119]; 0.357031
 .long 0xd24ccf3a  ; [631]; -0.357031
 .long 0x7790583d  ; [631]; 0.934093
 .long 0x343aca87  ; [375]; 0.408044
 .long 0x74dbf1ee  ; [375]; 0.912962
 .long 0x8b240e13  ; [887]; -0.912962
 .long 0x343aca87  ; [887]; 0.408044
 .long 0x5cf95637  ; [247]; 0.726359
 .long 0x57f9f2f7  ; [247]; 0.687315
 .long 0xa8060d0a  ; [759]; -0.687315
 .long 0x5cf95637  ; [759]; 0.726359
 .long 0x0388a9ea  ; [503]; 0.027608
 .long 0x7ff38273  ; [503]; 0.999619
 .long 0x800c7d8e  ; [1015]; -0.999619
 .long 0x0388a9ea  ; [1015]; 0.027608
 .long 0x7fdd4eeb  ; [15]; 0.998941
 .long 0x05e36ea9  ; [15]; 0.046003
 .long 0xfa1c9158  ; [527]; -0.046003
 .long 0x7fdd4eeb  ; [527]; 0.998941
 .long 0x56400757  ; [271]; 0.673829
 .long 0x5e93dc1e  ; [271]; 0.738887
 .long 0xa16c23e3  ; [783]; -0.738887
 .long 0x56400757  ; [783]; 0.673829
 .long 0x73e0c3a2  ; [143]; 0.905297
 .long 0x365f2e3b  ; [143]; 0.424780
 .long 0xc9a0d1c6  ; [655]; -0.424780
 .long 0x73e0c3a2  ; [655]; 0.905297
 .long 0x2b7dcf17  ; [399]; 0.339777
 .long 0x786280bf  ; [399]; 0.940506
 .long 0x879d7f42  ; [911]; -0.940506
 .long 0x2b7dcf17  ; [911]; 0.339777
 .long 0x7c4242f1  ; [79]; 0.970772
 .long 0x1eb86b46  ; [79]; 0.240003
 .long 0xe14794bb  ; [591]; -0.240003
 .long 0x7c4242f1  ; [591]; 0.970772
 .long 0x42244480  ; [335]; 0.516732
 .long 0x6d963c53  ; [335]; 0.856147
 .long 0x9269c3ae  ; [847]; -0.856147
 .long 0x42244480  ; [847]; 0.516732
 .long 0x670b4443  ; [207]; 0.805031
 .long 0x4bef092c  ; [207]; 0.593232
 .long 0xb410f6d5  ; [719]; -0.593232
 .long 0x670b4443  ; [719]; 0.805031
 .long 0x132b7bf9  ; [463]; 0.149765
 .long 0x7e8e6eb1  ; [463]; 0.988722
 .long 0x81719150  ; [975]; -0.988722
 .long 0x132b7bf9  ; [975]; 0.149765
 .long 0x7eabef2b  ; [47]; 0.989622
 .long 0x1264994e  ; [47]; 0.143695
 .long 0xed9b66b3  ; [559]; -0.143695
 .long 0x7eabef2b  ; [559]; 0.989622
 .long 0x4c9087b1  ; [303]; 0.598161
 .long 0x66937e90  ; [303]; 0.801376
 .long 0x996c8171  ; [815]; -0.801376
 .long 0x4c9087b1  ; [815]; 0.598161
 .long 0x6dfd9a1b  ; [175]; 0.859302
 .long 0x4177cfb0  ; [175]; 0.511469
 .long 0xbe883051  ; [687]; -0.511469
 .long 0x6dfd9a1b  ; [687]; 0.859302
 .long 0x1f7b7480  ; [431]; 0.245955
 .long 0x7c116852  ; [431]; 0.969281
 .long 0x83ee97af  ; [943]; -0.969281
 .long 0x1f7b7480  ; [943]; 0.245955
 .long 0x78a63d10  ; [111]; 0.942573
 .long 0x2ac08026  ; [111]; 0.334000
 .long 0xd53f7fdb  ; [623]; -0.334000
 .long 0x78a63d10  ; [623]; 0.942573
 .long 0x3714f02a  ; [367]; 0.430326
 .long 0x738acc9d  ; [367]; 0.902673
 .long 0x8c753364  ; [879]; -0.902673
 .long 0x3714f02a  ; [879]; 0.430326
 .long 0x5f1ae273  ; [239]; 0.743008
 .long 0x55ab0d46  ; [239]; 0.669283
 .long 0xaa54f2bb  ; [751]; -0.669283
 .long 0x5f1ae273  ; [751]; 0.743008
 .long 0x06ac406f  ; [495]; 0.052132
 .long 0x7fd37152  ; [495]; 0.998640
 .long 0x802c8eaf  ; [1007]; -0.998640
 .long 0x06ac406f  ; [1007]; 0.052132
 .long 0x7f6be9d3  ; [31]; 0.995481
 .long 0x0c27c389  ; [31]; 0.094963
 .long 0xf3d83c78  ; [543]; -0.094963
 .long 0x7f6be9d3  ; [543]; 0.995481
 .long 0x518169a4  ; [287]; 0.636762
 .long 0x62b21c7b  ; [287]; 0.771061
 .long 0x9d4de386  ; [799]; -0.771061
 .long 0x518169a4  ; [799]; 0.636762
 .long 0x71120cc4  ; [159]; 0.883363
 .long 0x3bfdfecd  ; [159]; 0.468689
 .long 0xc4020134  ; [671]; -0.468689
 .long 0x71120cc4  ; [671]; 0.883363
 .long 0x2588349d  ; [415]; 0.293219
 .long 0x7a5fb0d7  ; [415]; 0.956045
 .long 0x85a04f2a  ; [927]; -0.956045
 .long 0x2588349d  ; [927]; 0.293219
 .long 0x7a9a0e4f  ; [95]; 0.957826
 .long 0x24c7cd32  ; [95]; 0.287347
 .long 0xdb3832cf  ; [607]; -0.287347
 .long 0x7a9a0e4f  ; [607]; 0.957826
 .long 0x3caf50da  ; [351]; 0.474100
 .long 0x70b34524  ; [351]; 0.880471
 .long 0x8f4cbadd  ; [863]; -0.880471
 .long 0x3caf50da  ; [863]; 0.474100
 .long 0x6331a9d4  ; [223]; 0.774953
 .long 0x50e5fd6c  ; [223]; 0.632019
 .long 0xaf1a0295  ; [735]; -0.632019
 .long 0x6331a9d4  ; [735]; 0.774953
 .long 0x0cefdb75  ; [479]; 0.101070
 .long 0x7f5834b6  ; [479]; 0.994879
 .long 0x80a7cb4b  ; [991]; -0.994879
 .long 0x0cefdb75  ; [991]; 0.101070
 .long 0x7d9dd559  ; [63]; 0.981379
 .long 0x18961728  ; [63]; 0.192080
 .long 0xe769e8d9  ; [575]; -0.192080
 .long 0x7d9dd559  ; [575]; 0.981379
 .long 0x47706d93  ; [319]; 0.558119
 .long 0x6a359db8  ; [319]; 0.829761
 .long 0x95ca6249  ; [831]; -0.829761
 .long 0x47706d93  ; [831]; 0.558119
 .long 0x6aa551e8  ; [191]; 0.833170
 .long 0x46c9405c  ; [191]; 0.553017
 .long 0xb936bfa5  ; [703]; -0.553017
 .long 0x6aa551e8  ; [703]; 0.833170
 .long 0x195b49ea  ; [447]; 0.198098
 .long 0x7d769bb4  ; [447]; 0.980182
 .long 0x8289644d  ; [959]; -0.980182
 .long 0x195b49ea  ; [959]; 0.198098
 .long 0x76680375  ; [127]; 0.925049
 .long 0x309ed556  ; [127]; 0.379847
 .long 0xcf612aab  ; [639]; -0.379847
 .long 0x76680375  ; [639]; 0.925049
 .long 0x3158970d  ; [383]; 0.385516
 .long 0x761b1210  ; [383]; 0.922701
 .long 0x89e4edf1  ; [895]; -0.922701
 .long 0x3158970d  ; [895]; 0.385516
 .long 0x5ac973b4  ; [255]; 0.709273
 .long 0x5a3b47aa  ; [255]; 0.704934
 .long 0xa5c4b857  ; [767]; -0.704934
 .long 0x5ac973b4  ; [767]; 0.709273
 .long 0x006487e3  ; [511]; 0.003068
 .long 0x7fffd885  ; [511]; 0.999995
 .long 0x8000277c  ; [1023]; -0.999995
 .long 0x006487e3  ; [1023]; 0.003068
 
  	.global _twiddle

unpack.asm/     1161799871  0     0     0       7158      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function UNPACK
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpack(DATA *xy, ushort nx);
;
; Copyright Texas instruments Inc, 2000
; History;
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

                .mmregs
                .cpl_on
                .arms_off
                .ref twiddle

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

                .sect ".fftcode"
                .global _unpack

_unpack:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

            AADD        #-2,SP                        ; create local frame
            MOV         pair(T2),dbl(*SP(#00h))       ; save on entry

;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

Initialize:
            AND         #0FF00h,mmap(ST2_55)    ; linear addr for CDP,AR2,AR3,AR0, AR1

            BSET        #6,ST1_55               ; set FRCT
            BSET        #8,ST1_55               ; set SXMD
            BSET        #9,ST1_55               ; set SATD
            BCLR        #15,ST2_55              ; reset ARMS
            BCLR        #10,ST1_55              ; reset M40

;//-----------------------------------------------------------------------------
;// Unpack for RFFT
;//-----------------------------------------------------------------------------
            MOV         XAR0,XAR1               ; AR1 = pointer to input data = rm[0]
            ADD         T0,AR1                  ; AR1 = pointer to input data = rm[N]
            SFTS        T0,#-1                  ; T0 = RFFT size/2 (req. for loop)
            MOV         T0,T1                   ; T1 = T0 = RFFT size/2
            SFTS        T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
            SUB         #2,AR1                  ; element in the data buffer
            SUB         #2,T1                   ; loop = N/4 - 2
            MOV         T1,BRC0                 ; and store in repeat counter
            MOV         #-1,T2
            AMOV        #twiddle,XAR2           ; pointer to sin and cos tables
            AMOV        #(twiddle+1),XAR3       ; 
            AMAR        *(AR2+T0B)              ; set to 2nd entry of bit reversed
            AMAR        *(AR3+T0B)              ; sin/cos table 
;--------------------------------------------------------------------------------
; process yre[0] (DC) and yre[0] (Nyquist)
; yre[0] = xre[0] + xim[0]    store in yre[0] 
; yre[N] = xre[0] - xim[0]    store in yim[0]
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
            MOV         *AR0+ << #16,AC1               ; AC1=xre[0]
            ADD         *AR0 << #16,AC1,AC0            ; AC0 = xre[0] + xim[0]
            SUB         *AR0- << #16,AC1,AC1           ; AC1 = xre[0] - xim[0]
            MOV			HI(AC0 << #-1), *AR0+          ; yre[0]=0.5*xre[0]+xim[0]
            MOV			HI(AC1 << #-1), *AR0+          ; yim[0]=0.5*xre[0]-xim[0]
;--------------------------------------------------------------------------------
; process y1re[1]/im[1] ...
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
            RPTB        unpack_end              ; setup loopcounter (RFFT-size)/4 - 2
             ADD         *AR0,*AR1,AC0          ; rp = AC0 = x1Re + x2Re
             SUB         *AR0+,*AR1+,AC3        ; im = AC3 = x1Re - x2Re
             SUB         *AR1,*AR0,AC1          ; ip = AC1 = x2Im - x1Im
             ADD         *AR0-,*AR1-,AC2        ; rm = AC2 = x1Im + x2Im
             SFTS        AC2,#-1,AC2            ; rm = 0.5*AC2 = 0.5*(x1Im+x2Im)
             SFTS        AC3,#-1,AC3            ; im = 0.5*AC3 = 0.5*(x1Re-x2Re)
             SFTS        AC0,#-1,AC0            ; rp = 0.5*AC0 = 0.5*(x1Re+x2Re)
             SFTS        AC1,#-1,AC1            ; ip = 0.5*AC1 = 0.5*(x2Im-x1Im)
             MOV         HI(AC2),T1             ; save rm to T1
             MOV         HI(AC3),T3             ; save im to T3
;-----------------------------------------------------------------------
             MASM        *AR2,T1,AC0,AC2        ; y2re=AC2=rp-cos*rm
             MASM        *AR2,T3,AC1,AC3        ; y2im=AC3=ip-cos*im
             MACM        *AR2,T1,AC0,AC0        ; y1re=AC0=rp+cos*rm
             NEG         AC1,AC1
             MASM        *(AR2+T0B),T3,AC1,AC1  ; y1im=AC1=-ip-cos*im
;-----------------------------------------------------------------------
             ; y1re=rp+cos*rm-sin*im
             MASM        *AR3,T3,AC0,AC0        
             ; y1im=-ip-cos*im-sin*rm
             MASM        *AR3,T1,AC1,AC1 :: MOV         HI(AC0<<T2),*AR0+        
             ; y2re=rp-cos*rm+sin*im
             MACM        *AR3,T3,AC2,AC2 :: MOV         HI(AC1<<T2),*AR0+       
             ; y2im=ip-cos*im-sin*rm
             MASM        *(AR3+T0B),T1,AC3,AC3 
             MOV         HI(AC2<<T2),*AR1+
             MOV         HI(AC3<<T2),*AR1 
unpack_end:  SUB         #3,AR1                         ; adjust to next rm
;//-----------------------------------------------------------------------------
;       yre(N/2) = yre(N/2)
;       yim(N/2) = - yim(N/2)
;
;  Scaling by 2 added to avoid overflow
;//-----------------------------------------------------------------------------
            MOV         dbl(*AR0),pair(HI(AC0))
            NEG         AC1,AC1
            SFTS        AC0,#-1,AC0            
            SFTS        AC1,#-1,AC1            
            MOV         pair(HI(AC0)),dbl(*AR0)
;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------
            MOV         dbl(*SP(#00h)),pair(T2)
            AADD        #2,SP                  ; destroy local frame
;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
            RET

        .end
unpack32.asm/   1161799865  0     0     0       16652     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function UNPACK32
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpack(DATA *xy, ushort nx);
;
; Copyright Texas instruments Inc, 2000
; History;
;	- 11/20/2003	C. Iovescu initial implementation
;
;************************************************************************************
;
;  DFT of N-point real-valued sequence
;
; Implementation of the rfft based on the equations:
;
;   
;
;  g(n) n=0:N-1 is a real valued sequence. Purpose of the code
;  is to compute the RFFT of this signal: G(k) k=0:N-1 complex sequence. 
;
;  g(n) is split in two real sequences, odd and even part
;    
;          xe(n) = g(2n)    n=0:N/2-1
;          xo(n) = g(2n+1)  n=0:N/2-1
;
;  Form the complex sequence:
;
;         x(n) = xe(n) + jxo(n)  n=0:N/2-1
;
;  Compute the CFFT of x(n):
;
;        X(k) k=0:N/2-1
;
;  Derive from X(k) the CFFT of xe(n) and xo(n) using the equations
;
;       Xe(k) =  0.5  (X(k) + X*(N/2-k))   k=0:N/2-1  (1)
;       Xo(k) = -0.5j (X(k) - X*(N/2-k))   k=0:N/2-1  (2)
;
;  Separate in Real and Imag parts: 
;
;   Define: 
;            Xe(k) =  Xer(k)+jXei(k)
;            Xo(k) =  Xor(k)+jXoi(k)
;
;   Equations (1) and (2) yield:
;
;       Xer(k) =  0.5  (Xr(k) + Xr(N/2-k))   k=0:N/2-1  (3)
;       Xei(k) =  0.5  (Xi(k) - Xi(N/2-k))   k=0:N/2-1  (4)
;       Xor(k) =  0.5  (Xi(k) + Xi(N/2-k))   k=0:N/2-1  (5)
;       Xoi(k) = -0.5  (Xr(k) - Xr(N/2-k))   k=0:N/2-1  (6)
;
;   The previous equations have special values for:
;
;   DC Offset: 
;             k=0     Xer(0)= Xr(0)
;                     Xei(0)= 0
;                     Xor(0)= Xi(0)
;                     Xoi(0)= 0
;
;
;   Nyquist Frequency:
;             k=N/4   Xer(N/4)= Xr(N/4)
;                     Xei(N/4)= 0
;                     Xor(N/4)= Xi(N/4)
;                     Xoi(N/4)= 0
;
;
;    Computing G(k)
;
;    G(k)   = Xe(k) + W(k,N)Xo(k)     k = 0:N/2-1   (7)
;    G(N/2-k) = Xe*(k) - W(-k,N)Xo*(k)  k = 0:N/2-1   (8)
;
;  Separate in Real and Imag parts: 
;
;   Define: 
;            G(k) =  Gr(k)+jGi(k)
;            G(N-k) =  Gr(N-k)+jGi(N-k)
;            W(k,N) = cos(2Pik/N)-jsin(2Pik/N) = Wr(k)-jWi(k)
;
;   Equations (7) and (8) yield:
;
;          Gr(k)     = Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)   (9)
;          Gi(k)     = Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)   (10)
;          Gr(N/2-k) = Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)   (11)
;          Gi(N/2-k) =-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)   (12)
;
;
;  Equations (9) through (12) will be DIVIDED BY TWO in order to avoid
;  overflow.
;
;          Gr(k)     = 0.5[Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]   (13)
;          Gi(k)     = 0.5[Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   (14)
;          Gr(N/2-k) = 0.5[Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]   (15)
;          Gi(N/2-k) =0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   (16)
;
;  Special values:
;        
;     * DC Offset  k = 0                                    (17)
;
;           Gr(0) = 0.5 (Xr(0)+Xi(0)) 
;           Gi(0) = 0
;
;     * k = N/4                                             (18)
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;     * Nyquist Frequency  k = N/2                          (19)
;
;           Gr(N/2) = 0.5 (Xr(0)-Xi(0)) 
;           Gi(N/2) = 0
;
;
;  Practical computation of G(k) k=0:N-1
;      
;      1) Compute G(k) k=0:N/2
;             - G(0),G(N/4), G(N/2) based on special values formulae
;             - G(k) for   (0<k<N/2)
;      2) Deduct G(k) k=N/2+1:N-1 from the values computed in 1) using
;      the complex conjugate symmetry formulae (since g(n) is a real
;      sequence) 
;                   
;              G(k) = G*(N-k)  k=0:N-1
;
;  Algorithm implementation:
;    
;
;     The algorithm computes only G(k) k=0:N/2. In order to store the
;     result in the input array, G(0) and G(N/2) which have zero imag parts are
;     packed together and Gr(N/2) is stored at the location of Gi(0).
;
;        1) Compute Xer(k), Xei(k), Xor(k), Xoi(k) for k=1:N/4-1
;               ( k=0 and k=N/4 are special values)
;
;  
;
;

;****************************************************************

                .mmregs
                .cpl_on
                .arms_off
                .ref twiddle32

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

                .sect ".text:unpack32"
                .global _unpack32

_unpack32:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
  
; upon entry stack aligned on 32-bit boundary
  
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

      AADD        #-21,SP             ; create local frame
	  
	  
;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

Initialize:
            AND         #0FF00h,mmap(ST2_55)    ; linear addr for CDP,AR2,AR3,AR0, AR1

            BSET        #6,ST1_55               ; set FRCT
            BSET        #8,ST1_55               ; set SXMD

            ; SATD = 0 required for 32-bit multiplication
            BCLR        #9,ST1_55               ; set SATD
           
            BCLR        #15,ST2_55              ; reset ARMS
            BCLR        #10,ST1_55              ; reset M40

;//-----------------------------------------------------------------------------
;// Unpack for RFFT
;//
;//  T0 = N (Rfft size) 
;//
;//
;//
;//-----------------------------------------------------------------------------
            MOV         XAR0,XAR1               ; AR0 = start ptr input data = Xr[0]
            ADD         T0,AR1                  ; AR1 = end ptr input data 
            ADD         T0,AR1                  ; 32-bit data 
            MOV         T0,T1                   ; T1 = T0 = RFFT size/2
            SFTS        T1,#-1                  ; T1 = RFFT size/2 
            SFTS        T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
            SUB         #4,AR1                  ; AR1 = Xr[N/2-1] - last 32-bit elt
            SUB         #2,T1                   ; loop = N/4 - 2
            MOV         T1,BRC0                 ; and store in repeat counter
            AMOV        #twiddle32,XAR2         ; pointer to sin and cos tables
            AMOV        #(twiddle32+2),XAR3     ; 32-bit values (add 2)
            AMAR        *(AR2+T0B)              ; set to 2nd entry of bit reversed
            AMAR        *(AR3+T0B)              ; sin/cos table 
												; T0 = RFFT size for bitrev because 32-bit values
			MOV         XSP,XAR4   				; XAR4 local var ptr (stack)
			ADD	        #4, AR4

;--------------------------------------------------------------------------------
; Step1: 
;  Special values G(0) and G(N/2):
;        
;     * DC Offset  k = 0                                    
;
;           Gr(0) = 0.5 (Xr(0)+Xi(0)) 
;           Gi(0) = 0
;
;
;     * Nyquist Frequency  k = N/2                          
;
;           Gr(N/2) = 0.5 (Xr(0)-Xi(0)) 
;           Gi(N/2) = 0
;
;     In order to store G(k) in the input array, Gr(0) and Gr(N/2) 
;     are packed as real&imag values.
;
;--------------------------------------------------------------------------------
            MOV         dbl(*AR0+),AC1           ; AC1 = Xr[0]
            ADD         dbl(*AR0),AC1,AC0        ; AC0 = Xr[0] + Xi[0]          										             
            SUB         dbl(*AR0-),AC1,AC1     	 ; AC1 = Xr[0] - Xi[0]
       
            SFTS		AC0, #-1				 ; 0.5x
            SFTS		AC1, #-1				 ; 0.5x
                      
            MOV			AC0, dbl(*AR0+)          ; Gr(0)
            MOV			AC1, dbl(*AR0+)          ; Gr(N/2)
;--------------------------------------------------------------------------------
; Step 2: 
;
; General loop G(k) k=1:N/2-1  (k<>N/4)
;
;    Xer(k) =  0.5  (Xr(k) + Xr(N/2-k))  k=1:N/4-1  
;    Xei(k) =  0.5  (Xi(k) - Xi(N/2-k))  k=1:N/4-1 
;    Xor(k) =  0.5  (Xi(k) + Xi(N/2-k))  k=1:N/4-1  
;    Xoi(k) = -0.5  (Xr(k) - Xr(N/2-k))  k=1:N/4-1  
;
;--------------------------------------------------------------------------------
            RPTB        unpack_end              ; setup loopcounter (RFFT-size)/4 - 2

            MOV         dbl(*AR1+),AC1          ; AC1= Xr[N/2-k]           								 	
            ADD         dbl(*AR0),AC1,AC0       ; Xer = AC0 =   Xr[k] + Xr[N/2-k]  
    		SUB         dbl(*AR0+),AC1,AC3      ; Xoi = AC3 = -(Xr[k] - Xr[N/2-k])
    		
            MOV         dbl(*AR0-),AC2          ; AC2 = Xi[k]                 
            SUB			dbl(*AR1), AC2, AC1	    ; Xei = AC1 =  Xi[k] - Xi[N/2-k]             
            ADD         dbl(*AR1-),AC2,AC2      ; Xor = AC2 =  Xi[k] + Xi[N/2-k]

            SFTS        AC0,#-1                 ; Xer = 0.5*AC0
            SFTS        AC1,#-1                 ; Xei = 0.5*AC1 
            SFTS        AC2,#-1                 ; Xor = 0.5*AC2
            SFTS        AC3,#-1                 ; Xoi = 0.5*AC3
                                             
            MOV         AC0 ,dbl(*SP(#00h))     ; save Xer
            MOV         AC1 ,dbl(*SP(#02h))     ; save Xei            
            MOV         AC2 ,dbl(*SP(#04h))     ; save Xor
            MOV         AC3 ,dbl(*SP(#06h))     ; save Xoi
            
;-----------------------------------------------------------------------
;
;   Output N-point RFFT
;
;    Gr(k)     = 0.5[ Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]   
;    Gi(k)     = 0.5[ Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   
;    Gr(N/2-k) = 0.5[ Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]   
;    Gi(N/2-k) = 0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]  
;
;    Wr(k)     = cos(2Pik/N)
;    Wi(k)     = sin(2Pik/N)
;
;--------------------------------------------------------------------------------


             ; Wr(k)Xor(k)
			
			 ;  AR2 -> cos_H
			 ;		   cos_L
			 ; 
			 ;  AR4 -> Xor_H
			 ;	       Xor_L
			 ;
			 

             AMAR *AR2+
             MPYM uns(*AR2-), *AR4+, AC0	    ; AC0 = cos_L*Xor_H

             MACM *AR2, uns(*AR4-), AC0		    ; AC0 = AC0 + cos_H*Xor_L
             MACM *AR2+, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + cos_H*Xor_H 
             MOV  AC0 ,dbl(*SP(#08h))           ; save cos*Xor

             
             ; Wi(k)Xor(k)
			
			 ;  AR3 -> sin_H
			 ;	       sin_L
			 ; 
			 ;  AR4 -> Xor_H
			 ;	       Xor_L
			 ;
			 
			 AMAR *AR3+
             MPYM uns(*AR3-), *AR4+, AC0	    ; AC0 = sin_L*Xor_H
             MACM *AR3, uns(*AR4-), AC0		    ; AC0 = AC0 + sin_H*Xor_L
             MACM *AR3+, *AR4+, AC0 >> #16, AC0	; AC0 = AC0>>16 + sin_H*Xor_H 
             MOV  AC0 ,dbl(*SP(#0Ah))           ; save sin*Xor
			 AMAR *AR4+
			 
			 
             ; Wr(k)Xoi(k)
			
			 ;         cos_H
			 ;	AR2 -> cos_L
			 ; 
			 ;  AR4 -> Xoi_H
			 ;	       Xoi_L
			 ;
			 
			 
             MPYM uns(*AR2-), *AR4+, AC0	    ; AC0 = cos_L*Xoi_H
             MACM *AR2, uns(*AR4-), AC0		    ; AC0 = AC0 + cos_H*Xoi_L
             MACM *AR2, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + cos_H*Xoi_H 
             MOV  AC0 ,dbl(*SP(#0Ch))           ; save cos*Xoi
             
             			 			 
   
             ; Wi(k)Xoi(k)
			
			 ;         sin_H
			 ;	AR3 -> sin_L
			 ; 
			 ;  AR4 -> Xoi_H
			 ;	       Xoi_L
			 ;
			 
			 
            
             MPYM uns(*AR3-), *AR4+, AC0	    ; AC0 = sin_L*Xoi_H
             MACM *AR3, uns(*AR4-), AC0		    ; AC0 = AC0 + sin_H*Xoi_L
             MACM *AR3, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + sin_H*Xoi_H 
             MOV  AC0 ,dbl(*SP(#0Eh))           ; save sin*Xoi
       		             
          
          
          	; update AR4, local var pointer for next loop iteration 
          	SUB	        #2, AR4

            
            ; update the sin/cos pointers
            ; bit-reversed addressing used because twiddle table 
            ; is in bit-reversed format and normal format is needed
            ; in this algorithm.
            
         ;   !!!this requires special alignement of twiddle table ??


         	 ;  AR2 -> cos_H
			 ;	       cos_L         
         	 ;  AR3 -> sin_H
			 ;	       sin_L
         
         
            AMAR 	*(AR3+T0B)		; sin
            AMAR 	*(AR2+T0B)      ; cos
                
            
            
;    Gr(k)     = 0.5[ Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]            
                                                                                                  
            MOV         dbl(*SP(#00h)),AC0       ; AC0 = Xer(k)           								 	 
            ADD         dbl(*SP(#08h)),AC0,AC1   ; AC1 = Xer(k)+Wr(k)Xor(k)          										             
            ADD         dbl(*SP(#0Eh)),AC1,AC1   ; AC1 = Xer(k)+Wr(k)Xor(k)+Wi(k)Xoi(k)
            SFTS		AC1, #-1				 ; 0.5x
            MOV 		AC1, dbl(*AR0+)          ; Gr(k)
                                                                                                                   
;    Gi(k)     = 0.5[ Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]                                                                                                                                                            
            
            MOV         dbl(*SP(#02h)),AC1       ; AC1 = Xei(k) 
            ADD         dbl(*SP(#0Ch)),AC1,AC2   ; AC2 = Xei(k)+ Wr(k)Xoi(k)  
            SUB         dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = Xei(k)+ Wr(k)Xoi(k)-Wi(k)Xor(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR0+)			 ; Gi(k)
                 
            
;    Gr(N/2-k) = 0.5[ Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]                
             
            MOV         dbl(*SP(#00h)),AC1       ; AC1 = Xer(k) 
            SUB         dbl(*SP(#08h)),AC1,AC2   ; AC2 = Xer(k)- Wr(k)Xor(k)  
            SUB         dbl(*SP(#0Eh)),AC2,AC2   ; AC2 = Xer(k)- Wr(k)Xor(k)-Wi(k)Xoi(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR1+)			 ; Gr(N/2-k)            
             
;    Gi(N/2-k) = 0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]                
             
            MOV         dbl(*SP(#0Ch)),AC1       ; AC1 = Wr(k)Xoi(k) 
            SUB         dbl(*SP(#02h)),AC1,AC2   ; AC2 = -Xei(k)+ Wr(k)Xoi(k)  
            SUB         dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = -Xei(k)+ Wr(k)Xoi(k)-Wi(k)Xor(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR1)			 ; Gi(N/2-k)             
 
unpack_end: SUB         #6,AR1                   ; adjust to Gr(N/2-k-1)          
                        

;--------------------------------------------------------------------------------
; Step3: 
;  Special values G(N/4):
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;//-----------------------------------------------------------------------------
            MOV         dbl(*AR0+),AC0		; Xr(N/4)
            MOV         dbl(*AR0-) ,AC1		; Xi(N/4)          
            NEG         AC1,AC1				;-Xi(N/4)
            SFTS        AC0,#-1,AC0 		; 0.5*Xr(N/4)           
            SFTS        AC1,#-1,AC1  		;-0.5*Xi(N/4)          
            MOV         AC0 ,dbl(*AR0+)		;Gr(N/4) = 0.5 Xr(N/4)
    		MOV         AC1 ,dbl(*AR0+)		;Gi(N/4) =-0.5 Xi(N/4)        
                      
            
;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------
            AADD        #21,SP                  ; destroy local frame
;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
            RET

        .end
unpacki.asm/    1161799880  0     0     0       7333      `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function UNPACK
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex IFFT using bit-reversed input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
; Usage:  void unpacki(DATA *xy, ushort nx);
; Copyright Texas instruments Inc, 2000
; History;
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;****************************************************************

            .mmregs
            .cpl_on
            .arms_off
            .ref twiddle

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

            .sect ".fftcode"
            .global _unpacki

_unpacki:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
            PSH        mmap(ST0_55)
            PSH        mmap(ST1_55)
            PSH        mmap(ST2_55)
            PSH        mmap(ST3_55)

            AADD       #-2,SP                   ; create local frame
            MOV        pair(T2),dbl(*SP(#00h))  ; save on entry

;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

Initialize:
            AND         #0FF00h,mmap(ST2_55)    ; linear addr for CDP,AR2,AR3,AR0, AR1
                                                ; AR0, AR1
            BSET        #6,ST1_55               ; set FRCT
            BSET        #8,ST1_55               ; set SXMD
            BCLR        #9,ST1_55               ; set SATD
            BCLR        #15,ST2_55              ; reset ARMS
            BSET        #10,ST1_55              ; reset M40

;//-----------------------------------------------------------------------------
;// Unpack for IRFFT
;//-----------------------------------------------------------------------------
            MOV         XAR0,XAR1               ; AR1 = pointer to input data = rm[0]
            ADD         T0,AR1                  ; AR1 = pointer to input data = rm[N]
            SFTS        T0,#-1                  ; T0 = RFFT size/2 (req. for loop)
            MOV         T0,T1                   ; T1 = T0 = RFFT size/2
            SFTS        T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
            SUB         #2,AR1                  ; element in the data buffer
            SUB         #2,T1                   ; loop = N/4 - 2
            MOV         T1,BRC0                 ; and store in repeat counter 
            MOV         #-1,T2
            AMOV        #twiddle,XAR2           ; pointer to sin and cos tables
            AMOV        #(twiddle+1),XAR3       ; 
            AMAR        *(AR2+T0B)              ; set to 2nd entry of bit reversed
            AMAR        *(AR3+T0B)              ; sin/cos table 
            
;--------------------------------------------------------------------------------
; process yre[0] (DC) and yre[0] (Nyquist)
; yre[0] = 1/2(xre[0] + xim[0])    store in yre[0] 
; yre[N] = 1/2(xre[0] - xim[0])    store in yim[0]
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
            MOV         *AR0+,AC1                  ; AC1=xre[0]
            ADD         *AR0,AC1,AC0               ; AC0=xre[0]+xim[0]
            SUB         *AR0-,AC1,AC1              ; AC1=xre[0]-xim[0]
            MOV			AC0 << #-2, *AR0+          ; yre[0]=0.5*xre[0]+xim[0]
            MOV			AC1 << #-2, *AR0+          ; yim[0]=0.5*xre[0]-xim[0]
;--------------------------------------------------------------------------------
; process y1re/im
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
            RPTB        unpacki_end             ; setup loopcounter (RFFT-size)/4 - 2
             ADD         *AR0,*AR1,AC0          ; AC0 = x1Re+x2Re   
             SUB         *AR0+,*AR1+,AC3        ; AC3 = x1Re-x2Re
             SUB         *AR0,*AR1,AC1          ; AC1 = x1Im-x2Im
             ADD         *AR0-,*AR1-,AC2        ;  
             NEG		 AC2                    ; AC2 = -(x1Im+x2Im)
             SFTL        AC2,#-1,AC2            ; im = 0.5*AC3 = -0.5*(x1Re-x2Re)
             SFTL        AC3,#-1,AC3            ; rm = 0.5*AC2 = 0.5*(x1Im+x2Im)
             SFTL        AC0,#-1,AC0            ; rp = 0.5*AC0 = 0.5*(x1Re+x2Re)
             SFTL        AC1,#-1,AC1            ; ip = 0.5*AC1 = 0.5*(x1Im-x2Im)
             MOV         HI(AC2),T1             ; save rm to T1
             MOV         HI(AC3),T3             ; save im to T3  

;-----------------------------------------------------------------------
             MASM        *AR2,T1,AC0,AC2        ; y2re=AC2=rp-cos*rm
             MASM        *AR2,T3,AC1,AC3        ; y2im=AC3=ip-cos*im
             MACM        *AR2,T1,AC0,AC0        ; y1re=AC0=rp+cos*rm
             MACM        *(AR2+T0B),T3,AC1,AC1  ; y1im=AC1=ip+cos*im
;-----------------------------------------------------------------------
             ; y1re=rp+cos*rm-sin*im
             MASM        *AR3,T3,AC0,AC0        
             ; y1im=ip+cos*im+sin*rm                                         
             MACM        *AR3,T1,AC1,AC1 :: MOV         HI(AC0<<T2),*AR0+       
             ; y2re=-rp-cos*rm+sin*im
             MACM        *AR3,T3,AC2,AC2 :: MOV         HI(AC1<<T2),*AR0+       
             ; y2im=ip-cos*im-sin*rm
             MASM        *(AR3+T0B),T1,AC3,AC3       
             NEG		 AC3
             MOV         HI(AC2<<T2),*AR1+
             MOV         HI(AC3<<T2),*AR1 

unpacki_end: SUB         #3,AR1                 ; adjust to next rm
;//-----------------------------------------------------------------------------
;       yre(N/2) = yre(N/2)
;       yim(N/2) = - yim(N/2)
;
;Scaling by 2 added to avoid overflow
;//-----------------------------------------------------------------------------
            MOV         dbl(*AR0),pair(HI(AC0))
            NEG         AC1,AC1
            SFTS        AC0,#-1,AC0            
            SFTS        AC1,#-1,AC1            
            MOV         pair(HI(AC0)),dbl(*AR0)

;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------

            MOV         dbl(*SP(#00h)),pair(T2)
            AADD        #2,SP                  ; destroy local frame
            POP         mmap(ST3_55)
            POP         mmap(ST2_55)
            POP         mmap(ST1_55)
            POP         mmap(ST0_55)

;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
            RET

        .end

unpacki32.asm/  1161799875  0     0     0       15360     `
;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Function UNPACKI32
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpacki32(DATA *xy, ushort nx);
;
; Copyright Texas instruments Inc, 2000
; History;
;	- 11/20/2003	C. Iovescu initial implementation
;
;************************************************************************************
;
;  IDFT of N-point frequency domain sequence obtained from
;  a real-valued sequence.      
;
; Implementation of the rifft based on the derivation
;   
;  g(n) n=0:N-1 is a real valued sequence. The RFFT of this signal is
;  denoted G(k) k=0:N-1 complex sequence. The objective of the code is to
;  recover g(n) based on G(k).
;
;  g(n) is split in two real sequences, odd and even part
;    
;          xe(n) = g(2n)    n=0:N/2-1
;          xo(n) = g(2n+1)  n=0:N/2-1
;
;  Form the complex sequence:
;
;         x(n) = xe(n) + jxo(n)  n=0:N/2-1
;
;  The CFFT of x(n)can be expressed as:
;
;        X(k) k=0:N/2-1
;
;        X(k) = Xe(k) +j*Xo(k) k=0:N/2-1                (1)
;
;  The RFFT of g(n)can be expressed as:
;
;      G(k)     = Xe(k) + W(k,N)Xo(k)     k = 0:N/2-1   (2)
;      G(N/2+k) = Xe(k) - W(k,N)Xo(k)     k = 0:N/2-1   (3)
;
;   where W(k,n) = cos(2*PI*k/N)-j*sin(2*PI*k/N)
;         W(k,n) = Wr(k)-j*Wi(k)
;
;  (2) and (3) yield
;
;      Xe(k) = (G(k) + G(N/2+k))/2          k = 0:N/2-1       
;      Xo(k) = (G(k) - G(N/2+k))/(2*W(k,N)) k = 0:N/2-1
;
;  since g(n) is a real valued sequence the DFT has the complex
;  conjugate symmetry:
;
;     G(k) = G*(N-k)                      k = 0:N-1     (4)
;
;   And since 1/W(k,N) = W(-k, N)
;   Therefore:
;   
;     Xe(k) = (G(k) + G*(N/2-k))/2          k = 0:N/2-1  (5) 
;     Xo(k) = W(-k,N)(G(k) - G*(N/2-k))/2   k = 0:N/2-1  (6)
;
;  Separate in Real and Imag parts: 
;
;    Xr(k)+j*Xi(k) = (Xer(k)+ j*Xei(k)) +j*(Xor(k)+jXoi(k)) k=0:N/2-1 
;
;  define:
;
;     Grp(k) = (Gr(k) + Gr(N/2-k))/2   k = 0:N/2-1     (7)
;     Grm(k) = (Gr(k) - Gr(N/2-k))/2   k = 0:N/2-1     (8)
;     Gip(k) = (Gi(k) + Gi(N/2-k))/2   k = 0:N/2-1     (9)
;     Gim(k) = (Gi(k) - Gi(N/2-k))/2   k = 0:N/2-1     (10)
;
;
;    Xr(k)     = 0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]       k = 0:N/2-1  (11)
;    Xi(k)     = 0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       k = 0:N/2-1  (12)
;    Xr(N/2-k) = 0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]       k = 0:N/2-1  (13)
;    Xi(N/2-k) = 0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       k = 0:N/2-1  (14)
;       
;  Special values:
;        
;     * DC Offset  k = 0                                 
;
;     Xr(0) = 0.5*0.5*(Gr(0)+Gr(N/2))
;     Xi(0) = 0.5*0.5*(Gr(0)-Gr(N/2))
;
;    This was derived based on:
;
;           Wr(0) = 1
;           Wi(0) = 0
;           Gi(0) = Gi(N/2) = 0
;
;     * Nyquist Frequency  k = N/4                          
;
;      Xr(N/4) =  0.5*Gr(N/4) 
;      Xi(N/4) = -0.5*Gi(N/4)
;
;     This was derived based on:
;
;           Wr(N/4) = 0
;           Wi(N/4) = 1
;
;
;****************************************************************

                .mmregs
                .cpl_on
                .arms_off
                .ref twiddle32

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

                .sect ".text:unpacki32"
                .global _unpacki32

_unpacki32:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
  
; upon entry stack aligned on 32-bit boundary
  
      PSH	mmap(ST0_55)
      PSH	mmap(ST1_55)
      PSH	mmap(ST2_55)  
      PSH	mmap(ST3_55)

      AADD        #-21,SP             ; create local frame
	  
	  
;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

Initialize:
            AND         #0FF00h,mmap(ST2_55)    ; linear addr for CDP,AR2,AR3,AR0, AR1

            BSET        #6,ST1_55               ; set FRCT
            BSET        #8,ST1_55               ; set SXMD

            ; SATD = 0 required for 32-bit multiplication
            BCLR        #9,ST1_55               ; set SATD
           
            BCLR        #15,ST2_55              ; reset ARMS
            BCLR        #10,ST1_55              ; reset M40

;//-----------------------------------------------------------------------------
;// Unpack for RIFFT
;//
;//  T0 = N (Rfft size) 
;//
;//
;//
;//-----------------------------------------------------------------------------
            MOV         XAR0,XAR1               ; AR0 = start ptr input data = Xr[0]
            ADD         T0,AR1                  ; AR1 = end ptr input data 
            ADD         T0,AR1                  ; 32-bit data 
            MOV         T0,T1                   ; T1 = T0 = RFFT size/2
            SFTS        T1,#-1                  ; T1 = RFFT size/2 
            SFTS        T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
            SUB         #4,AR1                  ; AR1 = Xr[N/2-1] - last 32-bit elt
            SUB         #2,T1                   ; loop = N/4 - 2
            MOV         T1,BRC0                 ; and store in repeat counter
            AMOV        #twiddle32,XAR2         ; pointer to sin and cos tables
            AMOV        #(twiddle32+2),XAR3     ; 32-bit values (add 2)
            AMAR        *(AR2+T0B)              ; set to 2nd entry of bit reversed
            AMAR        *(AR3+T0B)              ; sin/cos table 
												; T0 = RFFT size for bitrev because 32-bit values
			MOV         XSP,XAR4   				; XAR4 local var ptr (stack)
			ADD	        #4, AR4

;--------------------------------------------------------------------------------
; Step1: 
;  Special values X(0):
;        
;     * DC Offset  k = 0                                    
;
;           Xr(0) = 0.5*0.5 (Gr(0)+Gi(N/2)) 
;           Xi(0) = 0.5*0.5 (Gr(0)-Gi(N/2))
;
;     Note: Gi(N/2) is stored as the imag part of G(0).
;
;--------------------------------------------------------------------------------
            MOV         dbl(*AR0+),AC1           ; AC1 = Gr[0]
            ADD         dbl(*AR0),AC1,AC0        ; AC0 = Gr[0] + Gi[N/2]          										             
            SUB         dbl(*AR0-),AC1,AC1     	 ; AC1 = Gr[0] - Gi[N/2]
       
            SFTS		AC0, #-2			 ; 0.25x
            SFTS		AC1, #-2			 ; 0.25x
                      
            MOV			AC0, dbl(*AR0+)    ; Xr(0)
            MOV			AC1, dbl(*AR0+)    ; Xi(0)
;--------------------------------------------------------------------------------
; Step 2: 
;
; General loop X(k) k=1:N/2-1  k<>N/4 (X(k)&X(N/2-k) computed in same iteration)
;  
;     Grp(k) = 0.5 (Gr(k) + Gr(N/2-k))   k = 1:N/4-1     
;     Grm(k) = 0.5 (Gr(k) - Gr(N/2-k))   k = 1:N/4-1     
;     Gip(k) = 0.5 (Gi(k) + Gi(N/2-k))   k = 1:N/4-1     
;     Gim(k) = 0.5 (Gi(k) - Gi(N/2-k))   k = 1:N/4-1      
;
;--------------------------------------------------------------------------------
            RPTB        unpack_end              ; setup loopcounter (RFFT-size)/4 - 2

            MOV         dbl(*AR0+),AC1          ; AC1 = Gr[k]           								 	
            ADD         dbl(*AR1),AC1,AC0       ; Grp = AC0 =   Gr[k] + Gr[N/2-k]  
    		SUB         dbl(*AR1+),AC1,AC3      ; Grm = AC3 =   Gr[k] - Gr[N/2-k]
    		
            MOV         dbl(*AR0-),AC2          ; AC2 = Gi[k]                 
            ADD			dbl(*AR1), AC2, AC1		; Gip = AC1 =  Gi[k] + Gi[N/2-k]             
            SUB         dbl(*AR1-),AC2,AC2      ; Gim = AC2 =  Gi[k] - Gi[N/2-k]

            SFTS        AC0,#-1                 ; Grp = 0.5*AC0
            SFTS        AC1,#-1                 ; Gip = 0.5*AC1 
            SFTS        AC2,#-1                 ; Gim = 0.5*AC2
            SFTS        AC3,#-1                 ; Grm = 0.5*AC3
                                             
            MOV         AC0 ,dbl(*SP(#00h))     ; save Grp
            MOV         AC1 ,dbl(*SP(#04h))     ; save Gip            
            MOV         AC2 ,dbl(*SP(#02h))     ; save Gim
            MOV         AC3 ,dbl(*SP(#06h))     ; save Grm
            
;-----------------------------------------------------------------------
;
;   Output for N/2-point CIFFT
;
;    Xr(k)     = 0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]      
;    Xi(k)     = 0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       
;    Xr(N/2-k) = 0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]       
;    Xi(N/2-k) = 0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]         
;
;    Wr(k)     = cos(2Pik/N)
;    Wi(k)     = sin(2Pik/N)
;
;--------------------------------------------------------------------------------


             ; Wr(k)Gip(k)
			
			 ;  AR2 -> cos_H
			 ;	     cos_L
			 ; 
			 ;  AR4 -> Gip_H
			 ;	     Gip_L
			 ;
			 

             AMAR *AR2+
             MPYM uns(*AR2-), *AR4+, AC0	    ; AC0 = cos_L*Gip_H

             MACM *AR2, uns(*AR4-), AC0		    ; AC0 = AC0 + cos_H*Gip_L
             MACM *AR2+, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + cos_H*Gip_H 
             MOV  AC0 ,dbl(*SP(#08h))           ; save cos*Gip

             
             ; Wi(k)Gip(k)
			
			 ;  AR3 -> sin_H
			 ;	     sin_L
			 ; 
			 ;  AR4 -> Gip_H
			 ;	     Gip_L
			 ;
			 
			 AMAR *AR3+
             MPYM uns(*AR3-), *AR4+, AC0	    ; AC0 = sin_L*Gip_H
             MACM *AR3, uns(*AR4-), AC0		    ; AC0 = AC0 + sin_H*Gip_L
             MACM *AR3+, *AR4+, AC0 >> #16, AC0	; AC0 = AC0>>16 + sin_H*Gip_H 
             MOV  AC0 ,dbl(*SP(#0Ah))           ; save sin*Gip
			 AMAR *AR4+
			 
			 
             ; Wr(k)Grm(k)
			
			 ;         cos_H
			 ;  AR2 -> cos_L
			 ; 
			 ;  AR4 -> Grm_H
			 ;	     Grm_L
			 ;
			 
			 
             MPYM uns(*AR2-), *AR4+, AC0	    ; AC0 = cos_L*Grm_H
             MACM *AR2, uns(*AR4-), AC0		    ; AC0 = AC0 + cos_H*Grm_L
             MACM *AR2, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + cos_H*Grm_H 
             MOV  AC0 ,dbl(*SP(#0Ch))           ; save cos*Grm
             
             			 			 
   
             ; Wi(k)Grm(k)
			
			 ;         sin_H
			 ;	AR3 -> sin_L
			 ; 
			 ;  AR4 -> Grm_H
			 ;	       Grm_L
			 ;
			 
			 
            
             MPYM uns(*AR3-), *AR4+, AC0	    ; AC0 = sin_L*Grm_H
             MACM *AR3, uns(*AR4-), AC0		    ; AC0 = AC0 + sin_H*Grm_L
             MACM *AR3, *AR4, AC0 >> #16, AC0	; AC0 = AC0>>16 + sin_H*Grm_H 
             MOV  AC0 ,dbl(*SP(#0Eh))           ; save sin*Grm
       		             
          
          
          	; update AR4, local var pointer for next loop iteration 
          	SUB	        #2, AR4

            
            ; update the sin/cos pointers
            ; bit-reversed addressing used because twiddle table 
            ; is in bit-reversed format and normal format is needed
            ; in this algorithm.
            
         


         	 ;  AR2 -> cos_H
			 ;	       cos_L         
         	 ;  AR3 -> sin_H
			 ;	       sin_L
         
         
            AMAR 	*(AR3+T0B)		; sin
            AMAR 	*(AR2+T0B)      ; cos
                
            
;     Xr(k)     =0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]                       
                                                                                                  
            MOV         dbl(*SP(#00h)),AC0       ; AC0 = Grp(k)           								 	 
            SUB         dbl(*SP(#08h)),AC0,AC1   ; AC1 = Grp(k)-Wr(k)Gip(k)          										             
            SUB         dbl(*SP(#0Eh)),AC1,AC1   ; AC1 = Grp(k)-Wr(k)Gip(k)-Wi(k)Grm(k)
            SFTS		AC1, #-1				 ; 0.5x
            MOV 		AC1, dbl(*AR0+)          ; Xr(k)
 

;    Xi(k)     =0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]                                                                                                                        
                                                                                                                                                            
            
            MOV         dbl(*SP(#02h)),AC1       ; AC1 = Gim(k) 
            ADD         dbl(*SP(#0Ch)),AC1,AC2   ; AC2 = Gim(k)+ Wr(k)Grm(k)  
            SUB         dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = Gim(k)+ Wr(k)Grm(k)-Wi(k)Gip(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR0+)			 ; Xi(k)
                 

;    Xr(N/2-k) =0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]                   
             
             
            MOV         dbl(*SP(#00h)),AC1       ; AC1 = Grp(k) 
            ADD         dbl(*SP(#08h)),AC1,AC2   ; AC2 = Grp(k)+ Wr(k)Gip(k)  
            ADD         dbl(*SP(#0Eh)),AC2,AC2   ; AC2 = Grp(k)+ Wr(k)Gip(k)+Wi(k)Grm(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR1+)			 ; Xr(N/2-k)            

;    Xi(N/2-k) =0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]                              
             
            MOV         dbl(*SP(#0Ch)),AC1       ; AC1 = Wr(k)Grm(k) 
            SUB         dbl(*SP(#02h)),AC1,AC2   ; AC2 = -Gim(k)+ Wr(k)Grm(k)  
            SUB         dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = -Gim(k)+ Wr(k)Grm(k)-Wi(k)Gip(k)  
            SFTS		AC2, #-1				 ; 0.5x    
            MOV 		AC2, dbl(*AR1)			 ; Xi(N/2-k)             
 
unpack_end: SUB         #6,AR1                   ; adjust to Gr(N/2-k-1)          
                        

;--------------------------------------------------------------------------------
; Step3: 
;  Special values G(N/4):
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;//-----------------------------------------------------------------------------
            MOV         dbl(*AR0+),AC0		; Xr(N/4)
            MOV         dbl(*AR0-) ,AC1		; Xi(N/4)          
            NEG         AC1,AC1				;-Xi(N/4)
            SFTS        AC0,#-1,AC0 		; 0.5*Xr(N/4)           
            SFTS        AC1,#-1,AC1  		;-0.5*Xi(N/4)          
            MOV         AC0 ,dbl(*AR0+)		;Gr(N/4) = 0.5 Xr(N/4)
    		MOV         AC1 ,dbl(*AR0+)		;Gi(N/4) =-0.5 Xi(N/4)        
                      
            
;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------
            AADD        #21,SP                  ; destroy local frame
;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
      POP	mmap(ST3_55)
      POP	mmap(ST2_55)
      POP	mmap(ST1_55)
      POP	mmap(ST0_55)
            RET

        .end
Dsplib.h/       1138291600  0     0     0       5245      `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _DSPLIB
#define _DSPLIB

#include <tms320.h>

/* 32-bit fft */

void cfft32_SCALE(LDATA *x, ushort nx);
void cfft32_NOSCALE(LDATA *x, ushort nx);
void cifft32_SCALE (LDATA *x,  ushort nx);
void cifft32_NOSCALE (LDATA *x,  ushort nx);


/* 16-bit fft */

void cfft_SCALE(DATA *x, ushort nx);
void cfft_NOSCALE(DATA *x, ushort nx);
void cifft_SCALE (DATA *x,  ushort nx);
void cifft_NOSCALE (DATA *x,  ushort nx);

void unpack(DATA *x, ushort nx);
void unpacki(DATA *x, ushort nx);
/* void rfft(DATA *x, ushort nx, ushort scale); */
/* void rifft(DATA *x,  ushort nx, ushort scale); */

/* 16-bit bit reversal */

void cbrev (DATA *x, DATA *y, ushort n);


/* correlations */

ushort acorr_raw(DATA *x, DATA *r, ushort nx, ushort nr);
ushort acorr_bias(DATA *x, DATA *r, ushort nx, ushort nr);
ushort acorr_unbias(DATA *x, DATA *r, ushort nx, ushort nr);

ushort corr_raw	(DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
ushort corr_bias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
ushort corr_unbias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);

/* filtering and convolution */

ushort convol(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);
ushort convol1(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);
ushort convol2(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);

ushort fir(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
ushort fir2(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
ushort firs(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh2);
ushort cfir(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);

ushort iircas4(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
ushort iircas5(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
ushort iircas51(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);

ushort firlat (DATA *x, DATA *h, DATA *r, DATA *pbuffer, int nx, int nh);
ushort iirlat (DATA *x, DATA *h, DATA *r, DATA *pbuffer, int nx, int nh);

ushort hilb16(DATA *x, DATA *h, DATA*r, DATA *dbuffer, ushort nx, ushort nh);
ushort firdec(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nh, ushort nx, ushort D);
ushort firinterp(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nh, ushort nx, ushort I);
ushort iir32(DATA *x,LDATA *h,DATA *r,LDATA *d, ushort nbiq, ushort nx);

/* adaptive filtering */

ushort dlms(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);
ushort dlmsfast(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);


/* math */
ushort add(DATA *x, DATA *y,  DATA *r,  ushort nx,  ushort scale);
ushort sub(DATA *x, DATA *y,  DATA *r,  ushort nx,  ushort scale);
ushort neg (DATA *x, DATA *r, ushort nx);
ushort neg32 (LDATA *x, LDATA *r, ushort nx);
ushort power (DATA *x, LDATA *r, ushort nx);

ushort sqrt_16(DATA *x, DATA *r, short nx);
void ldiv16(LDATA *x, DATA *y,DATA *r, DATA *rexp, ushort nx);
void recip16(DATA *x, DATA *r, DATA *rexp, ushort nx);

ushort mul32(LDATA *x, LDATA *y,  LDATA *r, ushort nx);

ushort expn(DATA *x, DATA *r, ushort nx);
ushort logn(DATA *x, LDATA *r, ushort nx);
ushort log_2(DATA *x, LDATA *r, ushort nx);
ushort log_10(DATA *x, LDATA *r, ushort nx);
short bexp (DATA *x, ushort nx);


short maxidx (DATA *x, ushort ng, ushort ng_size);
short maxidx34 (DATA *x, ushort nx);
short maxval (DATA *x, ushort nx);
short minidx (DATA *x, ushort ng, ushort ng_size);
short minval (DATA *x, ushort nx);

void maxvec (DATA *x, ushort nx, DATA *val, DATA *idx);
void minvec (DATA *x, ushort nx, DATA *val, DATA *idx);

/* matrix */

ushort mmul(DATA *x1,short row1,short col1,DATA *x2,short row2,short col2,DATA *r);
ushort mtrans(DATA *x, short row, short col, DATA *r);


/* trigonometric */

ushort atan16(DATA *x, DATA *r, ushort nx);
ushort atan2_16(DATA *i, DATA *q, DATA *r, ushort nx);
ushort sine(DATA *x, DATA *r, ushort nx);


/* miscellaneous */

ushort fltoq15(float *x, DATA *r, ushort nx);
ushort q15tofl(DATA *x, float *r, ushort nx);

ushort rand16(DATA *r, ushort nr);
void rand16init(void);




/* macro definition */

#define SCALE 1
#define NOSCALE 0

#define cfft(x,nx, type)   cfft_##type(x,nx)
#define cifft(x,nx, type)   cifft_##type(x,nx)


#define acorr(n1, n2, n3, n4, type) acorr_##type(n1, n2, n3, n4)
#define corr(n1, n2, n3, n4, n5, type) corr_##type(n1, n2, n3, n4, n5)
#define rfft(x,nx,type)\
    (\
         cfft_##type(x,nx/2),\
         cbrev(x,x,nx/2),\
         unpack(x,nx)\
    )

#define rifft(x,nx,type)\
    (\
        unpacki(x, nx),\
        cifft_##type(x,nx/2),\
        cbrev(x,x,nx/2)\
    )


#define rfft32(x,nx,type)\
    (\
         cfft32_##type(x,nx/2),\
         cbrev32(x,x,nx/2),\
         unpack32(x,nx)\
    )

#define rifft32(x,nx,type)\
    (\
        unpacki32(x, nx),\
        cifft32_##type(x,nx/2),\
        cbrev32(x,x,nx/2)\
    )

#endif

Dsplib_c.h/     1138291600  0     0     0       1306      `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _DSPLIBC
#define _DSPLIBC

#include <tms320.h>


/* correlations */

void acorr_c_raw(DATA *x, DATA *r, ushort nx, ushort nr);
void acorr_c_bias(DATA *x, DATA *r, ushort nx, ushort nr);
void acorr_c_unbias(DATA *x, DATA *r, ushort nx, ushort nr);

/* filtering and convolution */


void fir_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
void fir2_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
void firs_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh2);
void cfir_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);

void iircas4_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
void iircas5_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
void iircas51_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);


/* adaptive filtering */

void dlms_c(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);


/* macro definition */


#define acorr_c(n1, n2, n3, n4, type) acorr_c_##type(n1, n2, n3, n4)

#endif
math.h/         1138291600  0     0     0       2452      `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _MATH
#define _MATH

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

#define HUGE_VAL  3.40232347E+38F

/***************************************************************/
/* FUNCTION DECLARATIONS.                                      */
/***************************************************************/
         double asin(double _x);
         double acos(double _x);
         double atan(double _x);
         double atan2(double _y, double _x);
__INLINE double ceil(double _x);
         double cos(double _x);
         double cosh(double _x);
         double exp(double _x);
         double fabs(double _x);
__INLINE double floor(double _x);
__INLINE double fmod(double _x, double _y);
         double frexp(double _x, int *_exp);
         double ldexp(double _x, int _exp);
         double log(double _x);
         double log10(double _x);
         double modf(double _x, double *_iptr);
         double pow(double _x, double _y);
         double sin(double _x);
         double sinh(double _x);
         double sqrt(double _x);
         double tan(double _x);
         double tanh(double _x);

#if _INLINE
/****************************************************************************/
/*  ceil()       				                            */
/****************************************************************************/
static inline double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}

/****************************************************************************/
/*  floor()      				                            */
/****************************************************************************/
static inline double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}

/****************************************************************************/
/*  fmod()       				                            */
/****************************************************************************/
static inline double fmod(double x, double y)
{
   double d = fabs(x); 

   if (d - fabs(y) == d) return (0.0);
   modf(x/y, &d);
   return (x - d * y);
}
#endif /* _INLINE */
#undef __INLINE

#endif /* _MATH   */
MISC.H/         1138291600  0     0     0       363       `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _MISC
#define _MISC

#define PI	  3.14159265358979323846 // PI value
#define CONV	  32767.999999	   	// Q15-> float conversion value = 2^15- 2^1-15 

#endif


stdio.h/        1138291600  0     0     0       10130     `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _STDIO 
#define _STDIO

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t;                                           
#endif

typedef struct {
         int fd;                    /* File descriptor */
         unsigned char* buf;        /* Pointer to start of buffer */
         unsigned char* pos;        /* Position in buffer */
         unsigned char* bufend;     /* Pointer to end of buffer */
         unsigned char* buff_stop;  /* Pointer to last read char in buffer */
         unsigned int   flags;      /* File status flags (see below) */
         int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
typedef long fpos_t;
#endif

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL (void *) 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do no    -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */
#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#define stdevice        (&_device[0])        /* Default device (host)       */

typedef struct {                             
   char  name[9];
   unsigned short flags;
   int (*OPEN) ();
   int (*CLOSE) ();
   int (*READ) ();
   int (*WRITE) ();
   long (*LSEEK) ();
   int (*UNLINK) ();
   int (*RENAME) ();
} _DEVICE;

extern FILE _ftable[_NFILE];
extern char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
       int     remove(const char *_file);
extern int     rename(const char *_old, const char *_new);
extern FILE   *tmpfile(void);
extern char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern int    fclose(FILE *_fp); 
extern FILE   *fopen(const char *_fname, const char *_mode);
extern FILE   *freopen(const char *_fname, const char *_mode,
               register FILE *_fp);
extern void    setbuf(register FILE *_fp, char *_buf);
extern int     setvbuf(register FILE *_fp, register char *_buf, 
                       register int _type,  register size_t _size); 
extern int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fprintf(FILE *_fp, const char *_format, ...);
extern int     fscanf(FILE *_fp, const char *_fmt, ...);
extern int     printf(const char *_format, ...);
extern int     scanf(const char *_fmt, ...);
extern int     sprintf(char *_string, const char *_format, ...);
extern int     sscanf(const char *_str, const char *_fmt, ...);
extern int     vfprintf(FILE *_fp, const char *_format, char *_ap);
extern int     vprintf(const char *_format, char *_ap);
extern int     vsprintf(char *_string, const char *_format, char *_ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fgetc(register FILE *_fp);
extern char   *fgets(char *_ptr, register int _size, register FILE *_fp);
extern int     fputc(int _c, register FILE *_fp);
extern int     fputs(const char *_ptr, register FILE *_fp);
extern int     getc(FILE *_p);
       int     getchar(void);
extern char   *gets(char *_ptr); 
extern int     putc(int _x, FILE *_fp);
       int     putchar(int _x);
extern int     puts(const char *_ptr); 
extern int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern size_t    fread(void *_ptr, size_t _size, size_t _count, FILE *_fp);
extern size_t    fwrite(const void *_ptr, size_t _size, size_t _count,
                        register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern int       fgetpos(FILE *_fp, fpos_t *_pos);
extern int       fseek(register FILE *_fp, long _offset, int _ptrname);
extern int       fsetpos(FILE *_fp, const fpos_t *_pos);
extern long  ftell(FILE *_fp);
extern void  rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
       void      clearerr(FILE *_fp);
extern int       feof(FILE *_fp);
       int       ferror(FILE *_fp);
extern void      perror(const char *_s);
                

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

/******* END OF ANSI FUNCTIONS  *********************************************/


/****************************************************************************/
/* GETENV IS SUPPOSED TO BE IN STDLIB.H IN THE RTS.LIB, BUT BECAUSE STDIO.H */
/* IS THE ONLY HEADER FILE THAT USES ROUTINES TO INTERFACE WITH THE HOST    */
/* OPERATING SYSTEM, GETENV WAS PLACED HERE.                                */
/****************************************************************************/
char            *getenv(const char *_string);

/****************************************************************************/
/* LOW LEVEL FUNCTION PROTOTYPES                                            */
/****************************************************************************/
extern int       add_device(char           *name,
                            unsigned        flags,
                  int            (*dopen)(),
                  int            (*dclose)(),
                  int            (*dread)(),
                  int            (*dwrite)(),
                  long           (*dlseek)(),
                  int            (*dunlink)(),
                  int            (*drename)());
#endif
TMS320.H/       1138291600  0     0     0       478       `
/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _TMS320
#define _TMS320
 
typedef unsigned int   uint;
typedef unsigned short ushort;  
#define PASS -1


  typedef short DATA;
  typedef long LDATA;
  #define ABSVAL abs
  #define SHIFT15 >>15
  #define SHIFT1  /2
  #define ROUND 0x400
  #define DIV2	>>1

#endif
