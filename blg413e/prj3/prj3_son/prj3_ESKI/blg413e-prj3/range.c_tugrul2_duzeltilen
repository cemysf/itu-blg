#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/errno.h>
#include <linux/uaccess.h>

MODULE_LICENSE("Dual BSD/GPL");
MODULE_AUTHOR("cem");

int major=0;
int minor=0;
int count=1;
dev_t device_no=0;
int return_val=0;	// return 0 if nothing goes wrong..


struct range_dev{
	struct cdev cdev;
	int step, start, end, counter;
	struct semaphore sem;
	/// TODO: diğer datalar..

};
struct range_dev *device_ptr;



int range_open(struct inode *inode, struct file *filp)
{
    struct range_dev *dev;

    dev = container_of(inode->i_cdev, struct range_dev, cdev);
    filp->private_data = dev;
    dev->start = 0;
    dev->end = 5;
    dev->step = 1;
    dev->counter = dev->start;
    
    return 0;
}


int range_release(struct inode *inode, struct file *filp)
{
    return 0;
}

ssize_t range_read(struct file *filp, int __user *buf, size_t count)
{
    struct range_dev *dev = filp->private_data;
    int i, *array, n_int;
    ssize_t retval = 0;

    if (down_interruptible(&dev->sem))
        return -ERESTARTSYS;
    
    n_int = count / sizeof(int);
    
    if(n_int * dev->step + dev->counter > dev->end){
		n_int = dev->end - dev->counter / dev->step;
	} 
    
    array = kmalloc(n_int*sizeof(int), GFP_KERNEL);
    
    for(i=0;i<n_int;i++){
		array[i] = i*dev->step+dev->counter;
	}

    if (copy_to_user(buf, array, n_int * sizeof(int))) {
        retval = -EFAULT;
        goto out;
    }
	dev->counter = array[n_int-1] + dev->step;
	retval = n_int*sizeof(int);
  out:
  	kfree(array);
    up(&dev->sem);
    return retval;
}

/// ioctlFunct

struct file_operations fops = {
	.owner = THIS_MODULE,
	.open = range_open,
	.release = range_release,
	// TODO: fonksiyonlar yazılacak
	.read = range_read,
//	.ioctl = ioctlFunct,
};


static void rangeSetup(int index)
{
	int devno=MKDEV(major, minor+index);
	int err_no;

	cdev_init(&device_ptr->cdev, &fops);
	device_ptr->cdev.ops = &fops;
	device_ptr->cdev.owner = THIS_MODULE;
	err_no = cdev_add(&device_ptr->cdev, devno, 1);
	if (err_no!=0)
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot add range no:%d\n",err_no, index);
	else
		printk(KERN_ALERT "blg413e prj3 - (INFO) cdev index:%d added\n", index);

}

int initModule(void)
{
	int i;					// loop iterator
	printk(KERN_ALERT "blg413e prj3 - (INFO) initializing module\n"); 

	// dynamically allocate device numbers
	// device_no: holds the first number in allocation (if allocation is successfull)
	// minor: requested first minor (usually 0)
	// count: total number of continious device numbers requested
	return_val= alloc_chrdev_region(&device_no, minor, count, "range");
	major=MAJOR(device_no);
	if (return_val!=0)
	{
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot initialize module\n",return_val);
		return return_val;
	}
	
	device_ptr = kmalloc(count * sizeof(struct range_dev), GFP_KERNEL);
	if (device_ptr==NULL)
	{
		return_val = -ENOMEM;
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot allocate memory\n",return_val);	
		return return_val;
	}

	
	for(i=0; i<count; i++)
	{
		rangeSetup(i);
	}


	printk(KERN_ALERT "blg413e prj3 - (INFO) initialized devno:%d, major:%d\n" ,device_no, major);	
	return return_val;
}

void exitModule(void)
{
	dev_t devno = MKDEV(major, minor);
	int i;
	
	if(device_ptr!=NULL)
	{
		for(i=0; i< count; i++)
			cdev_del(&device_ptr[i].cdev);
		kfree(device_ptr);
	}
	
	
	unregister_chrdev_region(devno, count);
	printk(KERN_ALERT "blg413e prj3 - (INFO) exit module devno:%d, major:%d\n",devno, major); 
}

module_init(initModule);
module_exit(exitModule);

