#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/errno.h>

MODULE_LICENSE("Dual BSD/GPL");
MODULE_AUTHOR("cem");

int major=0;
int minor=0;
int count=1;
dev_t device_no=0;
int return_val=0;	// return 0 if nothing goes wrong..

struct range_dev{
	struct cdev cdev;
	/// TODO: diÄŸer datalar..
	int counter;
	int increment;
};
struct range_dev *device_ptr;


int openFunct(void)
{
	printk(KERN_ALERT "blg413e prj3 - open called\n");

	return 0;

}


ssize_t readFunct(struct inode *inode)
{
	//printk(KERN_ALERT "blg413e prj3 - (INFO) count=%d, (increment=%d)\n", , );
	printk(KERN_ALERT "blg413e prj3 - read called\n");

	struct range_dev *dev;
	dev = container_of(inode->i_cdev, struct range_dev, cdev);

	



	return 0;
}


struct file_operations fops = {
	.owner = THIS_MODULE,
	.open = openFunct,
	//.release = releaseFunct,
	.read = readFunct,
//	.ioctl = ioctlFunct,
};
//ssize_t readFunct(struct file *filp, char __user *buffer, size_t, loff_t *)
//{

//}

/// ioctlFunct


static void rangeSetup(int index)
{
	int devno=MKDEV(major, minor+index);
	int err_no;

	cdev_init(&device_ptr->cdev, &fops);
	device_ptr->cdev.ops = &fops;
	device_ptr->cdev.owner = THIS_MODULE;
	err_no = cdev_add(&device_ptr->cdev, devno, 1);
	if (err_no!=0)
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot register devno:%d index:%d\n",err_no, devno, index);
	else
		printk(KERN_ALERT "blg413e prj3 - (INFO) registered devno:%d index:%d\n",devno, index);

}


int initModule(void)
{
	int i;					// loop iterator
	printk(KERN_ALERT "blg413e prj3 - (INFO) initializing module\n"); 

	// dynamically allocate device numbers
	// device_no: holds the first number in allocation (if allocation is successfull)
	// minor: requested first minor (usually 0)
	// count: total number of continious device numbers requested
	return_val= alloc_chrdev_region(&device_no, minor, count, "range");
	major=MAJOR(device_no);
	if (return_val!=0)
	{
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot initialize module\n",return_val);
		return return_val;
	}
	
	// allocate memory for devices
	device_ptr = kmalloc(count * sizeof(struct range_dev), GFP_KERNEL);
	if (device_ptr==NULL)
	{
		return_val = -ENOMEM;
		printk(KERN_ALERT "blg413e prj3 - (ERROR:%d) cannot allocate memory\n",return_val);	
		return return_val;
	}
	memset(device_ptr, 0, count * sizeof(struct range_dev));
	
	// register devices
	for(i=0; i<count; i++)
	{
		rangeSetup(i);
	}


	printk(KERN_ALERT "blg413e prj3 - (INFO) initialized with major:%d\n", major);	
	return return_val;
}

void exitModule(void)
{
	dev_t devno = MKDEV(major, minor);
	int i;
	
	if(device_ptr!=NULL)
	{
		for(i=0; i< count; i++)
			cdev_del(&device_ptr[i].cdev);
		kfree(device_ptr);
	}
	
	
	unregister_chrdev_region(devno, count);
	printk(KERN_ALERT "blg413e prj3 - (INFO) exit module major:%d\n", major); 
}

module_init(initModule);
module_exit(exitModule);

